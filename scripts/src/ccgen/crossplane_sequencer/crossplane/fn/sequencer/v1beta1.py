# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ....k8s.apimachinery.pkg.apis.meta import v1


class Rule(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Rule"]:
            return Rule

        def build(self) -> "Rule":
            return Rule(**self._attrs)

        def sequence(self, value: Optional[List[str]], /) -> Self:
            """
            TODO: Should we add a way to infer sequencing from usages? e.g. InferFromUsages: true InferFromUsages bool            `json:"inferFromUsages,omitempty"`
            """
            return self._set("sequence", value)

    class BuilderContext(BuilderContextBase["Rule.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Rule.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Rule."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Rule", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Rule.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    sequence: Optional[List[str]] = None
    """
    TODO: Should we add a way to infer sequencing from usages? e.g. InferFromUsages: true InferFromUsages bool            `json:"inferFromUsages,omitempty"`
    """


class Input(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Input"]:
            return Input

        def build(self) -> "Input":
            return Input(**self._attrs)

        def api_version(
            self, value: Optional[Literal["sequencer.fn.crossplane.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Input"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(self, value_or_callback: Optional[v1.ObjectMeta], /) -> "Input.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "Input.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def rules(self, value_or_callback: List[Rule], /) -> "Input.Builder": ...

        @overload
        def rules(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Rule, Rule.Builder]],
                GenericListBuilder[Rule, Rule.Builder] | List[Rule],
            ],
            /,
        ) -> "Input.Builder": ...

        @overload
        def rules(self, value_or_callback: Never = ...) -> ListBuilderContext[Rule.Builder]: ...

        def rules(self, value_or_callback=None, /):
            """
            Rules is a list of rules that describe sequences of resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Rule.Builder]()
                context._parent_builder = self
                context._field_name = "rules"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Rule.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("rules", value)

    class BuilderContext(BuilderContextBase["Input.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Input.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Input."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Input", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Input.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["sequencer.fn.crossplane.io/v1beta1"]],
        Field(alias="apiVersion"),
    ] = "sequencer.fn.crossplane.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Input"]] = "Input"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    rules: List[Rule]
    """
    Rules is a list of rules that describe sequences of resources.
    """
