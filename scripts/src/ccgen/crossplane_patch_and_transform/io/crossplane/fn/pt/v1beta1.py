# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ....k8s.apimachinery.pkg.apis.meta import v1


class String(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["String"]:
            return String

        def build(self) -> "String":
            return String(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["String.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = String.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for String."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["String", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use String.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class Variable(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Variable"]:
            return Variable

        def build(self) -> "Variable":
            return Variable(**self._attrs)

        def from_field_path(self, value: str, /) -> Self:
            """
            FromFieldPath is the path of the field on the source whose value is
            to be used as input.
            """
            return self._set("from_field_path", value)

    class BuilderContext(BuilderContextBase["Variable.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Variable.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Variable."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Variable", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Variable.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path: Annotated[str, Field(alias="fromFieldPath")]
    """
    FromFieldPath is the path of the field on the source whose value is
    to be used as input.
    """


class Combine(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Combine"]:
            return Combine

        def build(self) -> "Combine":
            return Combine(**self._attrs)

        def strategy(self, value: Literal["string"], /) -> Self:
            """
            Strategy defines the strategy to use to combine the input variable values.
            Currently only string is supported.
            """
            return self._set("strategy", value)

        @overload
        def string(self, value_or_callback: Optional[String], /) -> "Combine.Builder": ...

        @overload
        def string(
            self,
            value_or_callback: Callable[[String.Builder], String.Builder | String],
            /,
        ) -> "Combine.Builder": ...

        @overload
        def string(self, value_or_callback: Never = ...) -> "String.BuilderContext": ...

        def string(self, value_or_callback=None, /):
            """
            String declares that input variables should be combined into a single
            string, using the relevant settings for formatting purposes.
            """
            if self._in_context and value_or_callback is None:
                context = String.BuilderContext()
                context._parent_builder = self
                context._field_name = "string"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(String.builder())
                if isinstance(output, String.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("string", value)

        @overload
        def variables(self, value_or_callback: List[Variable], /) -> "Combine.Builder": ...

        @overload
        def variables(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Variable, Variable.Builder]],
                GenericListBuilder[Variable, Variable.Builder] | List[Variable],
            ],
            /,
        ) -> "Combine.Builder": ...

        @overload
        def variables(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Variable.Builder]: ...

        def variables(self, value_or_callback=None, /):
            """
            Variables are the list of variables whose values will be retrieved and
            combined.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Variable.Builder]()
                context._parent_builder = self
                context._field_name = "variables"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Variable.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("variables", value)

    class BuilderContext(BuilderContextBase["Combine.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Combine.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Combine."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Combine", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Combine.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    strategy: Literal["string"]
    """
    Strategy defines the strategy to use to combine the input variable values.
    Currently only string is supported.
    """
    string: Optional[String] = None
    """
    String declares that input variables should be combined into a single
    string, using the relevant settings for formatting purposes.
    """
    variables: Annotated[List[Variable], Field(min_length=1)]
    """
    Variables are the list of variables whose values will be retrieved and
    combined.
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def from_field_path(self, value: Optional[Literal["Optional", "Required"]], /) -> Self:
            """
            FromFieldPath specifies how to patch from a field path. The default is
            'Optional', which means the patch will be a no-op if the specified
            fromFieldPath does not exist. Use 'Required' to prevent the creation of a
            new composed resource until the required path exists.
            """
            return self._set("from_field_path", value)

        def to_field_path(
            self,
            value: Optional[
                Literal[
                    "Replace",
                    "MergeObjects",
                    "MergeObjectsAppendArrays",
                    "ForceMergeObjects",
                    "ForceMergeObjectsAppendArrays",
                    "MergeObject",
                    "AppendArray",
                ]
            ],
            /,
        ) -> Self:
            """
            ToFieldPath specifies how to patch to a field path. The default is
            'Replace', which means the patch will completely replace the target field,
            or create it if it does not exist. Use 'MergeObjects' to recursively merge the patch
            object with the target object, while keeping target object keys, but overwriting any array values, or use
            'MergeObjectsAppendArrays' to recursively merge the patch object with the target object, while keeping
            target object keys and appending any array values to target array values, or use
            'ForceMergeObjects' to recursively merge the patch object with the target object, overwriting
            any target object keys, including array values, or use
            'ForceMergeObjectsAppendArrays' to recursively merge the patch object with the target object,
            overwriting target object keys, and appending any array values to target array values.
            'MergeObject' is deprecated, use 'MergeObjects' instead, which is functionally identical.
            'AppendArray' is deprecated, use 'ForceMergeObjectsAppendArrays' instead, which is functionally identical.
            """
            return self._set("to_field_path", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path: Annotated[
        Optional[Literal["Optional", "Required"]], Field(alias="fromFieldPath")
    ] = None
    """
    FromFieldPath specifies how to patch from a field path. The default is
    'Optional', which means the patch will be a no-op if the specified
    fromFieldPath does not exist. Use 'Required' to prevent the creation of a
    new composed resource until the required path exists.
    """
    to_field_path: Annotated[
        Optional[
            Literal[
                "Replace",
                "MergeObjects",
                "MergeObjectsAppendArrays",
                "ForceMergeObjects",
                "ForceMergeObjectsAppendArrays",
                "MergeObject",
                "AppendArray",
            ]
        ],
        Field(alias="toFieldPath"),
    ] = None
    """
    ToFieldPath specifies how to patch to a field path. The default is
    'Replace', which means the patch will completely replace the target field,
    or create it if it does not exist. Use 'MergeObjects' to recursively merge the patch
    object with the target object, while keeping target object keys, but overwriting any array values, or use
    'MergeObjectsAppendArrays' to recursively merge the patch object with the target object, while keeping
    target object keys and appending any array values to target array values, or use
    'ForceMergeObjects' to recursively merge the patch object with the target object, overwriting
    any target object keys, including array values, or use
    'ForceMergeObjectsAppendArrays' to recursively merge the patch object with the target object,
    overwriting target object keys, and appending any array values to target array values.
    'MergeObject' is deprecated, use 'MergeObjects' instead, which is functionally identical.
    'AppendArray' is deprecated, use 'ForceMergeObjectsAppendArrays' instead, which is functionally identical.
    """


class Convert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Convert"]:
            return Convert

        def build(self) -> "Convert":
            return Convert(**self._attrs)

        def format(self, value: Optional[Literal["none", "quantity", "json"]], /) -> Self:
            """
            The expected input format.

            * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
            Only used during `string -> float64` conversions.
            * `json` - parses the input as a JSON string.
            Only used during `string -> object` or `string -> list` conversions.

            If this property is null, the default conversion is applied.
            """
            return self._set("format", value)

        def to_type(
            self,
            value: Literal["string", "int", "int64", "bool", "float64", "object", "array"],
            /,
        ) -> Self:
            """
            ToType is the type of the output of this transform.
            """
            return self._set("to_type", value)

    class BuilderContext(BuilderContextBase["Convert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Convert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Convert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Convert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Convert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    format: Optional[Literal["none", "quantity", "json"]] = None
    """
    The expected input format.

    * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
    Only used during `string -> float64` conversions.
    * `json` - parses the input as a JSON string.
    Only used during `string -> object` or `string -> list` conversions.

    If this property is null, the default conversion is applied.
    """
    to_type: Annotated[
        Literal["string", "int", "int64", "bool", "float64", "object", "array"],
        Field(alias="toType"),
    ]
    """
    ToType is the type of the output of this transform.
    """


class Pattern(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pattern"]:
            return Pattern

        def build(self) -> "Pattern":
            return Pattern(**self._attrs)

        def literal(self, value: Optional[str], /) -> Self:
            """
            Literal exactly matches the input string (case sensitive).
            Is required if `type` is `literal`.
            """
            return self._set("literal", value)

        def regexp(self, value: Optional[str], /) -> Self:
            """
            Regexp to match against the input string.
            Is required if `type` is `regexp`.
            """
            return self._set("regexp", value)

        def result(self, value: Any, /) -> Self:
            """
            The value that is used as result of the transform if the pattern matches.
            """
            return self._set("result", value)

        def type(self, value: Optional[Literal["literal", "regexp"]], /) -> Self:
            """
            Type specifies how the pattern matches the input.

            * `literal` - the pattern value has to exactly match (case sensitive) the
            input string. This is the default.

            * `regexp` - the pattern treated as a regular expression against
            which the input string is tested. Crossplane will throw an error if the
            key is not a valid regexp.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Pattern.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pattern.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pattern."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pattern", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pattern.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    literal: Optional[str] = None
    """
    Literal exactly matches the input string (case sensitive).
    Is required if `type` is `literal`.
    """
    regexp: Optional[str] = None
    """
    Regexp to match against the input string.
    Is required if `type` is `regexp`.
    """
    result: Any
    """
    The value that is used as result of the transform if the pattern matches.
    """
    type: Optional[Literal["literal", "regexp"]] = "literal"
    """
    Type specifies how the pattern matches the input.

    * `literal` - the pattern value has to exactly match (case sensitive) the
    input string. This is the default.

    * `regexp` - the pattern treated as a regular expression against
    which the input string is tested. Crossplane will throw an error if the
    key is not a valid regexp.
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        def fallback_to(self, value: Optional[Literal["Value", "Input"]], /) -> Self:
            """
            Determines to what value the transform should fallback if no pattern matches.
            """
            return self._set("fallback_to", value)

        def fallback_value(self, value: Optional[Any], /) -> Self:
            """
            The fallback value that should be returned by the transform if now pattern
            matches.
            """
            return self._set("fallback_value", value)

        @overload
        def patterns(self, value_or_callback: List[Pattern], /) -> "Match.Builder": ...

        @overload
        def patterns(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pattern, Pattern.Builder]],
                GenericListBuilder[Pattern, Pattern.Builder] | List[Pattern],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def patterns(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Pattern.Builder]: ...

        def patterns(self, value_or_callback=None, /):
            """
            The patterns that should be tested against the input string.
            Patterns are tested in order. The value of the first match is used as
            result of this transform.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pattern.Builder]()
                context._parent_builder = self
                context._field_name = "patterns"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pattern.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patterns", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fallback_to: Annotated[Optional[Literal["Value", "Input"]], Field(alias="fallbackTo")] = "Value"
    """
    Determines to what value the transform should fallback if no pattern matches.
    """
    fallback_value: Annotated[Optional[Any], Field(alias="fallbackValue")] = None
    """
    The fallback value that should be returned by the transform if now pattern
    matches.
    """
    patterns: Optional[List[Pattern]] = None
    """
    The patterns that should be tested against the input string.
    Patterns are tested in order. The value of the first match is used as
    result of this transform.
    """


class Math(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Math"]:
            return Math

        def build(self) -> "Math":
            return Math(**self._attrs)

        def clamp_max(self, value: Optional[int], /) -> Self:
            """
            ClampMax makes sure that the value is not bigger than the given value.
            """
            return self._set("clamp_max", value)

        def clamp_min(self, value: Optional[int], /) -> Self:
            """
            ClampMin makes sure that the value is not smaller than the given value.
            """
            return self._set("clamp_min", value)

        def multiply(self, value: Optional[int], /) -> Self:
            """
            Multiply the value.
            """
            return self._set("multiply", value)

        def type(self, value: Optional[Literal["Multiply", "ClampMin", "ClampMax"]], /) -> Self:
            """
            Type of the math transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Math.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Math.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Math."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Math", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Math.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    clamp_max: Annotated[Optional[int], Field(alias="clampMax")] = None
    """
    ClampMax makes sure that the value is not bigger than the given value.
    """
    clamp_min: Annotated[Optional[int], Field(alias="clampMin")] = None
    """
    ClampMin makes sure that the value is not smaller than the given value.
    """
    multiply: Optional[int] = None
    """
    Multiply the value.
    """
    type: Optional[Literal["Multiply", "ClampMin", "ClampMax"]] = "Multiply"
    """
    Type of the math transform to be run.
    """


class Join(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Join"]:
            return Join

        def build(self) -> "Join":
            return Join(**self._attrs)

        def separator(self, value: str, /) -> Self:
            """
            Separator to join the input strings.
            """
            return self._set("separator", value)

    class BuilderContext(BuilderContextBase["Join.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Join.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Join."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Join", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Join.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    separator: str
    """
    Separator to join the input strings.
    """


class Regexp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Regexp"]:
            return Regexp

        def build(self) -> "Regexp":
            return Regexp(**self._attrs)

        def group(self, value: Optional[int], /) -> Self:
            """
            Group number to match. 0 (the default) matches the entire expression.
            """
            return self._set("group", value)

        def match(self, value: str, /) -> Self:
            """
            Match string. May optionally include submatches, aka capture groups.
            See https://pkg.go.dev/regexp/ for details.
            """
            return self._set("match", value)

    class BuilderContext(BuilderContextBase["Regexp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Regexp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Regexp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Regexp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Regexp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[int] = None
    """
    Group number to match. 0 (the default) matches the entire expression.
    """
    match: str
    """
    Match string. May optionally include submatches, aka capture groups.
    See https://pkg.go.dev/regexp/ for details.
    """


class Replace(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Replace"]:
            return Replace

        def build(self) -> "Replace":
            return Replace(**self._attrs)

        def replace(self, value: str, /) -> Self:
            """
            The Replace string replaces all occurrences of the search string.
            """
            return self._set("replace", value)

        def search(self, value: str, /) -> Self:
            """
            The Search string to match.
            """
            return self._set("search", value)

    class BuilderContext(BuilderContextBase["Replace.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Replace.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Replace."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Replace", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Replace.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    replace: str
    """
    The Replace string replaces all occurrences of the search string.
    """
    search: str
    """
    The Search string to match.
    """


class StringModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel"]:
            return StringModel

        def build(self) -> "StringModel":
            return StringModel(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join the input strings.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        @overload
        def replace(self, value_or_callback: Optional[Replace], /) -> "StringModel.Builder": ...

        @overload
        def replace(
            self,
            value_or_callback: Callable[[Replace.Builder], Replace.Builder | Replace],
            /,
        ) -> "StringModel.Builder": ...

        @overload
        def replace(self, value_or_callback: Never = ...) -> "Replace.BuilderContext": ...

        def replace(self, value_or_callback=None, /):
            """
            Search/Replace applied to the input string.
            """
            if self._in_context and value_or_callback is None:
                context = Replace.BuilderContext()
                context._parent_builder = self
                context._field_name = "replace"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Replace.builder())
                if isinstance(output, Replace.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("replace", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join the input strings.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    replace: Optional[Replace] = None
    """
    Search/Replace applied to the input string.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]] = "Format"
    """
    Type of the string transform to be run.
    """


class Transform(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Transform"]:
            return Transform

        def build(self) -> "Transform":
            return Transform(**self._attrs)

        @overload
        def convert(self, value_or_callback: Optional[Convert], /) -> "Transform.Builder": ...

        @overload
        def convert(
            self,
            value_or_callback: Callable[[Convert.Builder], Convert.Builder | Convert],
            /,
        ) -> "Transform.Builder": ...

        @overload
        def convert(self, value_or_callback: Never = ...) -> "Convert.BuilderContext": ...

        def convert(self, value_or_callback=None, /):
            """
            Convert is used to cast the input into the given output type.
            """
            if self._in_context and value_or_callback is None:
                context = Convert.BuilderContext()
                context._parent_builder = self
                context._field_name = "convert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Convert.builder())
                if isinstance(output, Convert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("convert", value)

        def map(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Map uses the input as a key in the given map and returns the value.
            """
            return self._set("map", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "Transform.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "Transform.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Match is a more complex version of Map that matches a list of patterns.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def math(self, value_or_callback: Optional[Math], /) -> "Transform.Builder": ...

        @overload
        def math(
            self, value_or_callback: Callable[[Math.Builder], Math.Builder | Math], /
        ) -> "Transform.Builder": ...

        @overload
        def math(self, value_or_callback: Never = ...) -> "Math.BuilderContext": ...

        def math(self, value_or_callback=None, /):
            """
            Math is used to transform the input via mathematical operations such as
            multiplication.
            """
            if self._in_context and value_or_callback is None:
                context = Math.BuilderContext()
                context._parent_builder = self
                context._field_name = "math"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Math.builder())
                if isinstance(output, Math.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("math", value)

        @overload
        def string(self, value_or_callback: Optional[StringModel], /) -> "Transform.Builder": ...

        @overload
        def string(
            self,
            value_or_callback: Callable[[StringModel.Builder], StringModel.Builder | StringModel],
            /,
        ) -> "Transform.Builder": ...

        @overload
        def string(self, value_or_callback: Never = ...) -> "StringModel.BuilderContext": ...

        def string(self, value_or_callback=None, /):
            """
            String is used to transform the input into a string or a different kind
            of string. Note that the input does not necessarily need to be a string.
            """
            if self._in_context and value_or_callback is None:
                context = StringModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "string"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StringModel.builder())
                if isinstance(output, StringModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("string", value)

        def type(self, value: Literal["map", "match", "math", "string", "convert"], /) -> Self:
            """
            Type of the transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Transform.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Transform.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Transform."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Transform", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Transform.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[Convert] = None
    """
    Convert is used to cast the input into the given output type.
    """
    map: Optional[Dict[str, Any]] = None
    """
    Map uses the input as a key in the given map and returns the value.
    """
    match: Optional[Match] = None
    """
    Match is a more complex version of Map that matches a list of patterns.
    """
    math: Optional[Math] = None
    """
    Math is used to transform the input via mathematical operations such as
    multiplication.
    """
    string: Optional[StringModel] = None
    """
    String is used to transform the input into a string or a different kind
    of string. Note that the input does not necessarily need to be a string.
    """
    type: Literal["map", "match", "math", "string", "convert"]
    """
    Type of the transform to be run.
    """


class Patch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Patch"]:
            return Patch

        def build(self) -> "Patch":
            return Patch(**self._attrs)

        @overload
        def combine(self, value_or_callback: Optional[Combine], /) -> "Patch.Builder": ...

        @overload
        def combine(
            self,
            value_or_callback: Callable[[Combine.Builder], Combine.Builder | Combine],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def combine(self, value_or_callback: Never = ...) -> "Combine.BuilderContext": ...

        def combine(self, value_or_callback=None, /):
            """
            Combine is the patch configuration for a CombineFromComposite,
            CombineToComposite patch.
            """
            if self._in_context and value_or_callback is None:
                context = Combine.BuilderContext()
                context._parent_builder = self
                context._field_name = "combine"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Combine.builder())
                if isinstance(output, Combine.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("combine", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the resource whose value is
            to be used as input. Required when type is FromCompositeFieldPath or
            ToCompositeFieldPath.
            """
            return self._set("from_field_path", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "Patch.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy configures the specifics of patching behaviour.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

        def to_field_path(self, value: Optional[str], /) -> Self:
            """
            ToFieldPath is the path of the field on the resource whose value will
            be changed with the result of transforms. Leave empty if you'd like to
            propagate to the same path as fromFieldPath.
            """
            return self._set("to_field_path", value)

        @overload
        def transforms(self, value_or_callback: List[Transform], /) -> "Patch.Builder": ...

        @overload
        def transforms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Transform, Transform.Builder]],
                GenericListBuilder[Transform, Transform.Builder] | List[Transform],
            ],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def transforms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Transform.Builder]: ...

        def transforms(self, value_or_callback=None, /):
            """
            Transforms are the list of functions that are used as a FIFO pipe for the
            input to be transformed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Transform.Builder]()
                context._parent_builder = self
                context._field_name = "transforms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Transform.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("transforms", value)

        def type(
            self,
            value: Optional[
                Literal[
                    "FromCompositeFieldPath",
                    "ToCompositeFieldPath",
                    "CombineFromComposite",
                    "CombineToComposite",
                    "FromEnvironmentFieldPath",
                    "ToEnvironmentFieldPath",
                ]
            ],
            /,
        ) -> Self:
            """
            Type sets the patching behaviour to be used. Each patch type may require
            its own fields to be set on the Patch object.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Patch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Patch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Patch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Patch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Patch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    combine: Optional[Combine] = None
    """
    Combine is the patch configuration for a CombineFromComposite,
    CombineToComposite patch.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the resource whose value is
    to be used as input. Required when type is FromCompositeFieldPath or
    ToCompositeFieldPath.
    """
    policy: Optional[Policy] = None
    """
    Policy configures the specifics of patching behaviour.
    """
    to_field_path: Annotated[Optional[str], Field(alias="toFieldPath")] = None
    """
    ToFieldPath is the path of the field on the resource whose value will
    be changed with the result of transforms. Leave empty if you'd like to
    propagate to the same path as fromFieldPath.
    """
    transforms: Optional[List[Transform]] = None
    """
    Transforms are the list of functions that are used as a FIFO pipe for the
    input to be transformed.
    """
    type: Optional[
        Literal[
            "FromCompositeFieldPath",
            "ToCompositeFieldPath",
            "CombineFromComposite",
            "CombineToComposite",
            "FromEnvironmentFieldPath",
            "ToEnvironmentFieldPath",
        ]
    ] = "FromCompositeFieldPath"
    """
    Type sets the patching behaviour to be used. Each patch type may require
    its own fields to be set on the Patch object.
    """


class Environment(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Environment"]:
            return Environment

        def build(self) -> "Environment":
            return Environment(**self._attrs)

        @overload
        def patches(self, value_or_callback: List[Patch], /) -> "Environment.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Patch, Patch.Builder]],
                GenericListBuilder[Patch, Patch.Builder] | List[Patch],
            ],
            /,
        ) -> "Environment.Builder": ...

        @overload
        def patches(self, value_or_callback: Never = ...) -> ListBuilderContext[Patch.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches is a list of environment patches that are executed before a
            composition's resources are composed. These patches are between the XR
            and the Environment. Either from the Environment to the XR, or vice
            versa.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Patch.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Patch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

    class BuilderContext(BuilderContextBase["Environment.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Environment.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Environment."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Environment", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Environment.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    patches: Optional[List[Patch]] = None
    """
    Patches is a list of environment patches that are executed before a
    composition's resources are composed. These patches are between the XR
    and the Environment. Either from the Environment to the XR, or vice
    versa.
    """


class StringModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel1"]:
            return StringModel1

        def build(self) -> "StringModel1":
            return StringModel1(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["StringModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class StringModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel2"]:
            return StringModel2

        def build(self) -> "StringModel2":
            return StringModel2(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel2.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel2.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join the input strings.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel2.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel2.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        @overload
        def replace(self, value_or_callback: Optional[Replace], /) -> "StringModel2.Builder": ...

        @overload
        def replace(
            self,
            value_or_callback: Callable[[Replace.Builder], Replace.Builder | Replace],
            /,
        ) -> "StringModel2.Builder": ...

        @overload
        def replace(self, value_or_callback: Never = ...) -> "Replace.BuilderContext": ...

        def replace(self, value_or_callback=None, /):
            """
            Search/Replace applied to the input string.
            """
            if self._in_context and value_or_callback is None:
                context = Replace.BuilderContext()
                context._parent_builder = self
                context._field_name = "replace"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Replace.builder())
                if isinstance(output, Replace.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("replace", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join the input strings.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    replace: Optional[Replace] = None
    """
    Search/Replace applied to the input string.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]] = "Format"
    """
    Type of the string transform to be run.
    """


class PatchModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PatchModel"]:
            return PatchModel

        def build(self) -> "PatchModel":
            return PatchModel(**self._attrs)

        @overload
        def combine(self, value_or_callback: Optional[Combine], /) -> "PatchModel.Builder": ...

        @overload
        def combine(
            self,
            value_or_callback: Callable[[Combine.Builder], Combine.Builder | Combine],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def combine(self, value_or_callback: Never = ...) -> "Combine.BuilderContext": ...

        def combine(self, value_or_callback=None, /):
            """
            Combine is the patch configuration for a CombineFromComposite,
            CombineToComposite patch.
            """
            if self._in_context and value_or_callback is None:
                context = Combine.BuilderContext()
                context._parent_builder = self
                context._field_name = "combine"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Combine.builder())
                if isinstance(output, Combine.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("combine", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the resource whose value is
            to be used as input. Required when type is FromCompositeFieldPath or
            ToCompositeFieldPath.
            """
            return self._set("from_field_path", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "PatchModel.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy configures the specifics of patching behaviour.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

        def to_field_path(self, value: Optional[str], /) -> Self:
            """
            ToFieldPath is the path of the field on the resource whose value will
            be changed with the result of transforms. Leave empty if you'd like to
            propagate to the same path as fromFieldPath.
            """
            return self._set("to_field_path", value)

        @overload
        def transforms(self, value_or_callback: List[Transform], /) -> "PatchModel.Builder": ...

        @overload
        def transforms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Transform, Transform.Builder]],
                GenericListBuilder[Transform, Transform.Builder] | List[Transform],
            ],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def transforms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Transform.Builder]: ...

        def transforms(self, value_or_callback=None, /):
            """
            Transforms are the list of functions that are used as a FIFO pipe for the
            input to be transformed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Transform.Builder]()
                context._parent_builder = self
                context._field_name = "transforms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Transform.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("transforms", value)

        def type(
            self,
            value: Optional[
                Literal[
                    "FromCompositeFieldPath",
                    "ToCompositeFieldPath",
                    "CombineFromComposite",
                    "CombineToComposite",
                    "FromEnvironmentFieldPath",
                    "ToEnvironmentFieldPath",
                    "CombineFromEnvironment",
                    "CombineToEnvironment",
                ]
            ],
            /,
        ) -> Self:
            """
            Type sets the patching behaviour to be used. Each patch type may require
            its own fields to be set on the ComposedPatch object.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["PatchModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PatchModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PatchModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    combine: Optional[Combine] = None
    """
    Combine is the patch configuration for a CombineFromComposite,
    CombineToComposite patch.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the resource whose value is
    to be used as input. Required when type is FromCompositeFieldPath or
    ToCompositeFieldPath.
    """
    policy: Optional[Policy] = None
    """
    Policy configures the specifics of patching behaviour.
    """
    to_field_path: Annotated[Optional[str], Field(alias="toFieldPath")] = None
    """
    ToFieldPath is the path of the field on the resource whose value will
    be changed with the result of transforms. Leave empty if you'd like to
    propagate to the same path as fromFieldPath.
    """
    transforms: Optional[List[Transform]] = None
    """
    Transforms are the list of functions that are used as a FIFO pipe for the
    input to be transformed.
    """
    type: Optional[
        Literal[
            "FromCompositeFieldPath",
            "ToCompositeFieldPath",
            "CombineFromComposite",
            "CombineToComposite",
            "FromEnvironmentFieldPath",
            "ToEnvironmentFieldPath",
            "CombineFromEnvironment",
            "CombineToEnvironment",
        ]
    ] = "FromCompositeFieldPath"
    """
    Type sets the patching behaviour to be used. Each patch type may require
    its own fields to be set on the ComposedPatch object.
    """


class PatchSet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PatchSet"]:
            return PatchSet

        def build(self) -> "PatchSet":
            return PatchSet(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of this PatchSet.
            """
            return self._set("name", value)

        @overload
        def patches(self, value_or_callback: List[PatchModel], /) -> "PatchSet.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchModel, PatchModel.Builder]],
                GenericListBuilder[PatchModel, PatchModel.Builder] | List[PatchModel],
            ],
            /,
        ) -> "PatchSet.Builder": ...

        @overload
        def patches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchModel.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches will be applied as an overlay to the base resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchModel.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

    class BuilderContext(BuilderContextBase["PatchSet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PatchSet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PatchSet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PatchSet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchSet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of this PatchSet.
    """
    patches: List[PatchModel]
    """
    Patches will be applied as an overlay to the base resource.
    """


class ConnectionDetail(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionDetail"]:
            return ConnectionDetail

        def build(self) -> "ConnectionDetail":
            return ConnectionDetail(**self._attrs)

        def from_connection_secret_key(self, value: Optional[str], /) -> Self:
            """
            FromConnectionSecretKey is the key that will be used to fetch the value
            from the composed resource's connection secret.
            """
            return self._set("from_connection_secret_key", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the composed resource whose
            value to be used as input. Name must be specified if the type is
            FromFieldPath.
            """
            return self._set("from_field_path", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the connection secret key that will be propagated to the
            connection secret of the composed resource.
            """
            return self._set("name", value)

        def type(
            self,
            value: Literal["FromConnectionSecretKey", "FromFieldPath", "FromValue"],
            /,
        ) -> Self:
            """
            Type sets the connection detail fetching behavior to be used. Each
            connection detail type may require its own fields to be set on the
            ConnectionDetail object.
            """
            return self._set("type", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value that will be propagated to the connection secret of the composite
            resource. May be set to inject a fixed, non-sensitive connection secret
            value, for example a well-known port.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["ConnectionDetail.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionDetail.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionDetail."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionDetail", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionDetail.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_connection_secret_key: Annotated[Optional[str], Field(alias="fromConnectionSecretKey")] = (
        None
    )
    """
    FromConnectionSecretKey is the key that will be used to fetch the value
    from the composed resource's connection secret.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the composed resource whose
    value to be used as input. Name must be specified if the type is
    FromFieldPath.
    """
    name: str
    """
    Name of the connection secret key that will be propagated to the
    connection secret of the composed resource.
    """
    type: Literal["FromConnectionSecretKey", "FromFieldPath", "FromValue"]
    """
    Type sets the connection detail fetching behavior to be used. Each
    connection detail type may require its own fields to be set on the
    ConnectionDetail object.
    """
    value: Optional[str] = None
    """
    Value that will be propagated to the connection secret of the composite
    resource. May be set to inject a fixed, non-sensitive connection secret
    value, for example a well-known port.
    """


class StringModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel3"]:
            return StringModel3

        def build(self) -> "StringModel3":
            return StringModel3(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["StringModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class StringModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel4"]:
            return StringModel4

        def build(self) -> "StringModel4":
            return StringModel4(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel4.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel4.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join the input strings.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel4.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel4.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        @overload
        def replace(self, value_or_callback: Optional[Replace], /) -> "StringModel4.Builder": ...

        @overload
        def replace(
            self,
            value_or_callback: Callable[[Replace.Builder], Replace.Builder | Replace],
            /,
        ) -> "StringModel4.Builder": ...

        @overload
        def replace(self, value_or_callback: Never = ...) -> "Replace.BuilderContext": ...

        def replace(self, value_or_callback=None, /):
            """
            Search/Replace applied to the input string.
            """
            if self._in_context and value_or_callback is None:
                context = Replace.BuilderContext()
                context._parent_builder = self
                context._field_name = "replace"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Replace.builder())
                if isinstance(output, Replace.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("replace", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join the input strings.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    replace: Optional[Replace] = None
    """
    Search/Replace applied to the input string.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp"]] = "Format"
    """
    Type of the string transform to be run.
    """


class PatchModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PatchModel1"]:
            return PatchModel1

        def build(self) -> "PatchModel1":
            return PatchModel1(**self._attrs)

        @overload
        def combine(self, value_or_callback: Optional[Combine], /) -> "PatchModel1.Builder": ...

        @overload
        def combine(
            self,
            value_or_callback: Callable[[Combine.Builder], Combine.Builder | Combine],
            /,
        ) -> "PatchModel1.Builder": ...

        @overload
        def combine(self, value_or_callback: Never = ...) -> "Combine.BuilderContext": ...

        def combine(self, value_or_callback=None, /):
            """
            Combine is the patch configuration for a CombineFromComposite,
            CombineToComposite patch.
            """
            if self._in_context and value_or_callback is None:
                context = Combine.BuilderContext()
                context._parent_builder = self
                context._field_name = "combine"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Combine.builder())
                if isinstance(output, Combine.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("combine", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the resource whose value is
            to be used as input. Required when type is FromCompositeFieldPath or
            ToCompositeFieldPath.
            """
            return self._set("from_field_path", value)

        def patch_set_name(self, value: Optional[str], /) -> Self:
            """
            PatchSetName to include patches from. Required when type is PatchSet.
            """
            return self._set("patch_set_name", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "PatchModel1.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "PatchModel1.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy configures the specifics of patching behaviour.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

        def to_field_path(self, value: Optional[str], /) -> Self:
            """
            ToFieldPath is the path of the field on the resource whose value will
            be changed with the result of transforms. Leave empty if you'd like to
            propagate to the same path as fromFieldPath.
            """
            return self._set("to_field_path", value)

        @overload
        def transforms(self, value_or_callback: List[Transform], /) -> "PatchModel1.Builder": ...

        @overload
        def transforms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Transform, Transform.Builder]],
                GenericListBuilder[Transform, Transform.Builder] | List[Transform],
            ],
            /,
        ) -> "PatchModel1.Builder": ...

        @overload
        def transforms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Transform.Builder]: ...

        def transforms(self, value_or_callback=None, /):
            """
            Transforms are the list of functions that are used as a FIFO pipe for the
            input to be transformed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Transform.Builder]()
                context._parent_builder = self
                context._field_name = "transforms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Transform.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("transforms", value)

        def type(
            self,
            value: Optional[
                Literal[
                    "FromCompositeFieldPath",
                    "PatchSet",
                    "ToCompositeFieldPath",
                    "CombineFromComposite",
                    "CombineToComposite",
                    "FromEnvironmentFieldPath",
                    "ToEnvironmentFieldPath",
                    "CombineFromEnvironment",
                    "CombineToEnvironment",
                ]
            ],
            /,
        ) -> Self:
            """
            Type sets the patching behaviour to be used. Each patch type may require
            its own fields to be set on the ComposedPatch object.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["PatchModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PatchModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PatchModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PatchModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    combine: Optional[Combine] = None
    """
    Combine is the patch configuration for a CombineFromComposite,
    CombineToComposite patch.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the resource whose value is
    to be used as input. Required when type is FromCompositeFieldPath or
    ToCompositeFieldPath.
    """
    patch_set_name: Annotated[Optional[str], Field(alias="patchSetName")] = None
    """
    PatchSetName to include patches from. Required when type is PatchSet.
    """
    policy: Optional[Policy] = None
    """
    Policy configures the specifics of patching behaviour.
    """
    to_field_path: Annotated[Optional[str], Field(alias="toFieldPath")] = None
    """
    ToFieldPath is the path of the field on the resource whose value will
    be changed with the result of transforms. Leave empty if you'd like to
    propagate to the same path as fromFieldPath.
    """
    transforms: Optional[List[Transform]] = None
    """
    Transforms are the list of functions that are used as a FIFO pipe for the
    input to be transformed.
    """
    type: Optional[
        Literal[
            "FromCompositeFieldPath",
            "PatchSet",
            "ToCompositeFieldPath",
            "CombineFromComposite",
            "CombineToComposite",
            "FromEnvironmentFieldPath",
            "ToEnvironmentFieldPath",
            "CombineFromEnvironment",
            "CombineToEnvironment",
        ]
    ] = "FromCompositeFieldPath"
    """
    Type sets the patching behaviour to be used. Each patch type may require
    its own fields to be set on the ComposedPatch object.
    """


class MatchCondition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchCondition"]:
            return MatchCondition

        def build(self) -> "MatchCondition":
            return MatchCondition(**self._attrs)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition you'd like to match.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type indicates the type of condition you'd like to use.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["MatchCondition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchCondition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchCondition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchCondition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchCondition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    status: Optional[str] = "True"
    """
    Status is the status of the condition you'd like to match.
    """
    type: Optional[str] = "Ready"
    """
    Type indicates the type of condition you'd like to use.
    """


class ReadinessCheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadinessCheck"]:
            return ReadinessCheck

        def build(self) -> "ReadinessCheck":
            return ReadinessCheck(**self._attrs)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            FieldPath shows the path of the field whose value will be used.
            """
            return self._set("field_path", value)

        @overload
        def match_condition(
            self, value_or_callback: Optional[MatchCondition], /
        ) -> "ReadinessCheck.Builder": ...

        @overload
        def match_condition(
            self,
            value_or_callback: Callable[
                [MatchCondition.Builder], MatchCondition.Builder | MatchCondition
            ],
            /,
        ) -> "ReadinessCheck.Builder": ...

        @overload
        def match_condition(
            self, value_or_callback: Never = ...
        ) -> "MatchCondition.BuilderContext": ...

        def match_condition(self, value_or_callback=None, /):
            """
            MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
            """
            if self._in_context and value_or_callback is None:
                context = MatchCondition.BuilderContext()
                context._parent_builder = self
                context._field_name = "match_condition"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchCondition.builder())
                if isinstance(output, MatchCondition.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_condition", value)

        def match_integer(self, value: Optional[int], /) -> Self:
            """
            MatchInt is the value you'd like to match if you're using "MatchInt" type.
            """
            return self._set("match_integer", value)

        def match_string(self, value: Optional[str], /) -> Self:
            """
            MatchString is the value you'd like to match if you're using "MatchString" type.
            """
            return self._set("match_string", value)

        def type(
            self,
            value: Literal[
                "MatchString",
                "MatchInteger",
                "NonEmpty",
                "MatchCondition",
                "MatchTrue",
                "MatchFalse",
                "None",
            ],
            /,
        ) -> Self:
            """
            Type indicates the type of probe you'd like to use.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ReadinessCheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadinessCheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadinessCheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadinessCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadinessCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    FieldPath shows the path of the field whose value will be used.
    """
    match_condition: Annotated[Optional[MatchCondition], Field(alias="matchCondition")] = None
    """
    MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
    """
    match_integer: Annotated[Optional[int], Field(alias="matchInteger")] = None
    """
    MatchInt is the value you'd like to match if you're using "MatchInt" type.
    """
    match_string: Annotated[Optional[str], Field(alias="matchString")] = None
    """
    MatchString is the value you'd like to match if you're using "MatchString" type.
    """
    type: Literal[
        "MatchString",
        "MatchInteger",
        "NonEmpty",
        "MatchCondition",
        "MatchTrue",
        "MatchFalse",
        "None",
    ]
    """
    Type indicates the type of probe you'd like to use.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def base(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Base of the composed resource that patches will be applied to and from.
            If base is omitted, a previous Function within the pipeline must have
            produced the named composed resource. Patches will be applied to and from
            that resource. If base is specified, and a previous Function within the
            pipeline produced the name composed resource, it will be overwritten.
            """
            return self._set("base", value)

        @overload
        def connection_details(
            self, value_or_callback: List[ConnectionDetail], /
        ) -> "ResourceModel.Builder": ...

        @overload
        def connection_details(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConnectionDetail, ConnectionDetail.Builder]],
                GenericListBuilder[ConnectionDetail, ConnectionDetail.Builder]
                | List[ConnectionDetail],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def connection_details(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConnectionDetail.Builder]: ...

        def connection_details(self, value_or_callback=None, /):
            """
            ConnectionDetails lists the propagation secret keys from this composed
            resource to the composition instance connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConnectionDetail.Builder]()
                context._parent_builder = self
                context._field_name = "connection_details"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionDetail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("connection_details", value)

        def name(self, value: str, /) -> Self:
            """
            A Name uniquely identifies this entry within its resources array.
            """
            return self._set("name", value)

        @overload
        def patches(self, value_or_callback: List[PatchModel1], /) -> "ResourceModel.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchModel1, PatchModel1.Builder]],
                GenericListBuilder[PatchModel1, PatchModel1.Builder] | List[PatchModel1],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def patches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchModel1.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches to and from the composed resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchModel1.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

        @overload
        def readiness_checks(
            self, value_or_callback: List[ReadinessCheck], /
        ) -> "ResourceModel.Builder": ...

        @overload
        def readiness_checks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ReadinessCheck, ReadinessCheck.Builder]],
                GenericListBuilder[ReadinessCheck, ReadinessCheck.Builder] | List[ReadinessCheck],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def readiness_checks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ReadinessCheck.Builder]: ...

        def readiness_checks(self, value_or_callback=None, /):
            """
            ReadinessChecks allows users to define custom readiness checks. All
            checks have to return true in order for resource to be considered ready.
            The default readiness check is to have the "Ready" condition to be
            "True".
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ReadinessCheck.Builder]()
                context._parent_builder = self
                context._field_name = "readiness_checks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessCheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_checks", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    base: Optional[Dict[str, Any]] = None
    """
    Base of the composed resource that patches will be applied to and from.
    If base is omitted, a previous Function within the pipeline must have
    produced the named composed resource. Patches will be applied to and from
    that resource. If base is specified, and a previous Function within the
    pipeline produced the name composed resource, it will be overwritten.
    """
    connection_details: Annotated[
        Optional[List[ConnectionDetail]], Field(alias="connectionDetails")
    ] = None
    """
    ConnectionDetails lists the propagation secret keys from this composed
    resource to the composition instance connection secret.
    """
    name: str
    """
    A Name uniquely identifies this entry within its resources array.
    """
    patches: Optional[List[PatchModel1]] = None
    """
    Patches to and from the composed resource.
    """
    readiness_checks: Annotated[Optional[List[ReadinessCheck]], Field(alias="readinessChecks")] = [
        {
            "matchCondition": {"status": "True", "type": "Ready"},
            "type": "MatchCondition",
        }
    ]
    """
    ReadinessChecks allows users to define custom readiness checks. All
    checks have to return true in order for resource to be considered ready.
    The default readiness check is to have the "Ready" condition to be
    "True".
    """


class Resources(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Resources"]:
            return Resources

        def build(self) -> "Resources":
            return Resources(**self._attrs)

        def api_version(self, value: Optional[Literal["pt.fn.crossplane.io/v1beta1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        @overload
        def environment(
            self, value_or_callback: Optional[Environment], /
        ) -> "Resources.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment represents the Composition environment.

            THIS IS AN ALPHA FIELD.
            Do not use it in production. It may be changed or removed without notice.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        def kind(self, value: Optional[Literal["Resources"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "Resources.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def patch_sets(self, value_or_callback: List[PatchSet], /) -> "Resources.Builder": ...

        @overload
        def patch_sets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchSet, PatchSet.Builder]],
                GenericListBuilder[PatchSet, PatchSet.Builder] | List[PatchSet],
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def patch_sets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchSet.Builder]: ...

        def patch_sets(self, value_or_callback=None, /):
            """
            PatchSets define a named set of patches that may be included by any
            resource. PatchSets cannot themselves refer to other PatchSets.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchSet.Builder]()
                context._parent_builder = self
                context._field_name = "patch_sets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchSet.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patch_sets", value)

        @overload
        def resources(self, value_or_callback: List[ResourceModel], /) -> "Resources.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "Resources.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resources is a list of resource templates that will be used when a
            composite resource is created.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

    class BuilderContext(BuilderContextBase["Resources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Resources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Resources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Resources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Resources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["pt.fn.crossplane.io/v1beta1"]], Field(alias="apiVersion")
    ] = "pt.fn.crossplane.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    environment: Optional[Environment] = None
    """
    Environment represents the Composition environment.

    THIS IS AN ALPHA FIELD.
    Do not use it in production. It may be changed or removed without notice.
    """
    kind: Optional[Literal["Resources"]] = "Resources"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    patch_sets: Annotated[Optional[List[PatchSet]], Field(alias="patchSets")] = None
    """
    PatchSets define a named set of patches that may be included by any
    resource. PatchSets cannot themselves refer to other PatchSets.
    """
    resources: List[ResourceModel]
    """
    Resources is a list of resource templates that will be used when a
    composite resource is created.
    """
