# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ...k8s.apimachinery.pkg.apis.meta import v1


class ClaimNames(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClaimNames"]:
            return ClaimNames

        def build(self) -> "ClaimNames":
            return ClaimNames(**self._attrs)

        def categories(self, value: Optional[List[str]], /) -> Self:
            """
            categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
            This is published in API discovery documents, and used by clients to support invocations like
            `kubectl get all`.
            """
            return self._set("categories", value)

        def kind(self, value: str, /) -> Self:
            """
            kind is the serialized kind of the resource. It is normally CamelCase and singular.
            Custom resource instances will use this value as the `kind` attribute in API calls.
            """
            return self._set("kind", value)

        def list_kind(self, value: Optional[str], /) -> Self:
            """
            listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
            """
            return self._set("list_kind", value)

        def plural(self, value: str, /) -> Self:
            """
            plural is the plural name of the resource to serve.
            The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
            Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
            Must be all lowercase.
            """
            return self._set("plural", value)

        def short_names(self, value: Optional[List[str]], /) -> Self:
            """
            shortNames are short names for the resource, exposed in API discovery documents,
            and used by clients to support invocations like `kubectl get <shortname>`.
            It must be all lowercase.
            """
            return self._set("short_names", value)

        def singular(self, value: Optional[str], /) -> Self:
            """
            singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
            """
            return self._set("singular", value)

    class BuilderContext(BuilderContextBase["ClaimNames.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClaimNames.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClaimNames."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClaimNames", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClaimNames.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    categories: Optional[List[str]] = None
    """
    categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
    This is published in API discovery documents, and used by clients to support invocations like
    `kubectl get all`.
    """
    kind: str
    """
    kind is the serialized kind of the resource. It is normally CamelCase and singular.
    Custom resource instances will use this value as the `kind` attribute in API calls.
    """
    list_kind: Annotated[Optional[str], Field(alias="listKind")] = None
    """
    listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
    """
    plural: str
    """
    plural is the plural name of the resource to serve.
    The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
    Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
    Must be all lowercase.
    """
    short_names: Annotated[Optional[List[str]], Field(alias="shortNames")] = None
    """
    shortNames are short names for the resource, exposed in API discovery documents,
    and used by clients to support invocations like `kubectl get <shortname>`.
    It must be all lowercase.
    """
    singular: Optional[str] = None
    """
    singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            name is the name of the service.
            Required
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            namespace is the namespace of the service.
            Required
            """
            return self._set("namespace", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            path is an optional URL path at which the webhook will be contacted.
            """
            return self._set("path", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            port is an optional service port at which the webhook will be contacted.
            `port` should be a valid port number (1-65535, inclusive).
            Defaults to 443 for backward compatibility.
            """
            return self._set("port", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    name is the name of the service.
    Required
    """
    namespace: str
    """
    namespace is the namespace of the service.
    Required
    """
    path: Optional[str] = None
    """
    path is an optional URL path at which the webhook will be contacted.
    """
    port: Optional[int] = None
    """
    port is an optional service port at which the webhook will be contacted.
    `port` should be a valid port number (1-65535, inclusive).
    Defaults to 443 for backward compatibility.
    """


class ClientConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientConfig"]:
            return ClientConfig

        def build(self) -> "ClientConfig":
            return ClientConfig(**self._attrs)

        def ca_bundle(self, value: Optional[str], /) -> Self:
            """
            caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
            If unspecified, system trust roots on the apiserver are used.
            """
            return self._set("ca_bundle", value)

        @overload
        def service(self, value_or_callback: Optional[Service], /) -> "ClientConfig.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[[Service.Builder], Service.Builder | Service],
            /,
        ) -> "ClientConfig.Builder": ...

        @overload
        def service(self, value_or_callback: Never = ...) -> "Service.BuilderContext": ...

        def service(self, value_or_callback=None, /):
            """
            service is a reference to the service for this webhook. Either
            service or url must be specified.

            If the webhook is running within the cluster, then you should use `service`.
            """
            if self._in_context and value_or_callback is None:
                context = Service.BuilderContext()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.builder())
                if isinstance(output, Service.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            url gives the location of the webhook, in standard URL form
            (`scheme://host:port/path`). Exactly one of `url` or `service`
            must be specified.

            The `host` should not refer to a service running in the cluster; use
            the `service` field instead. The host might be resolved via external
            DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
            in-cluster DNS as that would be a layering violation). `host` may
            also be an IP address.

            Please note that using `localhost` or `127.0.0.1` as a `host` is
            risky unless you take great care to run this webhook on all hosts
            which run an apiserver which might need to make calls to this
            webhook. Such installs are likely to be non-portable, i.e., not easy
            to turn up in a new cluster.

            The scheme must be "https"; the URL must begin with "https://".

            A path is optional, and if present may be any string permissible in
            a URL. You may use the path to pass an arbitrary string to the
            webhook, for example, a cluster identifier.

            Attempting to use a user or basic auth e.g. "user:password@" is not
            allowed. Fragments ("#...") and query parameters ("?...") are not
            allowed, either.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["ClientConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_bundle: Annotated[Optional[str], Field(alias="caBundle")] = None
    """
    caBundle is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
    If unspecified, system trust roots on the apiserver are used.
    """
    service: Optional[Service] = None
    """
    service is a reference to the service for this webhook. Either
    service or url must be specified.

    If the webhook is running within the cluster, then you should use `service`.
    """
    url: Optional[str] = None
    """
    url gives the location of the webhook, in standard URL form
    (`scheme://host:port/path`). Exactly one of `url` or `service`
    must be specified.

    The `host` should not refer to a service running in the cluster; use
    the `service` field instead. The host might be resolved via external
    DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
    in-cluster DNS as that would be a layering violation). `host` may
    also be an IP address.

    Please note that using `localhost` or `127.0.0.1` as a `host` is
    risky unless you take great care to run this webhook on all hosts
    which run an apiserver which might need to make calls to this
    webhook. Such installs are likely to be non-portable, i.e., not easy
    to turn up in a new cluster.

    The scheme must be "https"; the URL must begin with "https://".

    A path is optional, and if present may be any string permissible in
    a URL. You may use the path to pass an arbitrary string to the
    webhook, for example, a cluster identifier.

    Attempting to use a user or basic auth e.g. "user:password@" is not
    allowed. Fragments ("#...") and query parameters ("?...") are not
    allowed, either.
    """


class Webhook(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Webhook"]:
            return Webhook

        def build(self) -> "Webhook":
            return Webhook(**self._attrs)

        @overload
        def client_config(
            self, value_or_callback: Optional[ClientConfig], /
        ) -> "Webhook.Builder": ...

        @overload
        def client_config(
            self,
            value_or_callback: Callable[
                [ClientConfig.Builder], ClientConfig.Builder | ClientConfig
            ],
            /,
        ) -> "Webhook.Builder": ...

        @overload
        def client_config(
            self, value_or_callback: Never = ...
        ) -> "ClientConfig.BuilderContext": ...

        def client_config(self, value_or_callback=None, /):
            """
            clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
            """
            if self._in_context and value_or_callback is None:
                context = ClientConfig.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientConfig.builder())
                if isinstance(output, ClientConfig.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_config", value)

        def conversion_review_versions(self, value: List[str], /) -> Self:
            """
            conversionReviewVersions is an ordered list of preferred `ConversionReview`
            versions the Webhook expects. The API server will use the first version in
            the list which it supports. If none of the versions specified in this list
            are supported by API server, conversion will fail for the custom resource.
            If a persisted Webhook configuration specifies allowed versions and does not
            include any versions known to the API Server, calls to the webhook will fail.
            """
            return self._set("conversion_review_versions", value)

    class BuilderContext(BuilderContextBase["Webhook.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Webhook.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Webhook."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Webhook", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Webhook.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_config: Annotated[Optional[ClientConfig], Field(alias="clientConfig")] = None
    """
    clientConfig is the instructions for how to call the webhook if strategy is `Webhook`.
    """
    conversion_review_versions: Annotated[List[str], Field(alias="conversionReviewVersions")]
    """
    conversionReviewVersions is an ordered list of preferred `ConversionReview`
    versions the Webhook expects. The API server will use the first version in
    the list which it supports. If none of the versions specified in this list
    are supported by API server, conversion will fail for the custom resource.
    If a persisted Webhook configuration specifies allowed versions and does not
    include any versions known to the API Server, calls to the webhook will fail.
    """


class Conversion(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Conversion"]:
            return Conversion

        def build(self) -> "Conversion":
            return Conversion(**self._attrs)

        def strategy(self, value: str, /) -> Self:
            """
            strategy specifies how custom resources are converted between versions. Allowed values are:
            - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource.
            - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
              is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
            """
            return self._set("strategy", value)

        @overload
        def webhook(self, value_or_callback: Optional[Webhook], /) -> "Conversion.Builder": ...

        @overload
        def webhook(
            self,
            value_or_callback: Callable[[Webhook.Builder], Webhook.Builder | Webhook],
            /,
        ) -> "Conversion.Builder": ...

        @overload
        def webhook(self, value_or_callback: Never = ...) -> "Webhook.BuilderContext": ...

        def webhook(self, value_or_callback=None, /):
            """
            webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
            """
            if self._in_context and value_or_callback is None:
                context = Webhook.BuilderContext()
                context._parent_builder = self
                context._field_name = "webhook"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Webhook.builder())
                if isinstance(output, Webhook.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("webhook", value)

    class BuilderContext(BuilderContextBase["Conversion.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Conversion.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Conversion."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Conversion", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Conversion.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    strategy: str
    """
    strategy specifies how custom resources are converted between versions. Allowed values are:
    - `"None"`: The converter only change the apiVersion and would not touch any other field in the custom resource.
    - `"Webhook"`: API Server will call to an external webhook to do the conversion. Additional information
      is needed for this option. This requires spec.preserveUnknownFields to be false, and spec.conversion.webhook to be set.
    """
    webhook: Optional[Webhook] = None
    """
    webhook describes how to call the conversion webhook. Required when `strategy` is set to `"Webhook"`.
    """


class DefaultCompositionRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DefaultCompositionRef"]:
            return DefaultCompositionRef

        def build(self) -> "DefaultCompositionRef":
            return DefaultCompositionRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the Composition.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["DefaultCompositionRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DefaultCompositionRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DefaultCompositionRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DefaultCompositionRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DefaultCompositionRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the Composition.
    """


class EnforcedCompositionRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnforcedCompositionRef"]:
            return EnforcedCompositionRef

        def build(self) -> "EnforcedCompositionRef":
            return EnforcedCompositionRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the Composition.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["EnforcedCompositionRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnforcedCompositionRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnforcedCompositionRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnforcedCompositionRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnforcedCompositionRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the Composition.
    """


class Metadata(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Metadata"]:
            return Metadata

        def build(self) -> "Metadata":
            return Metadata(**self._attrs)

        def annotations(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Annotations is an unstructured key value map stored with a resource that may be
            set by external tools to store and retrieve arbitrary metadata. They are not
            queryable and should be preserved when modifying objects.
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
            """
            return self._set("annotations", value)

        def labels(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Map of string keys and values that can be used to organize and categorize
            (scope and select) objects. May match selectors of replication controllers
            More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
            and services.
            These labels are added to the composite resource and claim CRD's in addition
            to any labels defined by `CompositionResourceDefinition` `metadata.labels`.
            """
            return self._set("labels", value)

    class BuilderContext(BuilderContextBase["Metadata.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Metadata.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Metadata."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Metadata", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Metadata.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    annotations: Optional[Dict[str, str]] = None
    """
    Annotations is an unstructured key value map stored with a resource that may be
    set by external tools to store and retrieve arbitrary metadata. They are not
    queryable and should be preserved when modifying objects.
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
    """
    labels: Optional[Dict[str, str]] = None
    """
    Map of string keys and values that can be used to organize and categorize
    (scope and select) objects. May match selectors of replication controllers
    More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    and services.
    These labels are added to the composite resource and claim CRD's in addition
    to any labels defined by `CompositionResourceDefinition` `metadata.labels`.
    """


class Names(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Names"]:
            return Names

        def build(self) -> "Names":
            return Names(**self._attrs)

        def categories(self, value: Optional[List[str]], /) -> Self:
            """
            categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
            This is published in API discovery documents, and used by clients to support invocations like
            `kubectl get all`.
            """
            return self._set("categories", value)

        def kind(self, value: str, /) -> Self:
            """
            kind is the serialized kind of the resource. It is normally CamelCase and singular.
            Custom resource instances will use this value as the `kind` attribute in API calls.
            """
            return self._set("kind", value)

        def list_kind(self, value: Optional[str], /) -> Self:
            """
            listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
            """
            return self._set("list_kind", value)

        def plural(self, value: str, /) -> Self:
            """
            plural is the plural name of the resource to serve.
            The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
            Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
            Must be all lowercase.
            """
            return self._set("plural", value)

        def short_names(self, value: Optional[List[str]], /) -> Self:
            """
            shortNames are short names for the resource, exposed in API discovery documents,
            and used by clients to support invocations like `kubectl get <shortname>`.
            It must be all lowercase.
            """
            return self._set("short_names", value)

        def singular(self, value: Optional[str], /) -> Self:
            """
            singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
            """
            return self._set("singular", value)

    class BuilderContext(BuilderContextBase["Names.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Names.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Names."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Names", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Names.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    categories: Optional[List[str]] = None
    """
    categories is a list of grouped resources this custom resource belongs to (e.g. 'all').
    This is published in API discovery documents, and used by clients to support invocations like
    `kubectl get all`.
    """
    kind: str
    """
    kind is the serialized kind of the resource. It is normally CamelCase and singular.
    Custom resource instances will use this value as the `kind` attribute in API calls.
    """
    list_kind: Annotated[Optional[str], Field(alias="listKind")] = None
    """
    listKind is the serialized kind of the list for this resource. Defaults to "`kind`List".
    """
    plural: str
    """
    plural is the plural name of the resource to serve.
    The custom resources are served under `/apis/<group>/<version>/.../<plural>`.
    Must match the name of the CustomResourceDefinition (in the form `<names.plural>.<group>`).
    Must be all lowercase.
    """
    short_names: Annotated[Optional[List[str]], Field(alias="shortNames")] = None
    """
    shortNames are short names for the resource, exposed in API discovery documents,
    and used by clients to support invocations like `kubectl get <shortname>`.
    It must be all lowercase.
    """
    singular: Optional[str] = None
    """
    singular is the singular name of the resource. It must be all lowercase. Defaults to lowercased `kind`.
    """


class AdditionalPrinterColumn(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AdditionalPrinterColumn"]:
            return AdditionalPrinterColumn

        def build(self) -> "AdditionalPrinterColumn":
            return AdditionalPrinterColumn(**self._attrs)

        def description(self, value: Optional[str], /) -> Self:
            """
            description is a human readable description of this column.
            """
            return self._set("description", value)

        def format(self, value: Optional[str], /) -> Self:
            """
            format is an optional OpenAPI type definition for this column. The 'name' format is applied
            to the primary identifier column to assist in clients identifying column is the resource name.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
            """
            return self._set("format", value)

        def json_path(self, value: str, /) -> Self:
            """
            jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
            each custom resource to produce the value for this column.
            """
            return self._set("json_path", value)

        def name(self, value: str, /) -> Self:
            """
            name is a human readable name for the column.
            """
            return self._set("name", value)

        def priority(self, value: Optional[int], /) -> Self:
            """
            priority is an integer defining the relative importance of this column compared to others. Lower
            numbers are considered higher priority. Columns that may be omitted in limited space scenarios
            should be given a priority greater than 0.
            """
            return self._set("priority", value)

        def type(self, value: str, /) -> Self:
            """
            type is an OpenAPI type definition for this column.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["AdditionalPrinterColumn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AdditionalPrinterColumn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AdditionalPrinterColumn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AdditionalPrinterColumn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AdditionalPrinterColumn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    description: Optional[str] = None
    """
    description is a human readable description of this column.
    """
    format: Optional[str] = None
    """
    format is an optional OpenAPI type definition for this column. The 'name' format is applied
    to the primary identifier column to assist in clients identifying column is the resource name.
    See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
    """
    json_path: Annotated[str, Field(alias="jsonPath")]
    """
    jsonPath is a simple JSON path (i.e. with array notation) which is evaluated against
    each custom resource to produce the value for this column.
    """
    name: str
    """
    name is a human readable name for the column.
    """
    priority: Optional[int] = None
    """
    priority is an integer defining the relative importance of this column compared to others. Lower
    numbers are considered higher priority. Columns that may be omitted in limited space scenarios
    should be given a priority greater than 0.
    """
    type: str
    """
    type is an OpenAPI type definition for this column.
    See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#data-types for details.
    """


class Schema(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Schema"]:
            return Schema

        def build(self) -> "Schema":
            return Schema(**self._attrs)

        def open_apiv3_schema(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and
            pruning.
            """
            return self._set("open_apiv3_schema", value)

    class BuilderContext(BuilderContextBase["Schema.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Schema.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Schema."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Schema", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Schema.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    open_apiv3_schema: Annotated[Optional[Dict[str, Any]], Field(alias="openAPIV3Schema")] = None
    """
    OpenAPIV3Schema is the OpenAPI v3 schema to use for validation and
    pruning.
    """


class Version(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Version"]:
            return Version

        def build(self) -> "Version":
            return Version(**self._attrs)

        @overload
        def additional_printer_columns(
            self, value_or_callback: List[AdditionalPrinterColumn], /
        ) -> "Version.Builder": ...

        @overload
        def additional_printer_columns(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[AdditionalPrinterColumn, AdditionalPrinterColumn.Builder]],
                GenericListBuilder[AdditionalPrinterColumn, AdditionalPrinterColumn.Builder]
                | List[AdditionalPrinterColumn],
            ],
            /,
        ) -> "Version.Builder": ...

        @overload
        def additional_printer_columns(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[AdditionalPrinterColumn.Builder]: ...

        def additional_printer_columns(self, value_or_callback=None, /):
            """
            AdditionalPrinterColumns specifies additional columns returned in Table
            output. If no columns are specified, a single column displaying the age
            of the custom resource is used. See the following link for details:
            https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[AdditionalPrinterColumn.Builder]()
                context._parent_builder = self
                context._field_name = "additional_printer_columns"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AdditionalPrinterColumn.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("additional_printer_columns", value)

        def deprecated(self, value: Optional[bool], /) -> Self:
            """
            The deprecated field specifies that this version is deprecated and should
            not be used.
            """
            return self._set("deprecated", value)

        def deprecation_warning(self, value: Optional[str], /) -> Self:
            """
            DeprecationWarning specifies the message that should be shown to the user
            when using this version.
            """
            return self._set("deprecation_warning", value)

        def name(self, value: str, /) -> Self:
            """
            Name of this version, e.g. “v1”, “v2beta1”, etc. Composite resources are
            served under this version at `/apis/<group>/<version>/...` if `served` is
            true.
            """
            return self._set("name", value)

        def referenceable(self, value: bool, /) -> Self:
            """
            Referenceable specifies that this version may be referenced by a
            Composition in order to configure which resources an XR may be composed
            of. Exactly one version must be marked as referenceable; all Compositions
            must target only the referenceable version. The referenceable version
            must be served. It's mapped to the CRD's `spec.versions[*].storage` field.
            """
            return self._set("referenceable", value)

        @overload
        def schema_(self, value_or_callback: Optional[Schema], /) -> "Version.Builder": ...

        @overload
        def schema_(
            self,
            value_or_callback: Callable[[Schema.Builder], Schema.Builder | Schema],
            /,
        ) -> "Version.Builder": ...

        @overload
        def schema_(self, value_or_callback: Never = ...) -> "Schema.BuilderContext": ...

        def schema_(self, value_or_callback=None, /):
            """
            Schema describes the schema used for validation, pruning, and defaulting
            of this version of the defined composite resource. Fields required by all
            composite resources will be injected into this schema automatically, and
            will override equivalently named fields in this schema. Omitting this
            schema results in a schema that contains only the fields required by all
            composite resources.
            """
            if self._in_context and value_or_callback is None:
                context = Schema.BuilderContext()
                context._parent_builder = self
                context._field_name = "schema_"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Schema.builder())
                if isinstance(output, Schema.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("schema_", value)

        def served(self, value: bool, /) -> Self:
            """
            Served specifies that this version should be served via REST APIs.
            """
            return self._set("served", value)

    class BuilderContext(BuilderContextBase["Version.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Version.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Version."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Version", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Version.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    additional_printer_columns: Annotated[
        Optional[List[AdditionalPrinterColumn]], Field(alias="additionalPrinterColumns")
    ] = None
    """
    AdditionalPrinterColumns specifies additional columns returned in Table
    output. If no columns are specified, a single column displaying the age
    of the custom resource is used. See the following link for details:
    https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
    """
    deprecated: Optional[bool] = None
    """
    The deprecated field specifies that this version is deprecated and should
    not be used.
    """
    deprecation_warning: Annotated[
        Optional[str], Field(alias="deprecationWarning", max_length=256)
    ] = None
    """
    DeprecationWarning specifies the message that should be shown to the user
    when using this version.
    """
    name: str
    """
    Name of this version, e.g. “v1”, “v2beta1”, etc. Composite resources are
    served under this version at `/apis/<group>/<version>/...` if `served` is
    true.
    """
    referenceable: bool
    """
    Referenceable specifies that this version may be referenced by a
    Composition in order to configure which resources an XR may be composed
    of. Exactly one version must be marked as referenceable; all Compositions
    must target only the referenceable version. The referenceable version
    must be served. It's mapped to the CRD's `spec.versions[*].storage` field.
    """
    schema_: Annotated[Optional[Schema], Field(alias="schema")] = None
    """
    Schema describes the schema used for validation, pruning, and defaulting
    of this version of the defined composite resource. Fields required by all
    composite resources will be injected into this schema automatically, and
    will override equivalently named fields in this schema. Omitting this
    schema results in a schema that contains only the fields required by all
    composite resources.
    """
    served: bool
    """
    Served specifies that this version should be served via REST APIs.
    """


class CompositeResourceDefinitionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeResourceDefinitionSpec"]:
            return CompositeResourceDefinitionSpec

        def build(self) -> "CompositeResourceDefinitionSpec":
            return CompositeResourceDefinitionSpec(**self._attrs)

        @overload
        def claim_names(
            self, value_or_callback: Optional[ClaimNames], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def claim_names(
            self,
            value_or_callback: Callable[[ClaimNames.Builder], ClaimNames.Builder | ClaimNames],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def claim_names(self, value_or_callback: Never = ...) -> "ClaimNames.BuilderContext": ...

        def claim_names(self, value_or_callback=None, /):
            """
            ClaimNames specifies the names of an optional composite resource claim.
            When claim names are specified Crossplane will create a namespaced
            'composite resource claim' CRD that corresponds to the defined composite
            resource. This composite resource claim acts as a namespaced proxy for
            the composite resource; creating, updating, or deleting the claim will
            create, update, or delete a corresponding composite resource. You may add
            claim names to an existing CompositeResourceDefinition, but they cannot
            be changed or removed once they have been set.
            """
            if self._in_context and value_or_callback is None:
                context = ClaimNames.BuilderContext()
                context._parent_builder = self
                context._field_name = "claim_names"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClaimNames.builder())
                if isinstance(output, ClaimNames.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("claim_names", value)

        def connection_secret_keys(self, value: Optional[List[str]], /) -> Self:
            """
            ConnectionSecretKeys is the list of connection secret keys the
            defined XR can publish. If the list is empty, all keys will be
            published. If the list isn't empty, any connection secret keys that
            don't appear in the list will be filtered out. Only LegacyCluster XRs
            support connection secrets.
            """
            return self._set("connection_secret_keys", value)

        @overload
        def conversion(
            self, value_or_callback: Optional[Conversion], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def conversion(
            self,
            value_or_callback: Callable[[Conversion.Builder], Conversion.Builder | Conversion],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def conversion(self, value_or_callback: Never = ...) -> "Conversion.BuilderContext": ...

        def conversion(self, value_or_callback=None, /):
            """
            Conversion defines all conversion settings for the defined Composite resource.
            """
            if self._in_context and value_or_callback is None:
                context = Conversion.BuilderContext()
                context._parent_builder = self
                context._field_name = "conversion"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Conversion.builder())
                if isinstance(output, Conversion.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("conversion", value)

        def default_composite_delete_policy(
            self, value: Optional[Literal["Background", "Foreground"]], /
        ) -> Self:
            """
            DefaultCompositeDeletePolicy is the policy used when deleting the Composite
            that is associated with the Claim if no policy has been specified.
            """
            return self._set("default_composite_delete_policy", value)

        @overload
        def default_composition_ref(
            self, value_or_callback: Optional[DefaultCompositionRef], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def default_composition_ref(
            self,
            value_or_callback: Callable[
                [DefaultCompositionRef.Builder],
                DefaultCompositionRef.Builder | DefaultCompositionRef,
            ],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def default_composition_ref(
            self, value_or_callback: Never = ...
        ) -> "DefaultCompositionRef.BuilderContext": ...

        def default_composition_ref(self, value_or_callback=None, /):
            """
            DefaultCompositionRef refers to the Composition resource that will be used
            in case no composition selector is given.
            """
            if self._in_context and value_or_callback is None:
                context = DefaultCompositionRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "default_composition_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DefaultCompositionRef.builder())
                if isinstance(output, DefaultCompositionRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("default_composition_ref", value)

        def default_composition_update_policy(
            self, value: Optional[Literal["Automatic", "Manual"]], /
        ) -> Self:
            """
            DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
            Composition Revision has been created if no policy has been specified on the composite.
            """
            return self._set("default_composition_update_policy", value)

        @overload
        def enforced_composition_ref(
            self, value_or_callback: Optional[EnforcedCompositionRef], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def enforced_composition_ref(
            self,
            value_or_callback: Callable[
                [EnforcedCompositionRef.Builder],
                EnforcedCompositionRef.Builder | EnforcedCompositionRef,
            ],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def enforced_composition_ref(
            self, value_or_callback: Never = ...
        ) -> "EnforcedCompositionRef.BuilderContext": ...

        def enforced_composition_ref(self, value_or_callback=None, /):
            """
            EnforcedCompositionRef refers to the Composition resource that will be used
            by all composite instances whose schema is defined by this definition.
            """
            if self._in_context and value_or_callback is None:
                context = EnforcedCompositionRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "enforced_composition_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnforcedCompositionRef.builder())
                if isinstance(output, EnforcedCompositionRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("enforced_composition_ref", value)

        def group(self, value: str, /) -> Self:
            """
            Group specifies the API group of the defined composite resource.
            Composite resources are served under `/apis/<group>/...`. Must match the
            name of the XRD (in the form `<names.plural>.<group>`).
            """
            return self._set("group", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[Metadata], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[[Metadata.Builder], Metadata.Builder | Metadata],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "Metadata.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
            """
            if self._in_context and value_or_callback is None:
                context = Metadata.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Metadata.builder())
                if isinstance(output, Metadata.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def names(
            self, value_or_callback: Names, /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def names(
            self, value_or_callback: Callable[[Names.Builder], Names.Builder | Names], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def names(self, value_or_callback: Never = ...) -> "Names.BuilderContext": ...

        def names(self, value_or_callback=None, /):
            """
            Names specifies the resource and kind names of the defined composite
            resource.
            """
            if self._in_context and value_or_callback is None:
                context = Names.BuilderContext()
                context._parent_builder = self
                context._field_name = "names"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Names.builder())
                if isinstance(output, Names.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("names", value)

        def scope(
            self, value: Optional[Literal["LegacyCluster", "Namespaced", "Cluster"]], /
        ) -> Self:
            """
            Scope of the defined composite resource. Namespaced composite resources
            are scoped to a single namespace. Cluster scoped composite resource exist
            outside the scope of any namespace. Neither can be claimed. Legacy
            cluster scoped composite resources are cluster scoped resources that can
            be claimed.
            """
            return self._set("scope", value)

        @overload
        def versions(
            self, value_or_callback: List[Version], /
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def versions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Version, Version.Builder]],
                GenericListBuilder[Version, Version.Builder] | List[Version],
            ],
            /,
        ) -> "CompositeResourceDefinitionSpec.Builder": ...

        @overload
        def versions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Version.Builder]: ...

        def versions(self, value_or_callback=None, /):
            """
            Versions is the list of all API versions of the defined composite
            resource. Version names are used to compute the order in which served
            versions are listed in API discovery. If the version string is
            "kube-like", it will sort above non "kube-like" version strings, which
            are ordered lexicographically. "Kube-like" versions start with a "v",
            then are followed by a number (the major version), then optionally the
            string "alpha" or "beta" and another number (the minor version). These
            are sorted first by GA > beta > alpha (where GA is a version with no
            suffix such as beta or alpha), and then by comparing major version, then
            minor version. An example sorted list of versions: v10, v2, v1, v11beta2,
            v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Version.Builder]()
                context._parent_builder = self
                context._field_name = "versions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Version.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("versions", value)

    class BuilderContext(BuilderContextBase["CompositeResourceDefinitionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeResourceDefinitionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeResourceDefinitionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeResourceDefinitionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeResourceDefinitionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    claim_names: Annotated[Optional[ClaimNames], Field(alias="claimNames")] = None
    """
    ClaimNames specifies the names of an optional composite resource claim.
    When claim names are specified Crossplane will create a namespaced
    'composite resource claim' CRD that corresponds to the defined composite
    resource. This composite resource claim acts as a namespaced proxy for
    the composite resource; creating, updating, or deleting the claim will
    create, update, or delete a corresponding composite resource. You may add
    claim names to an existing CompositeResourceDefinition, but they cannot
    be changed or removed once they have been set.
    """
    connection_secret_keys: Annotated[Optional[List[str]], Field(alias="connectionSecretKeys")] = (
        None
    )
    """
    ConnectionSecretKeys is the list of connection secret keys the
    defined XR can publish. If the list is empty, all keys will be
    published. If the list isn't empty, any connection secret keys that
    don't appear in the list will be filtered out. Only LegacyCluster XRs
    support connection secrets.
    """
    conversion: Optional[Conversion] = None
    """
    Conversion defines all conversion settings for the defined Composite resource.
    """
    default_composite_delete_policy: Annotated[
        Optional[Literal["Background", "Foreground"]],
        Field(alias="defaultCompositeDeletePolicy"),
    ] = "Background"
    """
    DefaultCompositeDeletePolicy is the policy used when deleting the Composite
    that is associated with the Claim if no policy has been specified.
    """
    default_composition_ref: Annotated[
        Optional[DefaultCompositionRef], Field(alias="defaultCompositionRef")
    ] = None
    """
    DefaultCompositionRef refers to the Composition resource that will be used
    in case no composition selector is given.
    """
    default_composition_update_policy: Annotated[
        Optional[Literal["Automatic", "Manual"]],
        Field(alias="defaultCompositionUpdatePolicy"),
    ] = "Automatic"
    """
    DefaultCompositionUpdatePolicy is the policy used when updating composites after a new
    Composition Revision has been created if no policy has been specified on the composite.
    """
    enforced_composition_ref: Annotated[
        Optional[EnforcedCompositionRef], Field(alias="enforcedCompositionRef")
    ] = None
    """
    EnforcedCompositionRef refers to the Composition resource that will be used
    by all composite instances whose schema is defined by this definition.
    """
    group: str
    """
    Group specifies the API group of the defined composite resource.
    Composite resources are served under `/apis/<group>/...`. Must match the
    name of the XRD (in the form `<names.plural>.<group>`).
    """
    metadata: Optional[Metadata] = None
    """
    Metadata specifies the desired metadata for the defined composite resource and claim CRD's.
    """
    names: Names
    """
    Names specifies the resource and kind names of the defined composite
    resource.
    """
    scope: Optional[Literal["LegacyCluster", "Namespaced", "Cluster"]] = "LegacyCluster"
    """
    Scope of the defined composite resource. Namespaced composite resources
    are scoped to a single namespace. Cluster scoped composite resource exist
    outside the scope of any namespace. Neither can be claimed. Legacy
    cluster scoped composite resources are cluster scoped resources that can
    be claimed.
    """
    versions: List[Version]
    """
    Versions is the list of all API versions of the defined composite
    resource. Version names are used to compute the order in which served
    versions are listed in API discovery. If the version string is
    "kube-like", it will sort above non "kube-like" version strings, which
    are ordered lexicographically. "Kube-like" versions start with a "v",
    then are followed by a number (the major version), then optionally the
    string "alpha" or "beta" and another number (the minor version). These
    are sorted first by GA > beta > alpha (where GA is a version with no
    suffix such as beta or alpha), and then by comparing major version, then
    minor version. An example sorted list of versions: v10, v2, v1, v11beta2,
    v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            LastTransitionTime is the last time this condition transitioned from one
            status to another.
            """
            return self._set("last_transition_time", value)

        def message(self, value: Optional[str], /) -> Self:
            """
            A Message containing details about this condition's last transition from
            one status to another, if any.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            A Reason for this condition's last transition from one status to another.
            """
            return self._set("reason", value)

        def status(self, value: str, /) -> Self:
            """
            Status of this condition; is it currently True, False, or Unknown?
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            Type of this condition. At most one of each condition type may apply to
            a resource at any point in time.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    LastTransitionTime is the last time this condition transitioned from one
    status to another.
    """
    message: Optional[str] = None
    """
    A Message containing details about this condition's last transition from
    one status to another, if any.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: str
    """
    A Reason for this condition's last transition from one status to another.
    """
    status: str
    """
    Status of this condition; is it currently True, False, or Unknown?
    """
    type: str
    """
    Type of this condition. At most one of each condition type may apply to
    a resource at any point in time.
    """


class CompositeResourceClaimType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeResourceClaimType"]:
            return CompositeResourceClaimType

        def build(self) -> "CompositeResourceClaimType":
            return CompositeResourceClaimType(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the type.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the type.
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["CompositeResourceClaimType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeResourceClaimType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeResourceClaimType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeResourceClaimType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeResourceClaimType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the type.
    """
    kind: str
    """
    Kind of the type.
    """


class CompositeResourceType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeResourceType"]:
            return CompositeResourceType

        def build(self) -> "CompositeResourceType":
            return CompositeResourceType(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the type.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the type.
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["CompositeResourceType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeResourceType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeResourceType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeResourceType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeResourceType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the type.
    """
    kind: str
    """
    Kind of the type.
    """


class Controllers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Controllers"]:
            return Controllers

        def build(self) -> "Controllers":
            return Controllers(**self._attrs)

        @overload
        def composite_resource_claim_type(
            self, value_or_callback: Optional[CompositeResourceClaimType], /
        ) -> "Controllers.Builder": ...

        @overload
        def composite_resource_claim_type(
            self,
            value_or_callback: Callable[
                [CompositeResourceClaimType.Builder],
                CompositeResourceClaimType.Builder | CompositeResourceClaimType,
            ],
            /,
        ) -> "Controllers.Builder": ...

        @overload
        def composite_resource_claim_type(
            self, value_or_callback: Never = ...
        ) -> "CompositeResourceClaimType.BuilderContext": ...

        def composite_resource_claim_type(self, value_or_callback=None, /):
            """
            The CompositeResourceClaimTypeRef is the type of composite resource claim
            that Crossplane is currently reconciling for this definition. Its version
            will eventually become consistent with the definition's referenceable
            version. Note that clients may interact with any served type; this is
            simply the type that Crossplane interacts with.
            """
            if self._in_context and value_or_callback is None:
                context = CompositeResourceClaimType.BuilderContext()
                context._parent_builder = self
                context._field_name = "composite_resource_claim_type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositeResourceClaimType.builder())
                if isinstance(output, CompositeResourceClaimType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("composite_resource_claim_type", value)

        @overload
        def composite_resource_type(
            self, value_or_callback: Optional[CompositeResourceType], /
        ) -> "Controllers.Builder": ...

        @overload
        def composite_resource_type(
            self,
            value_or_callback: Callable[
                [CompositeResourceType.Builder],
                CompositeResourceType.Builder | CompositeResourceType,
            ],
            /,
        ) -> "Controllers.Builder": ...

        @overload
        def composite_resource_type(
            self, value_or_callback: Never = ...
        ) -> "CompositeResourceType.BuilderContext": ...

        def composite_resource_type(self, value_or_callback=None, /):
            """
            The CompositeResourceTypeRef is the type of composite resource that
            Crossplane is currently reconciling for this definition. Its version will
            eventually become consistent with the definition's referenceable version.
            Note that clients may interact with any served type; this is simply the
            type that Crossplane interacts with.
            """
            if self._in_context and value_or_callback is None:
                context = CompositeResourceType.BuilderContext()
                context._parent_builder = self
                context._field_name = "composite_resource_type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositeResourceType.builder())
                if isinstance(output, CompositeResourceType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("composite_resource_type", value)

    class BuilderContext(BuilderContextBase["Controllers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Controllers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Controllers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Controllers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Controllers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    composite_resource_claim_type: Annotated[
        Optional[CompositeResourceClaimType], Field(alias="compositeResourceClaimType")
    ] = None
    """
    The CompositeResourceClaimTypeRef is the type of composite resource claim
    that Crossplane is currently reconciling for this definition. Its version
    will eventually become consistent with the definition's referenceable
    version. Note that clients may interact with any served type; this is
    simply the type that Crossplane interacts with.
    """
    composite_resource_type: Annotated[
        Optional[CompositeResourceType], Field(alias="compositeResourceType")
    ] = None
    """
    The CompositeResourceTypeRef is the type of composite resource that
    Crossplane is currently reconciling for this definition. Its version will
    eventually become consistent with the definition's referenceable version.
    Note that clients may interact with any served type; this is simply the
    type that Crossplane interacts with.
    """


class CompositeResourceDefinitionStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeResourceDefinitionStatus"]:
            return CompositeResourceDefinitionStatus

        def build(self) -> "CompositeResourceDefinitionStatus":
            return CompositeResourceDefinitionStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "CompositeResourceDefinitionStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "CompositeResourceDefinitionStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions of the resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def controllers(
            self, value_or_callback: Optional[Controllers], /
        ) -> "CompositeResourceDefinitionStatus.Builder": ...

        @overload
        def controllers(
            self,
            value_or_callback: Callable[[Controllers.Builder], Controllers.Builder | Controllers],
            /,
        ) -> "CompositeResourceDefinitionStatus.Builder": ...

        @overload
        def controllers(self, value_or_callback: Never = ...) -> "Controllers.BuilderContext": ...

        def controllers(self, value_or_callback=None, /):
            """
            Controllers represents the status of the controllers that power this
            composite resource definition.
            """
            if self._in_context and value_or_callback is None:
                context = Controllers.BuilderContext()
                context._parent_builder = self
                context._field_name = "controllers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Controllers.builder())
                if isinstance(output, Controllers.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("controllers", value)

    class BuilderContext(BuilderContextBase["CompositeResourceDefinitionStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeResourceDefinitionStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeResourceDefinitionStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeResourceDefinitionStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeResourceDefinitionStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: Optional[List[Condition]] = None
    """
    Conditions of the resource.
    """
    controllers: Optional[Controllers] = None
    """
    Controllers represents the status of the controllers that power this
    composite resource definition.
    """


class CompositeResourceDefinition(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeResourceDefinition"]:
            return CompositeResourceDefinition

        def build(self) -> "CompositeResourceDefinition":
            return CompositeResourceDefinition(**self._attrs)

        def api_version(
            self, value: Optional[Literal["apiextensions.crossplane.io/v1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["CompositeResourceDefinition"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[CompositeResourceDefinitionSpec], /
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CompositeResourceDefinitionSpec.Builder],
                CompositeResourceDefinitionSpec.Builder | CompositeResourceDefinitionSpec,
            ],
            /,
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "CompositeResourceDefinitionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CompositeResourceDefinitionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositeResourceDefinitionSpec.builder())
                if isinstance(output, CompositeResourceDefinitionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[CompositeResourceDefinitionStatus], /
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [CompositeResourceDefinitionStatus.Builder],
                CompositeResourceDefinitionStatus.Builder | CompositeResourceDefinitionStatus,
            ],
            /,
        ) -> "CompositeResourceDefinition.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "CompositeResourceDefinitionStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CompositeResourceDefinitionStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositeResourceDefinitionStatus.builder())
                if isinstance(output, CompositeResourceDefinitionStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["CompositeResourceDefinition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeResourceDefinition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeResourceDefinition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeResourceDefinition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeResourceDefinition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["apiextensions.crossplane.io/v1"]], Field(alias="apiVersion")
    ] = "apiextensions.crossplane.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["CompositeResourceDefinition"]] = "CompositeResourceDefinition"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[CompositeResourceDefinitionSpec] = None
    status: Optional[CompositeResourceDefinitionStatus] = None
