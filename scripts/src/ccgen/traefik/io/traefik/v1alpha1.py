# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    Union,
    cast,
    overload,
)

from cloudcoil.pydantic import (
    BaseBuilder,
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field, RootModel

from ..k8s.apimachinery.pkg.apis.meta import v1


class Middleware(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Middleware"]:
            return Middleware

        def build(self) -> "Middleware":
            return Middleware(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Middleware resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Middleware resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Middleware.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Middleware.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Middleware."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Middleware", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Middleware.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Middleware resource.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Middleware resource.
    """


class Observability(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Observability"]:
            return Observability

        def build(self) -> "Observability":
            return Observability(**self._attrs)

        def access_logs(self, value: Optional[bool], /) -> Self:
            return self._set("access_logs", value)

        def metrics(self, value: Optional[bool], /) -> Self:
            return self._set("metrics", value)

        def tracing(self, value: Optional[bool], /) -> Self:
            return self._set("tracing", value)

    class BuilderContext(BuilderContextBase["Observability.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Observability.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Observability."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Observability", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Observability.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_logs: Annotated[Optional[bool], Field(alias="accessLogs")] = None
    metrics: Optional[bool] = None
    tracing: Optional[bool] = None


class HealthCheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HealthCheck"]:
            return HealthCheck

        def build(self) -> "HealthCheck":
            return HealthCheck(**self._attrs)

        def follow_redirects(self, value: Optional[bool], /) -> Self:
            """
            FollowRedirects defines whether redirects should be followed during the health check calls.
            Default: true
            """
            return self._set("follow_redirects", value)

        def headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Headers defines custom headers to be sent to the health check endpoint.
            """
            return self._set("headers", value)

        def hostname(self, value: Optional[str], /) -> Self:
            """
            Hostname defines the value of hostname in the Host header of the health check request.
            """
            return self._set("hostname", value)

        def interval(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Interval defines the frequency of the health check calls.
            Default: 30s
            """
            return self._set("interval", value)

        def method(self, value: Optional[str], /) -> Self:
            """
            Method defines the healthcheck method.
            """
            return self._set("method", value)

        def mode(self, value: Optional[str], /) -> Self:
            """
            Mode defines the health check mode.
            If defined to grpc, will use the gRPC health check protocol to probe the server.
            Default: http
            """
            return self._set("mode", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path defines the server URL path for the health check endpoint.
            """
            return self._set("path", value)

        def port(self, value: Optional[int], /) -> Self:
            """
            Port defines the server URL port for the health check endpoint.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme replaces the server URL scheme for the health check endpoint.
            """
            return self._set("scheme", value)

        def status(self, value: Optional[int], /) -> Self:
            """
            Status defines the expected HTTP status code of the response to the health check request.
            """
            return self._set("status", value)

        def timeout(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
            Default: 5s
            """
            return self._set("timeout", value)

    class BuilderContext(BuilderContextBase["HealthCheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HealthCheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HealthCheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HealthCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HealthCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    follow_redirects: Annotated[Optional[bool], Field(alias="followRedirects")] = None
    """
    FollowRedirects defines whether redirects should be followed during the health check calls.
    Default: true
    """
    headers: Optional[Dict[str, str]] = None
    """
    Headers defines custom headers to be sent to the health check endpoint.
    """
    hostname: Optional[str] = None
    """
    Hostname defines the value of hostname in the Host header of the health check request.
    """
    interval: Optional[Union[int, str]] = None
    """
    Interval defines the frequency of the health check calls.
    Default: 30s
    """
    method: Optional[str] = None
    """
    Method defines the healthcheck method.
    """
    mode: Optional[str] = None
    """
    Mode defines the health check mode.
    If defined to grpc, will use the gRPC health check protocol to probe the server.
    Default: http
    """
    path: Optional[str] = None
    """
    Path defines the server URL path for the health check endpoint.
    """
    port: Optional[int] = None
    """
    Port defines the server URL port for the health check endpoint.
    """
    scheme: Optional[str] = None
    """
    Scheme replaces the server URL scheme for the health check endpoint.
    """
    status: Optional[int] = None
    """
    Status defines the expected HTTP status code of the response to the health check request.
    """
    timeout: Optional[Union[int, str]] = None
    """
    Timeout defines the maximum duration Traefik will wait for a health check request before considering the server unhealthy.
    Default: 5s
    """


class ResponseForwarding(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResponseForwarding"]:
            return ResponseForwarding

        def build(self) -> "ResponseForwarding":
            return ResponseForwarding(**self._attrs)

        def flush_interval(self, value: Optional[str], /) -> Self:
            """
            FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
            A negative value means to flush immediately after each write to the client.
            This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
            for such responses, writes are flushed to the client immediately.
            Default: 100ms
            """
            return self._set("flush_interval", value)

    class BuilderContext(BuilderContextBase["ResponseForwarding.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResponseForwarding.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResponseForwarding."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResponseForwarding", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResponseForwarding.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    flush_interval: Annotated[Optional[str], Field(alias="flushInterval")] = None
    """
    FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
    A negative value means to flush immediately after each write to the client.
    This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
    for such responses, writes are flushed to the client immediately.
    Default: 100ms
    """


class Cookie(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Cookie"]:
            return Cookie

        def build(self) -> "Cookie":
            return Cookie(**self._attrs)

        def domain(self, value: Optional[str], /) -> Self:
            """
            Domain defines the host to which the cookie will be sent.
            More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
            """
            return self._set("domain", value)

        def http_only(self, value: Optional[bool], /) -> Self:
            """
            HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
            """
            return self._set("http_only", value)

        def max_age(self, value: Optional[int], /) -> Self:
            """
            MaxAge defines the number of seconds until the cookie expires.
            When set to a negative number, the cookie expires immediately.
            When set to zero, the cookie never expires.
            """
            return self._set("max_age", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name defines the Cookie name.
            """
            return self._set("name", value)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
            When not provided the cookie will be sent on every request to the domain.
            More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
            """
            return self._set("path", value)

        def same_site(self, value: Optional[Literal["none", "lax", "strict"]], /) -> Self:
            """
            SameSite defines the same site policy.
            More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
            """
            return self._set("same_site", value)

        def secure(self, value: Optional[bool], /) -> Self:
            """
            Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
            """
            return self._set("secure", value)

    class BuilderContext(BuilderContextBase["Cookie.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Cookie.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Cookie."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Cookie", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Cookie.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    domain: Optional[str] = None
    """
    Domain defines the host to which the cookie will be sent.
    More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#domaindomain-value
    """
    http_only: Annotated[Optional[bool], Field(alias="httpOnly")] = None
    """
    HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
    """
    max_age: Annotated[Optional[int], Field(alias="maxAge")] = None
    """
    MaxAge defines the number of seconds until the cookie expires.
    When set to a negative number, the cookie expires immediately.
    When set to zero, the cookie never expires.
    """
    name: Optional[str] = None
    """
    Name defines the Cookie name.
    """
    path: Optional[str] = None
    """
    Path defines the path that must exist in the requested URL for the browser to send the Cookie header.
    When not provided the cookie will be sent on every request to the domain.
    More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#pathpath-value
    """
    same_site: Annotated[Optional[Literal["none", "lax", "strict"]], Field(alias="sameSite")] = None
    """
    SameSite defines the same site policy.
    More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
    """
    secure: Optional[bool] = None
    """
    Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
    """


class Sticky(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Sticky"]:
            return Sticky

        def build(self) -> "Sticky":
            return Sticky(**self._attrs)

        @overload
        def cookie(self, value_or_callback: Optional[Cookie], /) -> "Sticky.Builder": ...

        @overload
        def cookie(
            self,
            value_or_callback: Callable[[Cookie.Builder], Cookie.Builder | Cookie],
            /,
        ) -> "Sticky.Builder": ...

        @overload
        def cookie(self, value_or_callback: Never = ...) -> "Cookie.BuilderContext": ...

        def cookie(self, value_or_callback=None, /):
            """
            Cookie defines the sticky cookie configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Cookie.BuilderContext()
                context._parent_builder = self
                context._field_name = "cookie"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Cookie.builder())
                if isinstance(output, Cookie.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("cookie", value)

    class BuilderContext(BuilderContextBase["Sticky.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Sticky.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Sticky."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Sticky", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Sticky.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cookie: Optional[Cookie] = None
    """
    Cookie defines the sticky cookie configuration.
    """


class Service(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Service"]:
            return Service

        def build(self) -> "Service":
            return Service(**self._attrs)

        @overload
        def health_check(
            self, value_or_callback: Optional[HealthCheck], /
        ) -> "Service.Builder": ...

        @overload
        def health_check(
            self,
            value_or_callback: Callable[[HealthCheck.Builder], HealthCheck.Builder | HealthCheck],
            /,
        ) -> "Service.Builder": ...

        @overload
        def health_check(self, value_or_callback: Never = ...) -> "HealthCheck.BuilderContext": ...

        def health_check(self, value_or_callback=None, /):
            """
            Healthcheck defines health checks for ExternalName services.
            """
            if self._in_context and value_or_callback is None:
                context = HealthCheck.BuilderContext()
                context._parent_builder = self
                context._field_name = "health_check"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.builder())
                if isinstance(output, HealthCheck.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_check", value)

        def kind(self, value: Optional[Literal["Service", "TraefikService"]], /) -> Self:
            """
            Kind defines the kind of the Service.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service or TraefikService.
            The differentiation between the two is specified in the Kind field.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def pass_host_header(self, value: Optional[bool], /) -> Self:
            """
            PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
            By default, passHostHeader is true.
            """
            return self._set("pass_host_header", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        @overload
        def response_forwarding(
            self, value_or_callback: Optional[ResponseForwarding], /
        ) -> "Service.Builder": ...

        @overload
        def response_forwarding(
            self,
            value_or_callback: Callable[
                [ResponseForwarding.Builder],
                ResponseForwarding.Builder | ResponseForwarding,
            ],
            /,
        ) -> "Service.Builder": ...

        @overload
        def response_forwarding(
            self, value_or_callback: Never = ...
        ) -> "ResponseForwarding.BuilderContext": ...

        def response_forwarding(self, value_or_callback=None, /):
            """
            ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
            """
            if self._in_context and value_or_callback is None:
                context = ResponseForwarding.BuilderContext()
                context._parent_builder = self
                context._field_name = "response_forwarding"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResponseForwarding.builder())
                if isinstance(output, ResponseForwarding.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response_forwarding", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
            It defaults to https when Kubernetes Service port is 443, http otherwise.
            """
            return self._set("scheme", value)

        def servers_transport(self, value: Optional[str], /) -> Self:
            """
            ServersTransport defines the name of ServersTransport resource to use.
            It allows to configure the transport between Traefik and your servers.
            Can only be used on a Kubernetes Service.
            """
            return self._set("servers_transport", value)

        @overload
        def sticky(self, value_or_callback: Optional[Sticky], /) -> "Service.Builder": ...

        @overload
        def sticky(
            self,
            value_or_callback: Callable[[Sticky.Builder], Sticky.Builder | Sticky],
            /,
        ) -> "Service.Builder": ...

        @overload
        def sticky(self, value_or_callback: Never = ...) -> "Sticky.BuilderContext": ...

        def sticky(self, value_or_callback=None, /):
            """
            Sticky defines the sticky sessions configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
            """
            if self._in_context and value_or_callback is None:
                context = Sticky.BuilderContext()
                context._parent_builder = self
                context._field_name = "sticky"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sticky.builder())
                if isinstance(output, Sticky.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky", value)

        def strategy(self, value: Optional[Literal["wrr", "p2c", "RoundRobin"]], /) -> Self:
            """
            Strategy defines the load balancing strategy between the servers.
            Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
            RoundRobin value is deprecated and supported for backward compatibility.
            """
            return self._set("strategy", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight and should only be specified when Name references a TraefikService object
            (and to be precise, one that embeds a Weighted Round Robin).
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Service.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Service.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Service."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Service", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Service.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    health_check: Annotated[Optional[HealthCheck], Field(alias="healthCheck")] = None
    """
    Healthcheck defines health checks for ExternalName services.
    """
    kind: Optional[Literal["Service", "TraefikService"]] = None
    """
    Kind defines the kind of the Service.
    """
    name: str
    """
    Name defines the name of the referenced Kubernetes Service or TraefikService.
    The differentiation between the two is specified in the Kind field.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    pass_host_header: Annotated[Optional[bool], Field(alias="passHostHeader")] = None
    """
    PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
    By default, passHostHeader is true.
    """
    port: Optional[Union[int, str]] = None
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    response_forwarding: Annotated[
        Optional[ResponseForwarding], Field(alias="responseForwarding")
    ] = None
    """
    ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
    """
    scheme: Optional[str] = None
    """
    Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
    It defaults to https when Kubernetes Service port is 443, http otherwise.
    """
    servers_transport: Annotated[Optional[str], Field(alias="serversTransport")] = None
    """
    ServersTransport defines the name of ServersTransport resource to use.
    It allows to configure the transport between Traefik and your servers.
    Can only be used on a Kubernetes Service.
    """
    sticky: Optional[Sticky] = None
    """
    Sticky defines the sticky sessions configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
    """
    strategy: Optional[Literal["wrr", "p2c", "RoundRobin"]] = None
    """
    Strategy defines the load balancing strategy between the servers.
    Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
    RoundRobin value is deprecated and supported for backward compatibility.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight and should only be specified when Name references a TraefikService object
    (and to be precise, one that embeds a Weighted Round Robin).
    """


class Route(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Route"]:
            return Route

        def build(self) -> "Route":
            return Route(**self._attrs)

        def kind(self, value: Optional[Literal["Rule"]], /) -> Self:
            """
            Kind defines the kind of the route.
            Rule is the only supported kind.
            If not defined, defaults to Rule.
            """
            return self._set("kind", value)

        def match(self, value: str, /) -> Self:
            """
            Match defines the router's rule.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rule
            """
            return self._set("match", value)

        @overload
        def middlewares(self, value_or_callback: List[Middleware], /) -> "Route.Builder": ...

        @overload
        def middlewares(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Middleware, Middleware.Builder]],
                GenericListBuilder[Middleware, Middleware.Builder] | List[Middleware],
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def middlewares(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Middleware.Builder]: ...

        def middlewares(self, value_or_callback=None, /):
            """
            Middlewares defines the list of references to Middleware resources.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-middleware
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Middleware.Builder]()
                context._parent_builder = self
                context._field_name = "middlewares"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Middleware.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("middlewares", value)

        @overload
        def observability(
            self, value_or_callback: Optional[Observability], /
        ) -> "Route.Builder": ...

        @overload
        def observability(
            self,
            value_or_callback: Callable[
                [Observability.Builder], Observability.Builder | Observability
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def observability(
            self, value_or_callback: Never = ...
        ) -> "Observability.BuilderContext": ...

        def observability(self, value_or_callback=None, /):
            """
            Observability defines the observability configuration for a router.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#observability
            """
            if self._in_context and value_or_callback is None:
                context = Observability.BuilderContext()
                context._parent_builder = self
                context._field_name = "observability"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Observability.builder())
                if isinstance(output, Observability.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("observability", value)

        def priority(self, value: Optional[int], /) -> Self:
            """
            Priority defines the router's priority.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#priority
            """
            return self._set("priority", value)

        @overload
        def services(self, value_or_callback: List[Service], /) -> "Route.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Service, Service.Builder]],
                GenericListBuilder[Service, Service.Builder] | List[Service],
            ],
            /,
        ) -> "Route.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Service.Builder]: ...

        def services(self, value_or_callback=None, /):
            """
            Services defines the list of Service.
            It can contain any combination of TraefikService and/or reference to a Kubernetes Service.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Service.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Service.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

        def syntax(self, value: Optional[str], /) -> Self:
            """
            Syntax defines the router's rule syntax.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rulesyntax
            Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
            """
            return self._set("syntax", value)

    class BuilderContext(BuilderContextBase["Route.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Route.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Route."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Route", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Route.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    kind: Optional[Literal["Rule"]] = None
    """
    Kind defines the kind of the route.
    Rule is the only supported kind.
    If not defined, defaults to Rule.
    """
    match: str
    """
    Match defines the router's rule.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rule
    """
    middlewares: Optional[List[Middleware]] = None
    """
    Middlewares defines the list of references to Middleware resources.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-middleware
    """
    observability: Optional[Observability] = None
    """
    Observability defines the observability configuration for a router.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#observability
    """
    priority: Annotated[Optional[int], Field(le=9223372036854775000)] = None
    """
    Priority defines the router's priority.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#priority
    """
    services: Optional[List[Service]] = None
    """
    Services defines the list of Service.
    It can contain any combination of TraefikService and/or reference to a Kubernetes Service.
    """
    syntax: Optional[str] = None
    """
    Syntax defines the router's rule syntax.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rulesyntax
    Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
    """


class Domain(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Domain"]:
            return Domain

        def build(self) -> "Domain":
            return Domain(**self._attrs)

        def main(self, value: Optional[str], /) -> Self:
            """
            Main defines the main domain name.
            """
            return self._set("main", value)

        def sans(self, value: Optional[List[str]], /) -> Self:
            """
            SANs defines the subject alternative domain names.
            """
            return self._set("sans", value)

    class BuilderContext(BuilderContextBase["Domain.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Domain.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Domain."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Domain", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Domain.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    main: Optional[str] = None
    """
    Main defines the main domain name.
    """
    sans: Optional[List[str]] = None
    """
    SANs defines the subject alternative domain names.
    """


class Options(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Options"]:
            return Options

        def build(self) -> "Options":
            return Options(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced TLSOption.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsoption
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced TLSOption.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsoption
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Options.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Options.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Options."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Options", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Options.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced TLSOption.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsoption
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced TLSOption.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsoption
    """


class Store(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Store"]:
            return Store

        def build(self) -> "Store":
            return Store(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced TLSStore.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsstore
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced TLSStore.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsstore
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["Store.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Store.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Store."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Store", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Store.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced TLSStore.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsstore
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced TLSStore.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#kind-tlsstore
    """


class Tls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tls"]:
            return Tls

        def build(self) -> "Tls":
            return Tls(**self._attrs)

        def cert_resolver(self, value: Optional[str], /) -> Self:
            """
            CertResolver defines the name of the certificate resolver to use.
            Cert resolvers have to be configured in the static configuration.
            More info: https://doc.traefik.io/traefik/v3.4/https/acme/#certificate-resolvers
            """
            return self._set("cert_resolver", value)

        @overload
        def domains(self, value_or_callback: List[Domain], /) -> "Tls.Builder": ...

        @overload
        def domains(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Domain, Domain.Builder]],
                GenericListBuilder[Domain, Domain.Builder] | List[Domain],
            ],
            /,
        ) -> "Tls.Builder": ...

        @overload
        def domains(self, value_or_callback: Never = ...) -> ListBuilderContext[Domain.Builder]: ...

        def domains(self, value_or_callback=None, /):
            """
            Domains defines the list of domains that will be used to issue certificates.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#domains
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Domain.Builder]()
                context._parent_builder = self
                context._field_name = "domains"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains", value)

        @overload
        def options(self, value_or_callback: Optional[Options], /) -> "Tls.Builder": ...

        @overload
        def options(
            self,
            value_or_callback: Callable[[Options.Builder], Options.Builder | Options],
            /,
        ) -> "Tls.Builder": ...

        @overload
        def options(self, value_or_callback: Never = ...) -> "Options.BuilderContext": ...

        def options(self, value_or_callback=None, /):
            """
            Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
            If not defined, the `default` TLSOption is used.
            More info: https://doc.traefik.io/traefik/v3.4/https/tls/#tls-options
            """
            if self._in_context and value_or_callback is None:
                context = Options.BuilderContext()
                context._parent_builder = self
                context._field_name = "options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Options.builder())
                if isinstance(output, Options.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("options", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
            """
            return self._set("secret_name", value)

        @overload
        def store(self, value_or_callback: Optional[Store], /) -> "Tls.Builder": ...

        @overload
        def store(
            self, value_or_callback: Callable[[Store.Builder], Store.Builder | Store], /
        ) -> "Tls.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "Store.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            """
            Store defines the reference to the TLSStore, that will be used to store certificates.
            Please note that only `default` TLSStore can be used.
            """
            if self._in_context and value_or_callback is None:
                context = Store.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Store.builder())
                if isinstance(output, Store.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

    class BuilderContext(BuilderContextBase["Tls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert_resolver: Annotated[Optional[str], Field(alias="certResolver")] = None
    """
    CertResolver defines the name of the certificate resolver to use.
    Cert resolvers have to be configured in the static configuration.
    More info: https://doc.traefik.io/traefik/v3.4/https/acme/#certificate-resolvers
    """
    domains: Optional[List[Domain]] = None
    """
    Domains defines the list of domains that will be used to issue certificates.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#domains
    """
    options: Optional[Options] = None
    """
    Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
    If not defined, the `default` TLSOption is used.
    More info: https://doc.traefik.io/traefik/v3.4/https/tls/#tls-options
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
    """
    store: Optional[Store] = None
    """
    Store defines the reference to the TLSStore, that will be used to store certificates.
    Please note that only `default` TLSStore can be used.
    """


class IngressRouteSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRouteSpec"]:
            return IngressRouteSpec

        def build(self) -> "IngressRouteSpec":
            return IngressRouteSpec(**self._attrs)

        def entry_points(self, value: Optional[List[str]], /) -> Self:
            """
            EntryPoints defines the list of entry point names to bind to.
            Entry points have to be configured in the static configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
            Default: all.
            """
            return self._set("entry_points", value)

        @overload
        def routes(self, value_or_callback: List[Route], /) -> "IngressRouteSpec.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Route, Route.Builder]],
                GenericListBuilder[Route, Route.Builder] | List[Route],
            ],
            /,
        ) -> "IngressRouteSpec.Builder": ...

        @overload
        def routes(self, value_or_callback: Never = ...) -> ListBuilderContext[Route.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            Routes defines the list of routes.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Route.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Route.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "IngressRouteSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "IngressRouteSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS defines the TLS configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#tls
            """
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["IngressRouteSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRouteSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRouteSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRouteSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRouteSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    entry_points: Annotated[Optional[List[str]], Field(alias="entryPoints")] = None
    """
    EntryPoints defines the list of entry point names to bind to.
    Entry points have to be configured in the static configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
    Default: all.
    """
    routes: List[Route]
    """
    Routes defines the list of routes.
    """
    tls: Optional[Tls] = None
    """
    TLS defines the TLS configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#tls
    """


class MiddlewareModel(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareModel"]:
            return MiddlewareModel

        def build(self) -> "MiddlewareModel":
            return MiddlewareModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Traefik resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Traefik resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["MiddlewareModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Traefik resource.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Traefik resource.
    """


class ProxyProtocol(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxyProtocol"]:
            return ProxyProtocol

        def build(self) -> "ProxyProtocol":
            return ProxyProtocol(**self._attrs)

        def version(self, value: Optional[int], /) -> Self:
            """
            Version defines the PROXY Protocol version to use.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["ProxyProtocol.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxyProtocol.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxyProtocol."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxyProtocol", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxyProtocol.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    version: Annotated[Optional[int], Field(ge=1, le=2)] = None
    """
    Version defines the PROXY Protocol version to use.
    """


class ServiceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceModel"]:
            return ServiceModel

        def build(self) -> "ServiceModel":
            return ServiceModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        @overload
        def proxy_protocol(
            self, value_or_callback: Optional[ProxyProtocol], /
        ) -> "ServiceModel.Builder": ...

        @overload
        def proxy_protocol(
            self,
            value_or_callback: Callable[
                [ProxyProtocol.Builder], ProxyProtocol.Builder | ProxyProtocol
            ],
            /,
        ) -> "ServiceModel.Builder": ...

        @overload
        def proxy_protocol(
            self, value_or_callback: Never = ...
        ) -> "ProxyProtocol.BuilderContext": ...

        def proxy_protocol(self, value_or_callback=None, /):
            """
            ProxyProtocol defines the PROXY protocol configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/services/#proxy-protocol
            """
            if self._in_context and value_or_callback is None:
                context = ProxyProtocol.BuilderContext()
                context._parent_builder = self
                context._field_name = "proxy_protocol"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProxyProtocol.builder())
                if isinstance(output, ProxyProtocol.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("proxy_protocol", value)

        def servers_transport(self, value: Optional[str], /) -> Self:
            """
            ServersTransport defines the name of ServersTransportTCP resource to use.
            It allows to configure the transport between Traefik and your servers.
            Can only be used on a Kubernetes Service.
            """
            return self._set("servers_transport", value)

        def termination_delay(self, value: Optional[int], /) -> Self:
            """
            TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates
            it has closed the writing capability of its connection, to close the reading capability as well,
            hence fully terminating the connection.
            It is a duration in milliseconds, defaulting to 100.
            A negative value means an infinite deadline (i.e. the reading capability is never closed).
            Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.
            """
            return self._set("termination_delay", value)

        def tls(self, value: Optional[bool], /) -> Self:
            """
            TLS determines whether to use TLS when dialing with the backend.
            """
            return self._set("tls", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight used when balancing requests between multiple Kubernetes Service.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["ServiceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Kubernetes Service.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    port: Union[int, str]
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    proxy_protocol: Annotated[Optional[ProxyProtocol], Field(alias="proxyProtocol")] = None
    """
    ProxyProtocol defines the PROXY protocol configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/services/#proxy-protocol
    """
    servers_transport: Annotated[Optional[str], Field(alias="serversTransport")] = None
    """
    ServersTransport defines the name of ServersTransportTCP resource to use.
    It allows to configure the transport between Traefik and your servers.
    Can only be used on a Kubernetes Service.
    """
    termination_delay: Annotated[Optional[int], Field(alias="terminationDelay")] = None
    """
    TerminationDelay defines the deadline that the proxy sets, after one of its connected peers indicates
    it has closed the writing capability of its connection, to close the reading capability as well,
    hence fully terminating the connection.
    It is a duration in milliseconds, defaulting to 100.
    A negative value means an infinite deadline (i.e. the reading capability is never closed).
    Deprecated: TerminationDelay will not be supported in future APIVersions, please use ServersTransport to configure the TerminationDelay instead.
    """
    tls: Optional[bool] = None
    """
    TLS determines whether to use TLS when dialing with the backend.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight used when balancing requests between multiple Kubernetes Service.
    """


class RouteModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RouteModel"]:
            return RouteModel

        def build(self) -> "RouteModel":
            return RouteModel(**self._attrs)

        def match(self, value: str, /) -> Self:
            """
            Match defines the router's rule.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rule_1
            """
            return self._set("match", value)

        @overload
        def middlewares(
            self, value_or_callback: List[MiddlewareModel], /
        ) -> "RouteModel.Builder": ...

        @overload
        def middlewares(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MiddlewareModel, MiddlewareModel.Builder]],
                GenericListBuilder[MiddlewareModel, MiddlewareModel.Builder]
                | List[MiddlewareModel],
            ],
            /,
        ) -> "RouteModel.Builder": ...

        @overload
        def middlewares(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MiddlewareModel.Builder]: ...

        def middlewares(self, value_or_callback=None, /):
            """
            Middlewares defines the list of references to MiddlewareTCP resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MiddlewareModel.Builder]()
                context._parent_builder = self
                context._field_name = "middlewares"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MiddlewareModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("middlewares", value)

        def priority(self, value: Optional[int], /) -> Self:
            """
            Priority defines the router's priority.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#priority_1
            """
            return self._set("priority", value)

        @overload
        def services(self, value_or_callback: List[ServiceModel], /) -> "RouteModel.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ServiceModel, ServiceModel.Builder]],
                GenericListBuilder[ServiceModel, ServiceModel.Builder] | List[ServiceModel],
            ],
            /,
        ) -> "RouteModel.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ServiceModel.Builder]: ...

        def services(self, value_or_callback=None, /):
            """
            Services defines the list of TCP services.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ServiceModel.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

        def syntax(self, value: Optional[Literal["v3", "v2"]], /) -> Self:
            """
            Syntax defines the router's rule syntax.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rulesyntax_1
            Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
            """
            return self._set("syntax", value)

    class BuilderContext(BuilderContextBase["RouteModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RouteModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RouteModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RouteModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RouteModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match: str
    """
    Match defines the router's rule.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rule_1
    """
    middlewares: Optional[List[MiddlewareModel]] = None
    """
    Middlewares defines the list of references to MiddlewareTCP resources.
    """
    priority: Annotated[Optional[int], Field(le=9223372036854775000)] = None
    """
    Priority defines the router's priority.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#priority_1
    """
    services: Optional[List[ServiceModel]] = None
    """
    Services defines the list of TCP services.
    """
    syntax: Optional[Literal["v3", "v2"]] = None
    """
    Syntax defines the router's rule syntax.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#rulesyntax_1
    Deprecated: Please do not use this field and rewrite the router rules to use the v3 syntax.
    """


class OptionsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["OptionsModel"]:
            return OptionsModel

        def build(self) -> "OptionsModel":
            return OptionsModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Traefik resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Traefik resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["OptionsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = OptionsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for OptionsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["OptionsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use OptionsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Traefik resource.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Traefik resource.
    """


class StoreModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StoreModel"]:
            return StoreModel

        def build(self) -> "StoreModel":
            return StoreModel(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Traefik resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Traefik resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["StoreModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StoreModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StoreModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StoreModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StoreModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Traefik resource.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Traefik resource.
    """


class TlsModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsModel"]:
            return TlsModel

        def build(self) -> "TlsModel":
            return TlsModel(**self._attrs)

        def cert_resolver(self, value: Optional[str], /) -> Self:
            """
            CertResolver defines the name of the certificate resolver to use.
            Cert resolvers have to be configured in the static configuration.
            More info: https://doc.traefik.io/traefik/v3.4/https/acme/#certificate-resolvers
            """
            return self._set("cert_resolver", value)

        @overload
        def domains(self, value_or_callback: List[Domain], /) -> "TlsModel.Builder": ...

        @overload
        def domains(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Domain, Domain.Builder]],
                GenericListBuilder[Domain, Domain.Builder] | List[Domain],
            ],
            /,
        ) -> "TlsModel.Builder": ...

        @overload
        def domains(self, value_or_callback: Never = ...) -> ListBuilderContext[Domain.Builder]: ...

        def domains(self, value_or_callback=None, /):
            """
            Domains defines the list of domains that will be used to issue certificates.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#domains
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Domain.Builder]()
                context._parent_builder = self
                context._field_name = "domains"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("domains", value)

        @overload
        def options(self, value_or_callback: Optional[OptionsModel], /) -> "TlsModel.Builder": ...

        @overload
        def options(
            self,
            value_or_callback: Callable[
                [OptionsModel.Builder], OptionsModel.Builder | OptionsModel
            ],
            /,
        ) -> "TlsModel.Builder": ...

        @overload
        def options(self, value_or_callback: Never = ...) -> "OptionsModel.BuilderContext": ...

        def options(self, value_or_callback=None, /):
            """
            Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
            If not defined, the `default` TLSOption is used.
            More info: https://doc.traefik.io/traefik/v3.4/https/tls/#tls-options
            """
            if self._in_context and value_or_callback is None:
                context = OptionsModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(OptionsModel.builder())
                if isinstance(output, OptionsModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("options", value)

        def passthrough(self, value: Optional[bool], /) -> Self:
            """
            Passthrough defines whether a TLS router will terminate the TLS connection.
            """
            return self._set("passthrough", value)

        def secret_name(self, value: Optional[str], /) -> Self:
            """
            SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
            """
            return self._set("secret_name", value)

        @overload
        def store(self, value_or_callback: Optional[StoreModel], /) -> "TlsModel.Builder": ...

        @overload
        def store(
            self,
            value_or_callback: Callable[[StoreModel.Builder], StoreModel.Builder | StoreModel],
            /,
        ) -> "TlsModel.Builder": ...

        @overload
        def store(self, value_or_callback: Never = ...) -> "StoreModel.BuilderContext": ...

        def store(self, value_or_callback=None, /):
            """
            Store defines the reference to the TLSStore, that will be used to store certificates.
            Please note that only `default` TLSStore can be used.
            """
            if self._in_context and value_or_callback is None:
                context = StoreModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "store"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StoreModel.builder())
                if isinstance(output, StoreModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("store", value)

    class BuilderContext(BuilderContextBase["TlsModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    cert_resolver: Annotated[Optional[str], Field(alias="certResolver")] = None
    """
    CertResolver defines the name of the certificate resolver to use.
    Cert resolvers have to be configured in the static configuration.
    More info: https://doc.traefik.io/traefik/v3.4/https/acme/#certificate-resolvers
    """
    domains: Optional[List[Domain]] = None
    """
    Domains defines the list of domains that will be used to issue certificates.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#domains
    """
    options: Optional[OptionsModel] = None
    """
    Options defines the reference to a TLSOption, that specifies the parameters of the TLS connection.
    If not defined, the `default` TLSOption is used.
    More info: https://doc.traefik.io/traefik/v3.4/https/tls/#tls-options
    """
    passthrough: Optional[bool] = None
    """
    Passthrough defines whether a TLS router will terminate the TLS connection.
    """
    secret_name: Annotated[Optional[str], Field(alias="secretName")] = None
    """
    SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
    """
    store: Optional[StoreModel] = None
    """
    Store defines the reference to the TLSStore, that will be used to store certificates.
    Please note that only `default` TLSStore can be used.
    """


class IngressRouteTCPSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRouteTCPSpec"]:
            return IngressRouteTCPSpec

        def build(self) -> "IngressRouteTCPSpec":
            return IngressRouteTCPSpec(**self._attrs)

        def entry_points(self, value: Optional[List[str]], /) -> Self:
            """
            EntryPoints defines the list of entry point names to bind to.
            Entry points have to be configured in the static configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
            Default: all.
            """
            return self._set("entry_points", value)

        @overload
        def routes(
            self, value_or_callback: List[RouteModel], /
        ) -> "IngressRouteTCPSpec.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RouteModel, RouteModel.Builder]],
                GenericListBuilder[RouteModel, RouteModel.Builder] | List[RouteModel],
            ],
            /,
        ) -> "IngressRouteTCPSpec.Builder": ...

        @overload
        def routes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RouteModel.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            Routes defines the list of routes.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RouteModel.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

        @overload
        def tls(
            self, value_or_callback: Optional[TlsModel], /
        ) -> "IngressRouteTCPSpec.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel.Builder], TlsModel.Builder | TlsModel],
            /,
        ) -> "IngressRouteTCPSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS defines the TLS configuration on a layer 4 / TCP Route.
            More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#tls_1
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel.builder())
                if isinstance(output, TlsModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["IngressRouteTCPSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRouteTCPSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRouteTCPSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRouteTCPSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRouteTCPSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    entry_points: Annotated[Optional[List[str]], Field(alias="entryPoints")] = None
    """
    EntryPoints defines the list of entry point names to bind to.
    Entry points have to be configured in the static configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
    Default: all.
    """
    routes: List[RouteModel]
    """
    Routes defines the list of routes.
    """
    tls: Optional[TlsModel] = None
    """
    TLS defines the TLS configuration on a layer 4 / TCP Route.
    More info: https://doc.traefik.io/traefik/v3.4/routing/routers/#tls_1
    """


class ServiceModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceModel1"]:
            return ServiceModel1

        def build(self) -> "ServiceModel1":
            return ServiceModel1(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def port(self, value: Union[int, str], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight used when balancing requests between multiple Kubernetes Service.
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["ServiceModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Kubernetes Service.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    port: Union[int, str]
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight used when balancing requests between multiple Kubernetes Service.
    """


class RouteModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RouteModel1"]:
            return RouteModel1

        def build(self) -> "RouteModel1":
            return RouteModel1(**self._attrs)

        @overload
        def services(self, value_or_callback: List[ServiceModel1], /) -> "RouteModel1.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ServiceModel1, ServiceModel1.Builder]],
                GenericListBuilder[ServiceModel1, ServiceModel1.Builder] | List[ServiceModel1],
            ],
            /,
        ) -> "RouteModel1.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ServiceModel1.Builder]: ...

        def services(self, value_or_callback=None, /):
            """
            Services defines the list of UDP services.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ServiceModel1.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

    class BuilderContext(BuilderContextBase["RouteModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RouteModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RouteModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RouteModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RouteModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    services: Optional[List[ServiceModel1]] = None
    """
    Services defines the list of UDP services.
    """


class IngressRouteUDPSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRouteUDPSpec"]:
            return IngressRouteUDPSpec

        def build(self) -> "IngressRouteUDPSpec":
            return IngressRouteUDPSpec(**self._attrs)

        def entry_points(self, value: Optional[List[str]], /) -> Self:
            """
            EntryPoints defines the list of entry point names to bind to.
            Entry points have to be configured in the static configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
            Default: all.
            """
            return self._set("entry_points", value)

        @overload
        def routes(
            self, value_or_callback: List[RouteModel1], /
        ) -> "IngressRouteUDPSpec.Builder": ...

        @overload
        def routes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RouteModel1, RouteModel1.Builder]],
                GenericListBuilder[RouteModel1, RouteModel1.Builder] | List[RouteModel1],
            ],
            /,
        ) -> "IngressRouteUDPSpec.Builder": ...

        @overload
        def routes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RouteModel1.Builder]: ...

        def routes(self, value_or_callback=None, /):
            """
            Routes defines the list of routes.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RouteModel1.Builder]()
                context._parent_builder = self
                context._field_name = "routes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RouteModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("routes", value)

    class BuilderContext(BuilderContextBase["IngressRouteUDPSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRouteUDPSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRouteUDPSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRouteUDPSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRouteUDPSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    entry_points: Annotated[Optional[List[str]], Field(alias="entryPoints")] = None
    """
    EntryPoints defines the list of entry point names to bind to.
    Entry points have to be configured in the static configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/entrypoints/
    Default: all.
    """
    routes: List[RouteModel1]
    """
    Routes defines the list of routes.
    """


class AddPrefix(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AddPrefix"]:
            return AddPrefix

        def build(self) -> "AddPrefix":
            return AddPrefix(**self._attrs)

        def prefix(self, value: Optional[str], /) -> Self:
            """
            Prefix is the string to add before the current path in the requested URL.
            It should include a leading slash (/).
            """
            return self._set("prefix", value)

    class BuilderContext(BuilderContextBase["AddPrefix.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AddPrefix.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AddPrefix."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AddPrefix", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AddPrefix.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    prefix: Optional[str] = None
    """
    Prefix is the string to add before the current path in the requested URL.
    It should include a leading slash (/).
    """


class BasicAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["BasicAuth"]:
            return BasicAuth

        def build(self) -> "BasicAuth":
            return BasicAuth(**self._attrs)

        def header_field(self, value: Optional[str], /) -> Self:
            """
            HeaderField defines a header field to store the authenticated user.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
            """
            return self._set("header_field", value)

        def realm(self, value: Optional[str], /) -> Self:
            """
            Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
            Default: traefik.
            """
            return self._set("realm", value)

        def remove_header(self, value: Optional[bool], /) -> Self:
            """
            RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
            Default: false.
            """
            return self._set("remove_header", value)

        def secret(self, value: Optional[str], /) -> Self:
            """
            Secret is the name of the referenced Kubernetes Secret containing user credentials.
            """
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["BasicAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = BasicAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for BasicAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["BasicAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use BasicAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    header_field: Annotated[Optional[str], Field(alias="headerField")] = None
    """
    HeaderField defines a header field to store the authenticated user.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
    """
    realm: Optional[str] = None
    """
    Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
    Default: traefik.
    """
    remove_header: Annotated[Optional[bool], Field(alias="removeHeader")] = None
    """
    RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
    Default: false.
    """
    secret: Optional[str] = None
    """
    Secret is the name of the referenced Kubernetes Secret containing user credentials.
    """


class Buffering(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Buffering"]:
            return Buffering

        def build(self) -> "Buffering":
            return Buffering(**self._attrs)

        def max_request_body_bytes(self, value: Optional[int], /) -> Self:
            """
            MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
            If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
            Default: 0 (no maximum).
            """
            return self._set("max_request_body_bytes", value)

        def max_response_body_bytes(self, value: Optional[int], /) -> Self:
            """
            MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
            If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
            Default: 0 (no maximum).
            """
            return self._set("max_response_body_bytes", value)

        def mem_request_body_bytes(self, value: Optional[int], /) -> Self:
            """
            MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
            Default: 1048576 (1Mi).
            """
            return self._set("mem_request_body_bytes", value)

        def mem_response_body_bytes(self, value: Optional[int], /) -> Self:
            """
            MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
            Default: 1048576 (1Mi).
            """
            return self._set("mem_response_body_bytes", value)

        def retry_expression(self, value: Optional[str], /) -> Self:
            """
            RetryExpression defines the retry conditions.
            It is a logical combination of functions with operators AND (&&) and OR (||).
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#retryexpression
            """
            return self._set("retry_expression", value)

    class BuilderContext(BuilderContextBase["Buffering.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Buffering.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Buffering."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Buffering", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Buffering.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    max_request_body_bytes: Annotated[Optional[int], Field(alias="maxRequestBodyBytes")] = None
    """
    MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
    If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
    Default: 0 (no maximum).
    """
    max_response_body_bytes: Annotated[Optional[int], Field(alias="maxResponseBodyBytes")] = None
    """
    MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
    If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
    Default: 0 (no maximum).
    """
    mem_request_body_bytes: Annotated[Optional[int], Field(alias="memRequestBodyBytes")] = None
    """
    MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
    Default: 1048576 (1Mi).
    """
    mem_response_body_bytes: Annotated[Optional[int], Field(alias="memResponseBodyBytes")] = None
    """
    MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
    Default: 1048576 (1Mi).
    """
    retry_expression: Annotated[Optional[str], Field(alias="retryExpression")] = None
    """
    RetryExpression defines the retry conditions.
    It is a logical combination of functions with operators AND (&&) and OR (||).
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#retryexpression
    """


class MiddlewareModel1(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareModel1"]:
            return MiddlewareModel1

        def build(self) -> "MiddlewareModel1":
            return MiddlewareModel1(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Middleware resource.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Middleware resource.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["MiddlewareModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name defines the name of the referenced Middleware resource.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Middleware resource.
    """


class Chain(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Chain"]:
            return Chain

        def build(self) -> "Chain":
            return Chain(**self._attrs)

        @overload
        def middlewares(self, value_or_callback: List[MiddlewareModel1], /) -> "Chain.Builder": ...

        @overload
        def middlewares(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MiddlewareModel1, MiddlewareModel1.Builder]],
                GenericListBuilder[MiddlewareModel1, MiddlewareModel1.Builder]
                | List[MiddlewareModel1],
            ],
            /,
        ) -> "Chain.Builder": ...

        @overload
        def middlewares(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MiddlewareModel1.Builder]: ...

        def middlewares(self, value_or_callback=None, /):
            """
            Middlewares is the list of MiddlewareRef which composes the chain.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MiddlewareModel1.Builder]()
                context._parent_builder = self
                context._field_name = "middlewares"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MiddlewareModel1.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("middlewares", value)

    class BuilderContext(BuilderContextBase["Chain.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Chain.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Chain."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Chain", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Chain.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    middlewares: Optional[List[MiddlewareModel1]] = None
    """
    Middlewares is the list of MiddlewareRef which composes the chain.
    """


class CheckPeriod(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
            """
            self._value = value
            return self

        def build(self) -> "CheckPeriod":
            value = cast(int, self._value)
            return CheckPeriod(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
    """

    class BuilderContext(BuilderContextBase["CheckPeriod.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CheckPeriod.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CheckPeriod."""
        return cls.BuilderContext()


class CheckPeriodModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
            """
            self._value = value
            return self

        def build(self) -> "CheckPeriodModel":
            value = cast(str, self._value)
            return CheckPeriodModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
    """

    class BuilderContext(BuilderContextBase["CheckPeriodModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CheckPeriodModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CheckPeriodModel."""
        return cls.BuilderContext()


class RecoveryDuration(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
            """
            self._value = value
            return self

        def build(self) -> "RecoveryDuration":
            value = cast(int, self._value)
            return RecoveryDuration(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
    """

    class BuilderContext(BuilderContextBase["RecoveryDuration.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RecoveryDuration.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RecoveryDuration."""
        return cls.BuilderContext()


class RecoveryDurationModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
            """
            self._value = value
            return self

        def build(self) -> "RecoveryDurationModel":
            value = cast(str, self._value)
            return RecoveryDurationModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
    """

    class BuilderContext(BuilderContextBase["RecoveryDurationModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RecoveryDurationModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RecoveryDurationModel."""
        return cls.BuilderContext()


class CircuitBreaker(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CircuitBreaker"]:
            return CircuitBreaker

        def build(self) -> "CircuitBreaker":
            return CircuitBreaker(**self._attrs)

        def check_period(self, value: Optional[Union[CheckPeriod, CheckPeriodModel]], /) -> Self:
            """
            CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
            """
            return self._set("check_period", value)

        def expression(self, value: Optional[str], /) -> Self:
            """
            Expression is the condition that triggers the tripped state.
            """
            return self._set("expression", value)

        def fallback_duration(self, value: Optional[Union[int, str]], /) -> Self:
            """
            FallbackDuration is the duration for which the circuit breaker will wait before trying to recover (from a tripped state).
            """
            return self._set("fallback_duration", value)

        def recovery_duration(
            self, value: Optional[Union[RecoveryDuration, RecoveryDurationModel]], /
        ) -> Self:
            """
            RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
            """
            return self._set("recovery_duration", value)

        def response_code(self, value: Optional[int], /) -> Self:
            """
            ResponseCode is the status code that the circuit breaker will return while it is in the open state.
            """
            return self._set("response_code", value)

    class BuilderContext(BuilderContextBase["CircuitBreaker.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CircuitBreaker.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CircuitBreaker."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CircuitBreaker", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CircuitBreaker.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    check_period: Annotated[
        Optional[Union[CheckPeriod, CheckPeriodModel]], Field(alias="checkPeriod")
    ] = None
    """
    CheckPeriod is the interval between successive checks of the circuit breaker condition (when in standby state).
    """
    expression: Optional[str] = None
    """
    Expression is the condition that triggers the tripped state.
    """
    fallback_duration: Annotated[Optional[Union[int, str]], Field(alias="fallbackDuration")] = None
    """
    FallbackDuration is the duration for which the circuit breaker will wait before trying to recover (from a tripped state).
    """
    recovery_duration: Annotated[
        Optional[Union[RecoveryDuration, RecoveryDurationModel]],
        Field(alias="recoveryDuration"),
    ] = None
    """
    RecoveryDuration is the duration for which the circuit breaker will try to recover (as soon as it is in recovering state).
    """
    response_code: Annotated[Optional[int], Field(alias="responseCode", ge=100, le=599)] = None
    """
    ResponseCode is the status code that the circuit breaker will return while it is in the open state.
    """


class Compress(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Compress"]:
            return Compress

        def build(self) -> "Compress":
            return Compress(**self._attrs)

        def default_encoding(self, value: Optional[str], /) -> Self:
            """
            DefaultEncoding specifies the default encoding if the `Accept-Encoding` header is not in the request or contains a wildcard (`*`).
            """
            return self._set("default_encoding", value)

        def encodings(self, value: Optional[List[str]], /) -> Self:
            """
            Encodings defines the list of supported compression algorithms.
            """
            return self._set("encodings", value)

        def excluded_content_types(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
            `application/grpc` is always excluded.
            """
            return self._set("excluded_content_types", value)

        def included_content_types(self, value: Optional[List[str]], /) -> Self:
            """
            IncludedContentTypes defines the list of content types to compare the Content-Type header of the responses before compressing.
            """
            return self._set("included_content_types", value)

        def min_response_body_bytes(self, value: Optional[int], /) -> Self:
            """
            MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
            Default: 1024.
            """
            return self._set("min_response_body_bytes", value)

    class BuilderContext(BuilderContextBase["Compress.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Compress.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Compress."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Compress", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Compress.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_encoding: Annotated[Optional[str], Field(alias="defaultEncoding")] = None
    """
    DefaultEncoding specifies the default encoding if the `Accept-Encoding` header is not in the request or contains a wildcard (`*`).
    """
    encodings: Optional[List[str]] = None
    """
    Encodings defines the list of supported compression algorithms.
    """
    excluded_content_types: Annotated[Optional[List[str]], Field(alias="excludedContentTypes")] = (
        None
    )
    """
    ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
    `application/grpc` is always excluded.
    """
    included_content_types: Annotated[Optional[List[str]], Field(alias="includedContentTypes")] = (
        None
    )
    """
    IncludedContentTypes defines the list of content types to compare the Content-Type header of the responses before compressing.
    """
    min_response_body_bytes: Annotated[Optional[int], Field(alias="minResponseBodyBytes", ge=0)] = (
        None
    )
    """
    MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
    Default: 1024.
    """


class ContentType(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ContentType"]:
            return ContentType

        def build(self) -> "ContentType":
            return ContentType(**self._attrs)

        def auto_detect(self, value: Optional[bool], /) -> Self:
            """
            AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
            be automatically set to a value derived from the contents of the response.
            Deprecated: AutoDetect option is deprecated, Content-Type middleware is only meant to be used to enable the content-type detection, please remove any usage of this option.
            """
            return self._set("auto_detect", value)

    class BuilderContext(BuilderContextBase["ContentType.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ContentType.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ContentType."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ContentType", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ContentType.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auto_detect: Annotated[Optional[bool], Field(alias="autoDetect")] = None
    """
    AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
    be automatically set to a value derived from the contents of the response.
    Deprecated: AutoDetect option is deprecated, Content-Type middleware is only meant to be used to enable the content-type detection, please remove any usage of this option.
    """


class DigestAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DigestAuth"]:
            return DigestAuth

        def build(self) -> "DigestAuth":
            return DigestAuth(**self._attrs)

        def header_field(self, value: Optional[str], /) -> Self:
            """
            HeaderField defines a header field to store the authenticated user.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
            """
            return self._set("header_field", value)

        def realm(self, value: Optional[str], /) -> Self:
            """
            Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
            Default: traefik.
            """
            return self._set("realm", value)

        def remove_header(self, value: Optional[bool], /) -> Self:
            """
            RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
            """
            return self._set("remove_header", value)

        def secret(self, value: Optional[str], /) -> Self:
            """
            Secret is the name of the referenced Kubernetes Secret containing user credentials.
            """
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["DigestAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DigestAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DigestAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DigestAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DigestAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    header_field: Annotated[Optional[str], Field(alias="headerField")] = None
    """
    HeaderField defines a header field to store the authenticated user.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/#headerfield
    """
    realm: Optional[str] = None
    """
    Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
    Default: traefik.
    """
    remove_header: Annotated[Optional[bool], Field(alias="removeHeader")] = None
    """
    RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
    """
    secret: Optional[str] = None
    """
    Secret is the name of the referenced Kubernetes Secret containing user credentials.
    """


class ServiceModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceModel2"]:
            return ServiceModel2

        def build(self) -> "ServiceModel2":
            return ServiceModel2(**self._attrs)

        @overload
        def health_check(
            self, value_or_callback: Optional[HealthCheck], /
        ) -> "ServiceModel2.Builder": ...

        @overload
        def health_check(
            self,
            value_or_callback: Callable[[HealthCheck.Builder], HealthCheck.Builder | HealthCheck],
            /,
        ) -> "ServiceModel2.Builder": ...

        @overload
        def health_check(self, value_or_callback: Never = ...) -> "HealthCheck.BuilderContext": ...

        def health_check(self, value_or_callback=None, /):
            """
            Healthcheck defines health checks for ExternalName services.
            """
            if self._in_context and value_or_callback is None:
                context = HealthCheck.BuilderContext()
                context._parent_builder = self
                context._field_name = "health_check"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.builder())
                if isinstance(output, HealthCheck.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_check", value)

        def kind(self, value: Optional[Literal["Service", "TraefikService"]], /) -> Self:
            """
            Kind defines the kind of the Service.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service or TraefikService.
            The differentiation between the two is specified in the Kind field.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def pass_host_header(self, value: Optional[bool], /) -> Self:
            """
            PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
            By default, passHostHeader is true.
            """
            return self._set("pass_host_header", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        @overload
        def response_forwarding(
            self, value_or_callback: Optional[ResponseForwarding], /
        ) -> "ServiceModel2.Builder": ...

        @overload
        def response_forwarding(
            self,
            value_or_callback: Callable[
                [ResponseForwarding.Builder],
                ResponseForwarding.Builder | ResponseForwarding,
            ],
            /,
        ) -> "ServiceModel2.Builder": ...

        @overload
        def response_forwarding(
            self, value_or_callback: Never = ...
        ) -> "ResponseForwarding.BuilderContext": ...

        def response_forwarding(self, value_or_callback=None, /):
            """
            ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
            """
            if self._in_context and value_or_callback is None:
                context = ResponseForwarding.BuilderContext()
                context._parent_builder = self
                context._field_name = "response_forwarding"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResponseForwarding.builder())
                if isinstance(output, ResponseForwarding.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response_forwarding", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
            It defaults to https when Kubernetes Service port is 443, http otherwise.
            """
            return self._set("scheme", value)

        def servers_transport(self, value: Optional[str], /) -> Self:
            """
            ServersTransport defines the name of ServersTransport resource to use.
            It allows to configure the transport between Traefik and your servers.
            Can only be used on a Kubernetes Service.
            """
            return self._set("servers_transport", value)

        @overload
        def sticky(self, value_or_callback: Optional[Sticky], /) -> "ServiceModel2.Builder": ...

        @overload
        def sticky(
            self,
            value_or_callback: Callable[[Sticky.Builder], Sticky.Builder | Sticky],
            /,
        ) -> "ServiceModel2.Builder": ...

        @overload
        def sticky(self, value_or_callback: Never = ...) -> "Sticky.BuilderContext": ...

        def sticky(self, value_or_callback=None, /):
            """
            Sticky defines the sticky sessions configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
            """
            if self._in_context and value_or_callback is None:
                context = Sticky.BuilderContext()
                context._parent_builder = self
                context._field_name = "sticky"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sticky.builder())
                if isinstance(output, Sticky.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky", value)

        def strategy(self, value: Optional[Literal["wrr", "p2c", "RoundRobin"]], /) -> Self:
            """
            Strategy defines the load balancing strategy between the servers.
            Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
            RoundRobin value is deprecated and supported for backward compatibility.
            """
            return self._set("strategy", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight and should only be specified when Name references a TraefikService object
            (and to be precise, one that embeds a Weighted Round Robin).
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["ServiceModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    health_check: Annotated[Optional[HealthCheck], Field(alias="healthCheck")] = None
    """
    Healthcheck defines health checks for ExternalName services.
    """
    kind: Optional[Literal["Service", "TraefikService"]] = None
    """
    Kind defines the kind of the Service.
    """
    name: str
    """
    Name defines the name of the referenced Kubernetes Service or TraefikService.
    The differentiation between the two is specified in the Kind field.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    pass_host_header: Annotated[Optional[bool], Field(alias="passHostHeader")] = None
    """
    PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
    By default, passHostHeader is true.
    """
    port: Optional[Union[int, str]] = None
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    response_forwarding: Annotated[
        Optional[ResponseForwarding], Field(alias="responseForwarding")
    ] = None
    """
    ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
    """
    scheme: Optional[str] = None
    """
    Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
    It defaults to https when Kubernetes Service port is 443, http otherwise.
    """
    servers_transport: Annotated[Optional[str], Field(alias="serversTransport")] = None
    """
    ServersTransport defines the name of ServersTransport resource to use.
    It allows to configure the transport between Traefik and your servers.
    Can only be used on a Kubernetes Service.
    """
    sticky: Optional[Sticky] = None
    """
    Sticky defines the sticky sessions configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
    """
    strategy: Optional[Literal["wrr", "p2c", "RoundRobin"]] = None
    """
    Strategy defines the load balancing strategy between the servers.
    Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
    RoundRobin value is deprecated and supported for backward compatibility.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight and should only be specified when Name references a TraefikService object
    (and to be precise, one that embeds a Weighted Round Robin).
    """


class Status(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            self._value = value
            return self

        def build(self) -> "Status":
            value = cast(str, self._value)
            return Status(value)

    root: Annotated[str, Field(pattern="^([1-5][0-9]{2}[,-]?)+$")]

    class BuilderContext(BuilderContextBase["Status.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Status.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Status."""
        return cls.BuilderContext()


class Errors(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Errors"]:
            return Errors

        def build(self) -> "Errors":
            return Errors(**self._attrs)

        def query(self, value: Optional[str], /) -> Self:
            """
            Query defines the URL for the error page (hosted by service).
            The {status} variable can be used in order to insert the status code in the URL.
            The {originalStatus} variable can be used in order to insert the upstream status code in the URL.
            The {url} variable can be used in order to insert the escaped request URL.
            """
            return self._set("query", value)

        @overload
        def service(self, value_or_callback: Optional[ServiceModel2], /) -> "Errors.Builder": ...

        @overload
        def service(
            self,
            value_or_callback: Callable[
                [ServiceModel2.Builder], ServiceModel2.Builder | ServiceModel2
            ],
            /,
        ) -> "Errors.Builder": ...

        @overload
        def service(self, value_or_callback: Never = ...) -> "ServiceModel2.BuilderContext": ...

        def service(self, value_or_callback=None, /):
            """
            Service defines the reference to a Kubernetes Service that will serve the error page.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/errorpages/#service
            """
            if self._in_context and value_or_callback is None:
                context = ServiceModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "service"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceModel2.builder())
                if isinstance(output, ServiceModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service", value)

        @overload
        def status(self, value_or_callback: List[Status], /) -> "Errors.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Status, Status.Builder]],
                GenericListBuilder[Status, Status.Builder] | List[Status],
            ],
            /,
        ) -> "Errors.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> ListBuilderContext[Status.Builder]: ...

        def status(self, value_or_callback=None, /):
            """
            Status defines which status or range of statuses should result in an error page.
            It can be either a status code as a number (500),
            as multiple comma-separated numbers (500,502),
            as ranges by separating two codes with a dash (500-599),
            or a combination of the two (404,418,500-599).
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Status.Builder]()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Status.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

        def status_rewrites(self, value: Optional[Dict[str, int]], /) -> Self:
            """
            StatusRewrites defines a mapping of status codes that should be returned instead of the original error status codes.
            For example: "418": 404 or "410-418": 404
            """
            return self._set("status_rewrites", value)

    class BuilderContext(BuilderContextBase["Errors.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Errors.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Errors."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Errors", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Errors.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    query: Optional[str] = None
    """
    Query defines the URL for the error page (hosted by service).
    The {status} variable can be used in order to insert the status code in the URL.
    The {originalStatus} variable can be used in order to insert the upstream status code in the URL.
    The {url} variable can be used in order to insert the escaped request URL.
    """
    service: Optional[ServiceModel2] = None
    """
    Service defines the reference to a Kubernetes Service that will serve the error page.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/errorpages/#service
    """
    status: Optional[List[Status]] = None
    """
    Status defines which status or range of statuses should result in an error page.
    It can be either a status code as a number (500),
    as multiple comma-separated numbers (500,502),
    as ranges by separating two codes with a dash (500-599),
    or a combination of the two (404,418,500-599).
    """
    status_rewrites: Annotated[Optional[Dict[str, int]], Field(alias="statusRewrites")] = None
    """
    StatusRewrites defines a mapping of status codes that should be returned instead of the original error status codes.
    For example: "418": 404 or "410-418": 404
    """


class TlsModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsModel1"]:
            return TlsModel1

        def build(self) -> "TlsModel1":
            return TlsModel1(**self._attrs)

        def ca_optional(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: TLS client authentication is a server side option (see https://github.com/golang/go/blob/740a490f71d026bb7d2d13cb8fa2d6d6e0572b70/src/crypto/tls/common.go#L634).
            """
            return self._set("ca_optional", value)

        def ca_secret(self, value: Optional[str], /) -> Self:
            """
            CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
            The CA certificate is extracted from key `tls.ca` or `ca.crt`.
            """
            return self._set("ca_secret", value)

        def cert_secret(self, value: Optional[str], /) -> Self:
            """
            CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
            The client certificate is extracted from the keys `tls.crt` and `tls.key`.
            """
            return self._set("cert_secret", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            InsecureSkipVerify defines whether the server certificates should be validated.
            """
            return self._set("insecure_skip_verify", value)

    class BuilderContext(BuilderContextBase["TlsModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_optional: Annotated[Optional[bool], Field(alias="caOptional")] = None
    """
    Deprecated: TLS client authentication is a server side option (see https://github.com/golang/go/blob/740a490f71d026bb7d2d13cb8fa2d6d6e0572b70/src/crypto/tls/common.go#L634).
    """
    ca_secret: Annotated[Optional[str], Field(alias="caSecret")] = None
    """
    CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
    The CA certificate is extracted from key `tls.ca` or `ca.crt`.
    """
    cert_secret: Annotated[Optional[str], Field(alias="certSecret")] = None
    """
    CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
    The client certificate is extracted from the keys `tls.crt` and `tls.key`.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    InsecureSkipVerify defines whether the server certificates should be validated.
    """


class ForwardAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForwardAuth"]:
            return ForwardAuth

        def build(self) -> "ForwardAuth":
            return ForwardAuth(**self._attrs)

        def add_auth_cookies_to_response(self, value: Optional[List[str]], /) -> Self:
            """
            AddAuthCookiesToResponse defines the list of cookies to copy from the authentication server response to the response.
            """
            return self._set("add_auth_cookies_to_response", value)

        def address(self, value: Optional[str], /) -> Self:
            """
            Address defines the authentication server address.
            """
            return self._set("address", value)

        def auth_request_headers(self, value: Optional[List[str]], /) -> Self:
            """
            AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
            If not set or empty then all request headers are passed.
            """
            return self._set("auth_request_headers", value)

        def auth_response_headers(self, value: Optional[List[str]], /) -> Self:
            """
            AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
            """
            return self._set("auth_response_headers", value)

        def auth_response_headers_regex(self, value: Optional[str], /) -> Self:
            """
            AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#authresponseheadersregex
            """
            return self._set("auth_response_headers_regex", value)

        def forward_body(self, value: Optional[bool], /) -> Self:
            """
            ForwardBody defines whether to send the request body to the authentication server.
            """
            return self._set("forward_body", value)

        def header_field(self, value: Optional[str], /) -> Self:
            """
            HeaderField defines a header field to store the authenticated user.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#headerfield
            """
            return self._set("header_field", value)

        def max_body_size(self, value: Optional[int], /) -> Self:
            """
            MaxBodySize defines the maximum body size in bytes allowed to be forwarded to the authentication server.
            """
            return self._set("max_body_size", value)

        def preserve_location_header(self, value: Optional[bool], /) -> Self:
            """
            PreserveLocationHeader defines whether to forward the Location header to the client as is or prefix it with the domain name of the authentication server.
            """
            return self._set("preserve_location_header", value)

        def preserve_request_method(self, value: Optional[bool], /) -> Self:
            """
            PreserveRequestMethod defines whether to preserve the original request method while forwarding the request to the authentication server.
            """
            return self._set("preserve_request_method", value)

        @overload
        def tls(self, value_or_callback: Optional[TlsModel1], /) -> "ForwardAuth.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel1.Builder], TlsModel1.Builder | TlsModel1],
            /,
        ) -> "ForwardAuth.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel1.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS defines the configuration used to secure the connection to the authentication server.
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel1.builder())
                if isinstance(output, TlsModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        def trust_forward_header(self, value: Optional[bool], /) -> Self:
            """
            TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
            """
            return self._set("trust_forward_header", value)

    class BuilderContext(BuilderContextBase["ForwardAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForwardAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForwardAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForwardAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForwardAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add_auth_cookies_to_response: Annotated[
        Optional[List[str]], Field(alias="addAuthCookiesToResponse")
    ] = None
    """
    AddAuthCookiesToResponse defines the list of cookies to copy from the authentication server response to the response.
    """
    address: Optional[str] = None
    """
    Address defines the authentication server address.
    """
    auth_request_headers: Annotated[Optional[List[str]], Field(alias="authRequestHeaders")] = None
    """
    AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
    If not set or empty then all request headers are passed.
    """
    auth_response_headers: Annotated[Optional[List[str]], Field(alias="authResponseHeaders")] = None
    """
    AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
    """
    auth_response_headers_regex: Annotated[
        Optional[str], Field(alias="authResponseHeadersRegex")
    ] = None
    """
    AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#authresponseheadersregex
    """
    forward_body: Annotated[Optional[bool], Field(alias="forwardBody")] = None
    """
    ForwardBody defines whether to send the request body to the authentication server.
    """
    header_field: Annotated[Optional[str], Field(alias="headerField")] = None
    """
    HeaderField defines a header field to store the authenticated user.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/#headerfield
    """
    max_body_size: Annotated[Optional[int], Field(alias="maxBodySize")] = None
    """
    MaxBodySize defines the maximum body size in bytes allowed to be forwarded to the authentication server.
    """
    preserve_location_header: Annotated[Optional[bool], Field(alias="preserveLocationHeader")] = (
        None
    )
    """
    PreserveLocationHeader defines whether to forward the Location header to the client as is or prefix it with the domain name of the authentication server.
    """
    preserve_request_method: Annotated[Optional[bool], Field(alias="preserveRequestMethod")] = None
    """
    PreserveRequestMethod defines whether to preserve the original request method while forwarding the request to the authentication server.
    """
    tls: Optional[TlsModel1] = None
    """
    TLS defines the configuration used to secure the connection to the authentication server.
    """
    trust_forward_header: Annotated[Optional[bool], Field(alias="trustForwardHeader")] = None
    """
    TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
    """


class GrpcWeb(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GrpcWeb"]:
            return GrpcWeb

        def build(self) -> "GrpcWeb":
            return GrpcWeb(**self._attrs)

        def allow_origins(self, value: Optional[List[str]], /) -> Self:
            """
            AllowOrigins is a list of allowable origins.
            Can also be a wildcard origin "*".
            """
            return self._set("allow_origins", value)

    class BuilderContext(BuilderContextBase["GrpcWeb.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GrpcWeb.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GrpcWeb."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GrpcWeb", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GrpcWeb.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allow_origins: Annotated[Optional[List[str]], Field(alias="allowOrigins")] = None
    """
    AllowOrigins is a list of allowable origins.
    Can also be a wildcard origin "*".
    """


class Headers(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Headers"]:
            return Headers

        def build(self) -> "Headers":
            return Headers(**self._attrs)

        def access_control_allow_credentials(self, value: Optional[bool], /) -> Self:
            """
            AccessControlAllowCredentials defines whether the request can include user credentials.
            """
            return self._set("access_control_allow_credentials", value)

        def access_control_allow_headers(self, value: Optional[List[str]], /) -> Self:
            """
            AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
            """
            return self._set("access_control_allow_headers", value)

        def access_control_allow_methods(self, value: Optional[List[str]], /) -> Self:
            """
            AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
            """
            return self._set("access_control_allow_methods", value)

        def access_control_allow_origin_list(self, value: Optional[List[str]], /) -> Self:
            """
            AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
            """
            return self._set("access_control_allow_origin_list", value)

        def access_control_allow_origin_list_regex(self, value: Optional[List[str]], /) -> Self:
            """
            AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
            """
            return self._set("access_control_allow_origin_list_regex", value)

        def access_control_expose_headers(self, value: Optional[List[str]], /) -> Self:
            """
            AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
            """
            return self._set("access_control_expose_headers", value)

        def access_control_max_age(self, value: Optional[int], /) -> Self:
            """
            AccessControlMaxAge defines the time that a preflight request may be cached.
            """
            return self._set("access_control_max_age", value)

        def add_vary_header(self, value: Optional[bool], /) -> Self:
            """
            AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
            """
            return self._set("add_vary_header", value)

        def allowed_hosts(self, value: Optional[List[str]], /) -> Self:
            """
            AllowedHosts defines the fully qualified list of allowed domain names.
            """
            return self._set("allowed_hosts", value)

        def browser_xss_filter(self, value: Optional[bool], /) -> Self:
            """
            BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
            """
            return self._set("browser_xss_filter", value)

        def content_security_policy(self, value: Optional[str], /) -> Self:
            """
            ContentSecurityPolicy defines the Content-Security-Policy header value.
            """
            return self._set("content_security_policy", value)

        def content_security_policy_report_only(self, value: Optional[str], /) -> Self:
            """
            ContentSecurityPolicyReportOnly defines the Content-Security-Policy-Report-Only header value.
            """
            return self._set("content_security_policy_report_only", value)

        def content_type_nosniff(self, value: Optional[bool], /) -> Self:
            """
            ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
            """
            return self._set("content_type_nosniff", value)

        def custom_browser_xss_value(self, value: Optional[str], /) -> Self:
            """
            CustomBrowserXSSValue defines the X-XSS-Protection header value.
            This overrides the BrowserXssFilter option.
            """
            return self._set("custom_browser_xss_value", value)

        def custom_frame_options_value(self, value: Optional[str], /) -> Self:
            """
            CustomFrameOptionsValue defines the X-Frame-Options header value.
            This overrides the FrameDeny option.
            """
            return self._set("custom_frame_options_value", value)

        def custom_request_headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            CustomRequestHeaders defines the header names and values to apply to the request.
            """
            return self._set("custom_request_headers", value)

        def custom_response_headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            CustomResponseHeaders defines the header names and values to apply to the response.
            """
            return self._set("custom_response_headers", value)

        def feature_policy(self, value: Optional[str], /) -> Self:
            """
            Deprecated: FeaturePolicy option is deprecated, please use PermissionsPolicy instead.
            """
            return self._set("feature_policy", value)

        def force_sts_header(self, value: Optional[bool], /) -> Self:
            """
            ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
            """
            return self._set("force_sts_header", value)

        def frame_deny(self, value: Optional[bool], /) -> Self:
            """
            FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
            """
            return self._set("frame_deny", value)

        def hosts_proxy_headers(self, value: Optional[List[str]], /) -> Self:
            """
            HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
            """
            return self._set("hosts_proxy_headers", value)

        def is_development(self, value: Optional[bool], /) -> Self:
            """
            IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
            Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
            If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
            and STS headers, leave this as false.
            """
            return self._set("is_development", value)

        def permissions_policy(self, value: Optional[str], /) -> Self:
            """
            PermissionsPolicy defines the Permissions-Policy header value.
            This allows sites to control browser features.
            """
            return self._set("permissions_policy", value)

        def public_key(self, value: Optional[str], /) -> Self:
            """
            PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
            """
            return self._set("public_key", value)

        def referrer_policy(self, value: Optional[str], /) -> Self:
            """
            ReferrerPolicy defines the Referrer-Policy header value.
            This allows sites to control whether browsers forward the Referer header to other sites.
            """
            return self._set("referrer_policy", value)

        def ssl_force_host(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: SSLForceHost option is deprecated, please use RedirectRegex instead.
            """
            return self._set("ssl_force_host", value)

        def ssl_host(self, value: Optional[str], /) -> Self:
            """
            Deprecated: SSLHost option is deprecated, please use RedirectRegex instead.
            """
            return self._set("ssl_host", value)

        def ssl_proxy_headers(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
            It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
            """
            return self._set("ssl_proxy_headers", value)

        def ssl_redirect(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: SSLRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
            """
            return self._set("ssl_redirect", value)

        def ssl_temporary_redirect(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: SSLTemporaryRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
            """
            return self._set("ssl_temporary_redirect", value)

        def sts_include_subdomains(self, value: Optional[bool], /) -> Self:
            """
            STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
            """
            return self._set("sts_include_subdomains", value)

        def sts_preload(self, value: Optional[bool], /) -> Self:
            """
            STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
            """
            return self._set("sts_preload", value)

        def sts_seconds(self, value: Optional[int], /) -> Self:
            """
            STSSeconds defines the max-age of the Strict-Transport-Security header.
            If set to 0, the header is not set.
            """
            return self._set("sts_seconds", value)

    class BuilderContext(BuilderContextBase["Headers.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Headers.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Headers."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Headers", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Headers.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    access_control_allow_credentials: Annotated[
        Optional[bool], Field(alias="accessControlAllowCredentials")
    ] = None
    """
    AccessControlAllowCredentials defines whether the request can include user credentials.
    """
    access_control_allow_headers: Annotated[
        Optional[List[str]], Field(alias="accessControlAllowHeaders")
    ] = None
    """
    AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
    """
    access_control_allow_methods: Annotated[
        Optional[List[str]], Field(alias="accessControlAllowMethods")
    ] = None
    """
    AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
    """
    access_control_allow_origin_list: Annotated[
        Optional[List[str]], Field(alias="accessControlAllowOriginList")
    ] = None
    """
    AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
    """
    access_control_allow_origin_list_regex: Annotated[
        Optional[List[str]], Field(alias="accessControlAllowOriginListRegex")
    ] = None
    """
    AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
    """
    access_control_expose_headers: Annotated[
        Optional[List[str]], Field(alias="accessControlExposeHeaders")
    ] = None
    """
    AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
    """
    access_control_max_age: Annotated[Optional[int], Field(alias="accessControlMaxAge")] = None
    """
    AccessControlMaxAge defines the time that a preflight request may be cached.
    """
    add_vary_header: Annotated[Optional[bool], Field(alias="addVaryHeader")] = None
    """
    AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
    """
    allowed_hosts: Annotated[Optional[List[str]], Field(alias="allowedHosts")] = None
    """
    AllowedHosts defines the fully qualified list of allowed domain names.
    """
    browser_xss_filter: Annotated[Optional[bool], Field(alias="browserXssFilter")] = None
    """
    BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
    """
    content_security_policy: Annotated[Optional[str], Field(alias="contentSecurityPolicy")] = None
    """
    ContentSecurityPolicy defines the Content-Security-Policy header value.
    """
    content_security_policy_report_only: Annotated[
        Optional[str], Field(alias="contentSecurityPolicyReportOnly")
    ] = None
    """
    ContentSecurityPolicyReportOnly defines the Content-Security-Policy-Report-Only header value.
    """
    content_type_nosniff: Annotated[Optional[bool], Field(alias="contentTypeNosniff")] = None
    """
    ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
    """
    custom_browser_xss_value: Annotated[Optional[str], Field(alias="customBrowserXSSValue")] = None
    """
    CustomBrowserXSSValue defines the X-XSS-Protection header value.
    This overrides the BrowserXssFilter option.
    """
    custom_frame_options_value: Annotated[Optional[str], Field(alias="customFrameOptionsValue")] = (
        None
    )
    """
    CustomFrameOptionsValue defines the X-Frame-Options header value.
    This overrides the FrameDeny option.
    """
    custom_request_headers: Annotated[
        Optional[Dict[str, str]], Field(alias="customRequestHeaders")
    ] = None
    """
    CustomRequestHeaders defines the header names and values to apply to the request.
    """
    custom_response_headers: Annotated[
        Optional[Dict[str, str]], Field(alias="customResponseHeaders")
    ] = None
    """
    CustomResponseHeaders defines the header names and values to apply to the response.
    """
    feature_policy: Annotated[Optional[str], Field(alias="featurePolicy")] = None
    """
    Deprecated: FeaturePolicy option is deprecated, please use PermissionsPolicy instead.
    """
    force_sts_header: Annotated[Optional[bool], Field(alias="forceSTSHeader")] = None
    """
    ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
    """
    frame_deny: Annotated[Optional[bool], Field(alias="frameDeny")] = None
    """
    FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
    """
    hosts_proxy_headers: Annotated[Optional[List[str]], Field(alias="hostsProxyHeaders")] = None
    """
    HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
    """
    is_development: Annotated[Optional[bool], Field(alias="isDevelopment")] = None
    """
    IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
    Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
    If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
    and STS headers, leave this as false.
    """
    permissions_policy: Annotated[Optional[str], Field(alias="permissionsPolicy")] = None
    """
    PermissionsPolicy defines the Permissions-Policy header value.
    This allows sites to control browser features.
    """
    public_key: Annotated[Optional[str], Field(alias="publicKey")] = None
    """
    PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
    """
    referrer_policy: Annotated[Optional[str], Field(alias="referrerPolicy")] = None
    """
    ReferrerPolicy defines the Referrer-Policy header value.
    This allows sites to control whether browsers forward the Referer header to other sites.
    """
    ssl_force_host: Annotated[Optional[bool], Field(alias="sslForceHost")] = None
    """
    Deprecated: SSLForceHost option is deprecated, please use RedirectRegex instead.
    """
    ssl_host: Annotated[Optional[str], Field(alias="sslHost")] = None
    """
    Deprecated: SSLHost option is deprecated, please use RedirectRegex instead.
    """
    ssl_proxy_headers: Annotated[Optional[Dict[str, str]], Field(alias="sslProxyHeaders")] = None
    """
    SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
    It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
    """
    ssl_redirect: Annotated[Optional[bool], Field(alias="sslRedirect")] = None
    """
    Deprecated: SSLRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
    """
    ssl_temporary_redirect: Annotated[Optional[bool], Field(alias="sslTemporaryRedirect")] = None
    """
    Deprecated: SSLTemporaryRedirect option is deprecated, please use EntryPoint redirection or RedirectScheme instead.
    """
    sts_include_subdomains: Annotated[Optional[bool], Field(alias="stsIncludeSubdomains")] = None
    """
    STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
    """
    sts_preload: Annotated[Optional[bool], Field(alias="stsPreload")] = None
    """
    STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
    """
    sts_seconds: Annotated[Optional[int], Field(alias="stsSeconds", ge=0)] = None
    """
    STSSeconds defines the max-age of the Strict-Transport-Security header.
    If set to 0, the header is not set.
    """


class IpStrategy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpStrategy"]:
            return IpStrategy

        def build(self) -> "IpStrategy":
            return IpStrategy(**self._attrs)

        def depth(self, value: Optional[int], /) -> Self:
            """
            Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
            """
            return self._set("depth", value)

        def excluded_i_ps(self, value: Optional[List[str]], /) -> Self:
            """
            ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
            """
            return self._set("excluded_i_ps", value)

        def ipv6_subnet(self, value: Optional[int], /) -> Self:
            """
            IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
            """
            return self._set("ipv6_subnet", value)

    class BuilderContext(BuilderContextBase["IpStrategy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpStrategy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpStrategy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpStrategy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpStrategy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    depth: Annotated[Optional[int], Field(ge=0)] = None
    """
    Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
    """
    excluded_i_ps: Annotated[Optional[List[str]], Field(alias="excludedIPs")] = None
    """
    ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
    """
    ipv6_subnet: Annotated[Optional[int], Field(alias="ipv6Subnet")] = None
    """
    IPv6Subnet configures Traefik to consider all IPv6 addresses from the defined subnet as originating from the same IP. Applies to RemoteAddrStrategy and DepthStrategy.
    """


class SourceCriterion(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceCriterion"]:
            return SourceCriterion

        def build(self) -> "SourceCriterion":
            return SourceCriterion(**self._attrs)

        @overload
        def ip_strategy(
            self, value_or_callback: Optional[IpStrategy], /
        ) -> "SourceCriterion.Builder": ...

        @overload
        def ip_strategy(
            self,
            value_or_callback: Callable[[IpStrategy.Builder], IpStrategy.Builder | IpStrategy],
            /,
        ) -> "SourceCriterion.Builder": ...

        @overload
        def ip_strategy(self, value_or_callback: Never = ...) -> "IpStrategy.BuilderContext": ...

        def ip_strategy(self, value_or_callback=None, /):
            """
            IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
            """
            if self._in_context and value_or_callback is None:
                context = IpStrategy.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_strategy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpStrategy.builder())
                if isinstance(output, IpStrategy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_strategy", value)

        def request_header_name(self, value: Optional[str], /) -> Self:
            """
            RequestHeaderName defines the name of the header used to group incoming requests.
            """
            return self._set("request_header_name", value)

        def request_host(self, value: Optional[bool], /) -> Self:
            """
            RequestHost defines whether to consider the request Host as the source.
            """
            return self._set("request_host", value)

    class BuilderContext(BuilderContextBase["SourceCriterion.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceCriterion.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceCriterion."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceCriterion", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceCriterion.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ip_strategy: Annotated[Optional[IpStrategy], Field(alias="ipStrategy")] = None
    """
    IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
    """
    request_header_name: Annotated[Optional[str], Field(alias="requestHeaderName")] = None
    """
    RequestHeaderName defines the name of the header used to group incoming requests.
    """
    request_host: Annotated[Optional[bool], Field(alias="requestHost")] = None
    """
    RequestHost defines whether to consider the request Host as the source.
    """


class InFlightReq(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InFlightReq"]:
            return InFlightReq

        def build(self) -> "InFlightReq":
            return InFlightReq(**self._attrs)

        def amount(self, value: Optional[int], /) -> Self:
            """
            Amount defines the maximum amount of allowed simultaneous in-flight request.
            The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
            """
            return self._set("amount", value)

        @overload
        def source_criterion(
            self, value_or_callback: Optional[SourceCriterion], /
        ) -> "InFlightReq.Builder": ...

        @overload
        def source_criterion(
            self,
            value_or_callback: Callable[
                [SourceCriterion.Builder], SourceCriterion.Builder | SourceCriterion
            ],
            /,
        ) -> "InFlightReq.Builder": ...

        @overload
        def source_criterion(
            self, value_or_callback: Never = ...
        ) -> "SourceCriterion.BuilderContext": ...

        def source_criterion(self, value_or_callback=None, /):
            """
            SourceCriterion defines what criterion is used to group requests as originating from a common source.
            If several strategies are defined at the same time, an error will be raised.
            If none are set, the default is to use the requestHost.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/#sourcecriterion
            """
            if self._in_context and value_or_callback is None:
                context = SourceCriterion.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_criterion"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceCriterion.builder())
                if isinstance(output, SourceCriterion.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_criterion", value)

    class BuilderContext(BuilderContextBase["InFlightReq.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InFlightReq.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InFlightReq."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InFlightReq", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InFlightReq.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    amount: Annotated[Optional[int], Field(ge=0)] = None
    """
    Amount defines the maximum amount of allowed simultaneous in-flight request.
    The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
    """
    source_criterion: Annotated[Optional[SourceCriterion], Field(alias="sourceCriterion")] = None
    """
    SourceCriterion defines what criterion is used to group requests as originating from a common source.
    If several strategies are defined at the same time, an error will be raised.
    If none are set, the default is to use the requestHost.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/#sourcecriterion
    """


class IpAllowList(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpAllowList"]:
            return IpAllowList

        def build(self) -> "IpAllowList":
            return IpAllowList(**self._attrs)

        @overload
        def ip_strategy(
            self, value_or_callback: Optional[IpStrategy], /
        ) -> "IpAllowList.Builder": ...

        @overload
        def ip_strategy(
            self,
            value_or_callback: Callable[[IpStrategy.Builder], IpStrategy.Builder | IpStrategy],
            /,
        ) -> "IpAllowList.Builder": ...

        @overload
        def ip_strategy(self, value_or_callback: Never = ...) -> "IpStrategy.BuilderContext": ...

        def ip_strategy(self, value_or_callback=None, /):
            """
            IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
            """
            if self._in_context and value_or_callback is None:
                context = IpStrategy.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_strategy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpStrategy.builder())
                if isinstance(output, IpStrategy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_strategy", value)

        def reject_status_code(self, value: Optional[int], /) -> Self:
            """
            RejectStatusCode defines the HTTP status code used for refused requests.
            If not set, the default is 403 (Forbidden).
            """
            return self._set("reject_status_code", value)

        def source_range(self, value: Optional[List[str]], /) -> Self:
            """
            SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
            """
            return self._set("source_range", value)

    class BuilderContext(BuilderContextBase["IpAllowList.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpAllowList.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpAllowList."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpAllowList", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpAllowList.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ip_strategy: Annotated[Optional[IpStrategy], Field(alias="ipStrategy")] = None
    """
    IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
    """
    reject_status_code: Annotated[Optional[int], Field(alias="rejectStatusCode")] = None
    """
    RejectStatusCode defines the HTTP status code used for refused requests.
    If not set, the default is 403 (Forbidden).
    """
    source_range: Annotated[Optional[List[str]], Field(alias="sourceRange")] = None
    """
    SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
    """


class IpWhiteList(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpWhiteList"]:
            return IpWhiteList

        def build(self) -> "IpWhiteList":
            return IpWhiteList(**self._attrs)

        @overload
        def ip_strategy(
            self, value_or_callback: Optional[IpStrategy], /
        ) -> "IpWhiteList.Builder": ...

        @overload
        def ip_strategy(
            self,
            value_or_callback: Callable[[IpStrategy.Builder], IpStrategy.Builder | IpStrategy],
            /,
        ) -> "IpWhiteList.Builder": ...

        @overload
        def ip_strategy(self, value_or_callback: Never = ...) -> "IpStrategy.BuilderContext": ...

        def ip_strategy(self, value_or_callback=None, /):
            """
            IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
            """
            if self._in_context and value_or_callback is None:
                context = IpStrategy.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_strategy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpStrategy.builder())
                if isinstance(output, IpStrategy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_strategy", value)

        def source_range(self, value: Optional[List[str]], /) -> Self:
            """
            SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation). Required.
            """
            return self._set("source_range", value)

    class BuilderContext(BuilderContextBase["IpWhiteList.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpWhiteList.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpWhiteList."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpWhiteList", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpWhiteList.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ip_strategy: Annotated[Optional[IpStrategy], Field(alias="ipStrategy")] = None
    """
    IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/#ipstrategy
    """
    source_range: Annotated[Optional[List[str]], Field(alias="sourceRange")] = None
    """
    SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation). Required.
    """


class Issuer(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Issuer"]:
            return Issuer

        def build(self) -> "Issuer":
            return Issuer(**self._attrs)

        def common_name(self, value: Optional[bool], /) -> Self:
            """
            CommonName defines whether to add the organizationalUnit information into the issuer.
            """
            return self._set("common_name", value)

        def country(self, value: Optional[bool], /) -> Self:
            """
            Country defines whether to add the country information into the issuer.
            """
            return self._set("country", value)

        def domain_component(self, value: Optional[bool], /) -> Self:
            """
            DomainComponent defines whether to add the domainComponent information into the issuer.
            """
            return self._set("domain_component", value)

        def locality(self, value: Optional[bool], /) -> Self:
            """
            Locality defines whether to add the locality information into the issuer.
            """
            return self._set("locality", value)

        def organization(self, value: Optional[bool], /) -> Self:
            """
            Organization defines whether to add the organization information into the issuer.
            """
            return self._set("organization", value)

        def province(self, value: Optional[bool], /) -> Self:
            """
            Province defines whether to add the province information into the issuer.
            """
            return self._set("province", value)

        def serial_number(self, value: Optional[bool], /) -> Self:
            """
            SerialNumber defines whether to add the serialNumber information into the issuer.
            """
            return self._set("serial_number", value)

    class BuilderContext(BuilderContextBase["Issuer.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Issuer.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Issuer."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Issuer", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Issuer.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_name: Annotated[Optional[bool], Field(alias="commonName")] = None
    """
    CommonName defines whether to add the organizationalUnit information into the issuer.
    """
    country: Optional[bool] = None
    """
    Country defines whether to add the country information into the issuer.
    """
    domain_component: Annotated[Optional[bool], Field(alias="domainComponent")] = None
    """
    DomainComponent defines whether to add the domainComponent information into the issuer.
    """
    locality: Optional[bool] = None
    """
    Locality defines whether to add the locality information into the issuer.
    """
    organization: Optional[bool] = None
    """
    Organization defines whether to add the organization information into the issuer.
    """
    province: Optional[bool] = None
    """
    Province defines whether to add the province information into the issuer.
    """
    serial_number: Annotated[Optional[bool], Field(alias="serialNumber")] = None
    """
    SerialNumber defines whether to add the serialNumber information into the issuer.
    """


class Subject(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Subject"]:
            return Subject

        def build(self) -> "Subject":
            return Subject(**self._attrs)

        def common_name(self, value: Optional[bool], /) -> Self:
            """
            CommonName defines whether to add the organizationalUnit information into the subject.
            """
            return self._set("common_name", value)

        def country(self, value: Optional[bool], /) -> Self:
            """
            Country defines whether to add the country information into the subject.
            """
            return self._set("country", value)

        def domain_component(self, value: Optional[bool], /) -> Self:
            """
            DomainComponent defines whether to add the domainComponent information into the subject.
            """
            return self._set("domain_component", value)

        def locality(self, value: Optional[bool], /) -> Self:
            """
            Locality defines whether to add the locality information into the subject.
            """
            return self._set("locality", value)

        def organization(self, value: Optional[bool], /) -> Self:
            """
            Organization defines whether to add the organization information into the subject.
            """
            return self._set("organization", value)

        def organizational_unit(self, value: Optional[bool], /) -> Self:
            """
            OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
            """
            return self._set("organizational_unit", value)

        def province(self, value: Optional[bool], /) -> Self:
            """
            Province defines whether to add the province information into the subject.
            """
            return self._set("province", value)

        def serial_number(self, value: Optional[bool], /) -> Self:
            """
            SerialNumber defines whether to add the serialNumber information into the subject.
            """
            return self._set("serial_number", value)

    class BuilderContext(BuilderContextBase["Subject.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Subject.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Subject."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Subject", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Subject.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    common_name: Annotated[Optional[bool], Field(alias="commonName")] = None
    """
    CommonName defines whether to add the organizationalUnit information into the subject.
    """
    country: Optional[bool] = None
    """
    Country defines whether to add the country information into the subject.
    """
    domain_component: Annotated[Optional[bool], Field(alias="domainComponent")] = None
    """
    DomainComponent defines whether to add the domainComponent information into the subject.
    """
    locality: Optional[bool] = None
    """
    Locality defines whether to add the locality information into the subject.
    """
    organization: Optional[bool] = None
    """
    Organization defines whether to add the organization information into the subject.
    """
    organizational_unit: Annotated[Optional[bool], Field(alias="organizationalUnit")] = None
    """
    OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
    """
    province: Optional[bool] = None
    """
    Province defines whether to add the province information into the subject.
    """
    serial_number: Annotated[Optional[bool], Field(alias="serialNumber")] = None
    """
    SerialNumber defines whether to add the serialNumber information into the subject.
    """


class Info(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Info"]:
            return Info

        def build(self) -> "Info":
            return Info(**self._attrs)

        @overload
        def issuer(self, value_or_callback: Optional[Issuer], /) -> "Info.Builder": ...

        @overload
        def issuer(
            self,
            value_or_callback: Callable[[Issuer.Builder], Issuer.Builder | Issuer],
            /,
        ) -> "Info.Builder": ...

        @overload
        def issuer(self, value_or_callback: Never = ...) -> "Issuer.BuilderContext": ...

        def issuer(self, value_or_callback=None, /):
            """
            Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
            """
            if self._in_context and value_or_callback is None:
                context = Issuer.BuilderContext()
                context._parent_builder = self
                context._field_name = "issuer"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Issuer.builder())
                if isinstance(output, Issuer.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("issuer", value)

        def not_after(self, value: Optional[bool], /) -> Self:
            """
            NotAfter defines whether to add the Not After information from the Validity part.
            """
            return self._set("not_after", value)

        def not_before(self, value: Optional[bool], /) -> Self:
            """
            NotBefore defines whether to add the Not Before information from the Validity part.
            """
            return self._set("not_before", value)

        def sans(self, value: Optional[bool], /) -> Self:
            """
            Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
            """
            return self._set("sans", value)

        def serial_number(self, value: Optional[bool], /) -> Self:
            """
            SerialNumber defines whether to add the client serialNumber information.
            """
            return self._set("serial_number", value)

        @overload
        def subject(self, value_or_callback: Optional[Subject], /) -> "Info.Builder": ...

        @overload
        def subject(
            self,
            value_or_callback: Callable[[Subject.Builder], Subject.Builder | Subject],
            /,
        ) -> "Info.Builder": ...

        @overload
        def subject(self, value_or_callback: Never = ...) -> "Subject.BuilderContext": ...

        def subject(self, value_or_callback=None, /):
            """
            Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
            """
            if self._in_context and value_or_callback is None:
                context = Subject.BuilderContext()
                context._parent_builder = self
                context._field_name = "subject"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Subject.builder())
                if isinstance(output, Subject.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("subject", value)

    class BuilderContext(BuilderContextBase["Info.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Info.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Info."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Info", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Info.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    issuer: Optional[Issuer] = None
    """
    Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
    """
    not_after: Annotated[Optional[bool], Field(alias="notAfter")] = None
    """
    NotAfter defines whether to add the Not After information from the Validity part.
    """
    not_before: Annotated[Optional[bool], Field(alias="notBefore")] = None
    """
    NotBefore defines whether to add the Not Before information from the Validity part.
    """
    sans: Optional[bool] = None
    """
    Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
    """
    serial_number: Annotated[Optional[bool], Field(alias="serialNumber")] = None
    """
    SerialNumber defines whether to add the client serialNumber information.
    """
    subject: Optional[Subject] = None
    """
    Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
    """


class PassTlsClientCert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PassTlsClientCert"]:
            return PassTlsClientCert

        def build(self) -> "PassTlsClientCert":
            return PassTlsClientCert(**self._attrs)

        @overload
        def info(self, value_or_callback: Optional[Info], /) -> "PassTlsClientCert.Builder": ...

        @overload
        def info(
            self, value_or_callback: Callable[[Info.Builder], Info.Builder | Info], /
        ) -> "PassTlsClientCert.Builder": ...

        @overload
        def info(self, value_or_callback: Never = ...) -> "Info.BuilderContext": ...

        def info(self, value_or_callback=None, /):
            """
            Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
            """
            if self._in_context and value_or_callback is None:
                context = Info.BuilderContext()
                context._parent_builder = self
                context._field_name = "info"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Info.builder())
                if isinstance(output, Info.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("info", value)

        def pem(self, value: Optional[bool], /) -> Self:
            """
            PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
            """
            return self._set("pem", value)

    class BuilderContext(BuilderContextBase["PassTlsClientCert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PassTlsClientCert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PassTlsClientCert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PassTlsClientCert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PassTlsClientCert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    info: Optional[Info] = None
    """
    Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
    """
    pem: Optional[bool] = None
    """
    PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
    """


class DialTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            DialTimeout sets the timeout for establishing new connections.
            Default value is 5 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            DialTimeout sets the timeout for establishing new connections.
            Default value is 5 seconds.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeout":
            value = cast(int, self._value)
            return DialTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout sets the timeout for establishing new connections.
    Default value is 5 seconds.
    """

    class BuilderContext(BuilderContextBase["DialTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeout."""
        return cls.BuilderContext()


class DialTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            DialTimeout sets the timeout for establishing new connections.
            Default value is 5 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            DialTimeout sets the timeout for establishing new connections.
            Default value is 5 seconds.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeoutModel":
            value = cast(str, self._value)
            return DialTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout sets the timeout for establishing new connections.
    Default value is 5 seconds.
    """

    class BuilderContext(BuilderContextBase["DialTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeoutModel."""
        return cls.BuilderContext()


class ReadTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            ReadTimeout defines the timeout for socket read operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            ReadTimeout defines the timeout for socket read operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def build(self) -> "ReadTimeout":
            value = cast(int, self._value)
            return ReadTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ReadTimeout defines the timeout for socket read operations.
    Default value is 3 seconds.
    """

    class BuilderContext(BuilderContextBase["ReadTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadTimeout."""
        return cls.BuilderContext()


class ReadTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            ReadTimeout defines the timeout for socket read operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            ReadTimeout defines the timeout for socket read operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def build(self) -> "ReadTimeoutModel":
            value = cast(str, self._value)
            return ReadTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ReadTimeout defines the timeout for socket read operations.
    Default value is 3 seconds.
    """

    class BuilderContext(BuilderContextBase["ReadTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadTimeoutModel."""
        return cls.BuilderContext()


class TlsModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsModel2"]:
            return TlsModel2

        def build(self) -> "TlsModel2":
            return TlsModel2(**self._attrs)

        def ca_secret(self, value: Optional[str], /) -> Self:
            """
            CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
            The CA certificate is extracted from key `tls.ca` or `ca.crt`.
            """
            return self._set("ca_secret", value)

        def cert_secret(self, value: Optional[str], /) -> Self:
            """
            CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
            The client certificate is extracted from the keys `tls.crt` and `tls.key`.
            """
            return self._set("cert_secret", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            InsecureSkipVerify defines whether the server certificates should be validated.
            """
            return self._set("insecure_skip_verify", value)

    class BuilderContext(BuilderContextBase["TlsModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_secret: Annotated[Optional[str], Field(alias="caSecret")] = None
    """
    CASecret is the name of the referenced Kubernetes Secret containing the CA to validate the server certificate.
    The CA certificate is extracted from key `tls.ca` or `ca.crt`.
    """
    cert_secret: Annotated[Optional[str], Field(alias="certSecret")] = None
    """
    CertSecret is the name of the referenced Kubernetes Secret containing the client certificate.
    The client certificate is extracted from the keys `tls.crt` and `tls.key`.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    InsecureSkipVerify defines whether the server certificates should be validated.
    """


class WriteTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            WriteTimeout defines the timeout for socket write operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            WriteTimeout defines the timeout for socket write operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def build(self) -> "WriteTimeout":
            value = cast(int, self._value)
            return WriteTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    WriteTimeout defines the timeout for socket write operations.
    Default value is 3 seconds.
    """

    class BuilderContext(BuilderContextBase["WriteTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteTimeout."""
        return cls.BuilderContext()


class WriteTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            WriteTimeout defines the timeout for socket write operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            WriteTimeout defines the timeout for socket write operations.
            Default value is 3 seconds.
            """
            self._value = value
            return self

        def build(self) -> "WriteTimeoutModel":
            value = cast(str, self._value)
            return WriteTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    WriteTimeout defines the timeout for socket write operations.
    Default value is 3 seconds.
    """

    class BuilderContext(BuilderContextBase["WriteTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = WriteTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for WriteTimeoutModel."""
        return cls.BuilderContext()


class Redis(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Redis"]:
            return Redis

        def build(self) -> "Redis":
            return Redis(**self._attrs)

        def db(self, value: Optional[int], /) -> Self:
            """
            DB defines the Redis database that will be selected after connecting to the server.
            """
            return self._set("db", value)

        def dial_timeout(self, value: Optional[Union[DialTimeout, DialTimeoutModel]], /) -> Self:
            """
            DialTimeout sets the timeout for establishing new connections.
            Default value is 5 seconds.
            """
            return self._set("dial_timeout", value)

        def endpoints(self, value: Optional[List[str]], /) -> Self:
            """
            Endpoints contains either a single address or a seed list of host:port addresses.
            Default value is ["localhost:6379"].
            """
            return self._set("endpoints", value)

        def max_active_conns(self, value: Optional[int], /) -> Self:
            """
            MaxActiveConns defines the maximum number of connections allocated by the pool at a given time.
            Default value is 0, meaning there is no limit.
            """
            return self._set("max_active_conns", value)

        def min_idle_conns(self, value: Optional[int], /) -> Self:
            """
            MinIdleConns defines the minimum number of idle connections.
            Default value is 0, and idle connections are not closed by default.
            """
            return self._set("min_idle_conns", value)

        def pool_size(self, value: Optional[int], /) -> Self:
            """
            PoolSize defines the initial number of socket connections.
            If the pool runs out of available connections, additional ones will be created beyond PoolSize.
            This can be limited using MaxActiveConns.
            // Default value is 0, meaning 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
            """
            return self._set("pool_size", value)

        def read_timeout(self, value: Optional[Union[ReadTimeout, ReadTimeoutModel]], /) -> Self:
            """
            ReadTimeout defines the timeout for socket read operations.
            Default value is 3 seconds.
            """
            return self._set("read_timeout", value)

        def secret(self, value: Optional[str], /) -> Self:
            """
            Secret defines the name of the referenced Kubernetes Secret containing Redis credentials.
            """
            return self._set("secret", value)

        @overload
        def tls(self, value_or_callback: Optional[TlsModel2], /) -> "Redis.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel2.Builder], TlsModel2.Builder | TlsModel2],
            /,
        ) -> "Redis.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel2.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS defines TLS-specific configurations, including the CA, certificate, and key,
            which can be provided as a file path or file content.
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel2.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel2.builder())
                if isinstance(output, TlsModel2.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        def write_timeout(self, value: Optional[Union[WriteTimeout, WriteTimeoutModel]], /) -> Self:
            """
            WriteTimeout defines the timeout for socket write operations.
            Default value is 3 seconds.
            """
            return self._set("write_timeout", value)

    class BuilderContext(BuilderContextBase["Redis.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Redis.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Redis."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Redis", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Redis.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    db: Optional[int] = None
    """
    DB defines the Redis database that will be selected after connecting to the server.
    """
    dial_timeout: Annotated[
        Optional[Union[DialTimeout, DialTimeoutModel]], Field(alias="dialTimeout")
    ] = None
    """
    DialTimeout sets the timeout for establishing new connections.
    Default value is 5 seconds.
    """
    endpoints: Optional[List[str]] = None
    """
    Endpoints contains either a single address or a seed list of host:port addresses.
    Default value is ["localhost:6379"].
    """
    max_active_conns: Annotated[Optional[int], Field(alias="maxActiveConns")] = None
    """
    MaxActiveConns defines the maximum number of connections allocated by the pool at a given time.
    Default value is 0, meaning there is no limit.
    """
    min_idle_conns: Annotated[Optional[int], Field(alias="minIdleConns")] = None
    """
    MinIdleConns defines the minimum number of idle connections.
    Default value is 0, and idle connections are not closed by default.
    """
    pool_size: Annotated[Optional[int], Field(alias="poolSize")] = None
    """
    PoolSize defines the initial number of socket connections.
    If the pool runs out of available connections, additional ones will be created beyond PoolSize.
    This can be limited using MaxActiveConns.
    // Default value is 0, meaning 10 connections per every available CPU as reported by runtime.GOMAXPROCS.
    """
    read_timeout: Annotated[
        Optional[Union[ReadTimeout, ReadTimeoutModel]], Field(alias="readTimeout")
    ] = None
    """
    ReadTimeout defines the timeout for socket read operations.
    Default value is 3 seconds.
    """
    secret: Optional[str] = None
    """
    Secret defines the name of the referenced Kubernetes Secret containing Redis credentials.
    """
    tls: Optional[TlsModel2] = None
    """
    TLS defines TLS-specific configurations, including the CA, certificate, and key,
    which can be provided as a file path or file content.
    """
    write_timeout: Annotated[
        Optional[Union[WriteTimeout, WriteTimeoutModel]], Field(alias="writeTimeout")
    ] = None
    """
    WriteTimeout defines the timeout for socket write operations.
    Default value is 3 seconds.
    """


class RateLimit(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RateLimit"]:
            return RateLimit

        def build(self) -> "RateLimit":
            return RateLimit(**self._attrs)

        def average(self, value: Optional[int], /) -> Self:
            """
            Average is the maximum rate, by default in requests/s, allowed for the given source.
            It defaults to 0, which means no rate limiting.
            The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
            one needs to define a Period larger than a second.
            """
            return self._set("average", value)

        def burst(self, value: Optional[int], /) -> Self:
            """
            Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
            It defaults to 1.
            """
            return self._set("burst", value)

        def period(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Period, in combination with Average, defines the actual maximum rate, such as:
            r = Average / Period. It defaults to a second.
            """
            return self._set("period", value)

        @overload
        def redis(self, value_or_callback: Optional[Redis], /) -> "RateLimit.Builder": ...

        @overload
        def redis(
            self, value_or_callback: Callable[[Redis.Builder], Redis.Builder | Redis], /
        ) -> "RateLimit.Builder": ...

        @overload
        def redis(self, value_or_callback: Never = ...) -> "Redis.BuilderContext": ...

        def redis(self, value_or_callback=None, /):
            """
            Redis hold the configs of Redis as bucket in rate limiter.
            """
            if self._in_context and value_or_callback is None:
                context = Redis.BuilderContext()
                context._parent_builder = self
                context._field_name = "redis"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Redis.builder())
                if isinstance(output, Redis.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("redis", value)

        @overload
        def source_criterion(
            self, value_or_callback: Optional[SourceCriterion], /
        ) -> "RateLimit.Builder": ...

        @overload
        def source_criterion(
            self,
            value_or_callback: Callable[
                [SourceCriterion.Builder], SourceCriterion.Builder | SourceCriterion
            ],
            /,
        ) -> "RateLimit.Builder": ...

        @overload
        def source_criterion(
            self, value_or_callback: Never = ...
        ) -> "SourceCriterion.BuilderContext": ...

        def source_criterion(self, value_or_callback=None, /):
            """
            SourceCriterion defines what criterion is used to group requests as originating from a common source.
            If several strategies are defined at the same time, an error will be raised.
            If none are set, the default is to use the request's remote address field (as an ipStrategy).
            """
            if self._in_context and value_or_callback is None:
                context = SourceCriterion.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_criterion"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceCriterion.builder())
                if isinstance(output, SourceCriterion.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_criterion", value)

    class BuilderContext(BuilderContextBase["RateLimit.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RateLimit.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RateLimit."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RateLimit", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RateLimit.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    average: Annotated[Optional[int], Field(ge=0)] = None
    """
    Average is the maximum rate, by default in requests/s, allowed for the given source.
    It defaults to 0, which means no rate limiting.
    The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
    one needs to define a Period larger than a second.
    """
    burst: Annotated[Optional[int], Field(ge=0)] = None
    """
    Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
    It defaults to 1.
    """
    period: Optional[Union[int, str]] = None
    """
    Period, in combination with Average, defines the actual maximum rate, such as:
    r = Average / Period. It defaults to a second.
    """
    redis: Optional[Redis] = None
    """
    Redis hold the configs of Redis as bucket in rate limiter.
    """
    source_criterion: Annotated[Optional[SourceCriterion], Field(alias="sourceCriterion")] = None
    """
    SourceCriterion defines what criterion is used to group requests as originating from a common source.
    If several strategies are defined at the same time, an error will be raised.
    If none are set, the default is to use the request's remote address field (as an ipStrategy).
    """


class RedirectRegex(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedirectRegex"]:
            return RedirectRegex

        def build(self) -> "RedirectRegex":
            return RedirectRegex(**self._attrs)

        def permanent(self, value: Optional[bool], /) -> Self:
            """
            Permanent defines whether the redirection is permanent (308).
            """
            return self._set("permanent", value)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regex defines the regex used to match and capture elements from the request URL.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement defines how to modify the URL to have the new target URL.
            """
            return self._set("replacement", value)

    class BuilderContext(BuilderContextBase["RedirectRegex.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedirectRegex.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedirectRegex."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedirectRegex", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedirectRegex.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    permanent: Optional[bool] = None
    """
    Permanent defines whether the redirection is permanent (308).
    """
    regex: Optional[str] = None
    """
    Regex defines the regex used to match and capture elements from the request URL.
    """
    replacement: Optional[str] = None
    """
    Replacement defines how to modify the URL to have the new target URL.
    """


class RedirectScheme(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RedirectScheme"]:
            return RedirectScheme

        def build(self) -> "RedirectScheme":
            return RedirectScheme(**self._attrs)

        def permanent(self, value: Optional[bool], /) -> Self:
            """
            Permanent defines whether the redirection is permanent (308).
            """
            return self._set("permanent", value)

        def port(self, value: Optional[str], /) -> Self:
            """
            Port defines the port of the new URL.
            """
            return self._set("port", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme defines the scheme of the new URL.
            """
            return self._set("scheme", value)

    class BuilderContext(BuilderContextBase["RedirectScheme.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RedirectScheme.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RedirectScheme."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RedirectScheme", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RedirectScheme.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    permanent: Optional[bool] = None
    """
    Permanent defines whether the redirection is permanent (308).
    """
    port: Optional[str] = None
    """
    Port defines the port of the new URL.
    """
    scheme: Optional[str] = None
    """
    Scheme defines the scheme of the new URL.
    """


class ReplacePath(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReplacePath"]:
            return ReplacePath

        def build(self) -> "ReplacePath":
            return ReplacePath(**self._attrs)

        def path(self, value: Optional[str], /) -> Self:
            """
            Path defines the path to use as replacement in the request URL.
            """
            return self._set("path", value)

    class BuilderContext(BuilderContextBase["ReplacePath.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReplacePath.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReplacePath."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReplacePath", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReplacePath.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    path: Optional[str] = None
    """
    Path defines the path to use as replacement in the request URL.
    """


class ReplacePathRegex(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReplacePathRegex"]:
            return ReplacePathRegex

        def build(self) -> "ReplacePathRegex":
            return ReplacePathRegex(**self._attrs)

        def regex(self, value: Optional[str], /) -> Self:
            """
            Regex defines the regular expression used to match and capture the path from the request URL.
            """
            return self._set("regex", value)

        def replacement(self, value: Optional[str], /) -> Self:
            """
            Replacement defines the replacement path format, which can include captured variables.
            """
            return self._set("replacement", value)

    class BuilderContext(BuilderContextBase["ReplacePathRegex.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReplacePathRegex.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReplacePathRegex."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReplacePathRegex", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReplacePathRegex.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    regex: Optional[str] = None
    """
    Regex defines the regular expression used to match and capture the path from the request URL.
    """
    replacement: Optional[str] = None
    """
    Replacement defines the replacement path format, which can include captured variables.
    """


class InitialInterval(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            InitialInterval defines the first wait time in the exponential backoff series.
            The maximum interval is calculated as twice the initialInterval.
            If unspecified, requests will be retried immediately.
            The value of initialInterval should be provided in seconds or as a valid duration format,
            see https://pkg.go.dev/time#ParseDuration.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            InitialInterval defines the first wait time in the exponential backoff series.
            The maximum interval is calculated as twice the initialInterval.
            If unspecified, requests will be retried immediately.
            The value of initialInterval should be provided in seconds or as a valid duration format,
            see https://pkg.go.dev/time#ParseDuration.
            """
            self._value = value
            return self

        def build(self) -> "InitialInterval":
            value = cast(int, self._value)
            return InitialInterval(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    InitialInterval defines the first wait time in the exponential backoff series.
    The maximum interval is calculated as twice the initialInterval.
    If unspecified, requests will be retried immediately.
    The value of initialInterval should be provided in seconds or as a valid duration format,
    see https://pkg.go.dev/time#ParseDuration.
    """

    class BuilderContext(BuilderContextBase["InitialInterval.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitialInterval.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitialInterval."""
        return cls.BuilderContext()


class InitialIntervalModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            InitialInterval defines the first wait time in the exponential backoff series.
            The maximum interval is calculated as twice the initialInterval.
            If unspecified, requests will be retried immediately.
            The value of initialInterval should be provided in seconds or as a valid duration format,
            see https://pkg.go.dev/time#ParseDuration.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            InitialInterval defines the first wait time in the exponential backoff series.
            The maximum interval is calculated as twice the initialInterval.
            If unspecified, requests will be retried immediately.
            The value of initialInterval should be provided in seconds or as a valid duration format,
            see https://pkg.go.dev/time#ParseDuration.
            """
            self._value = value
            return self

        def build(self) -> "InitialIntervalModel":
            value = cast(str, self._value)
            return InitialIntervalModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    InitialInterval defines the first wait time in the exponential backoff series.
    The maximum interval is calculated as twice the initialInterval.
    If unspecified, requests will be retried immediately.
    The value of initialInterval should be provided in seconds or as a valid duration format,
    see https://pkg.go.dev/time#ParseDuration.
    """

    class BuilderContext(BuilderContextBase["InitialIntervalModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InitialIntervalModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InitialIntervalModel."""
        return cls.BuilderContext()


class Retry(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Retry"]:
            return Retry

        def build(self) -> "Retry":
            return Retry(**self._attrs)

        def attempts(self, value: Optional[int], /) -> Self:
            """
            Attempts defines how many times the request should be retried.
            """
            return self._set("attempts", value)

        def initial_interval(
            self, value: Optional[Union[InitialInterval, InitialIntervalModel]], /
        ) -> Self:
            """
            InitialInterval defines the first wait time in the exponential backoff series.
            The maximum interval is calculated as twice the initialInterval.
            If unspecified, requests will be retried immediately.
            The value of initialInterval should be provided in seconds or as a valid duration format,
            see https://pkg.go.dev/time#ParseDuration.
            """
            return self._set("initial_interval", value)

    class BuilderContext(BuilderContextBase["Retry.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Retry.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Retry."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Retry", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Retry.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attempts: Annotated[Optional[int], Field(ge=0)] = None
    """
    Attempts defines how many times the request should be retried.
    """
    initial_interval: Annotated[
        Optional[Union[InitialInterval, InitialIntervalModel]],
        Field(alias="initialInterval"),
    ] = None
    """
    InitialInterval defines the first wait time in the exponential backoff series.
    The maximum interval is calculated as twice the initialInterval.
    If unspecified, requests will be retried immediately.
    The value of initialInterval should be provided in seconds or as a valid duration format,
    see https://pkg.go.dev/time#ParseDuration.
    """


class StripPrefix(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StripPrefix"]:
            return StripPrefix

        def build(self) -> "StripPrefix":
            return StripPrefix(**self._attrs)

        def force_slash(self, value: Optional[bool], /) -> Self:
            """
            Deprecated: ForceSlash option is deprecated, please remove any usage of this option.
            ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
            Default: true.
            """
            return self._set("force_slash", value)

        def prefixes(self, value: Optional[List[str]], /) -> Self:
            """
            Prefixes defines the prefixes to strip from the request URL.
            """
            return self._set("prefixes", value)

    class BuilderContext(BuilderContextBase["StripPrefix.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StripPrefix.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StripPrefix."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StripPrefix", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StripPrefix.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    force_slash: Annotated[Optional[bool], Field(alias="forceSlash")] = None
    """
    Deprecated: ForceSlash option is deprecated, please remove any usage of this option.
    ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
    Default: true.
    """
    prefixes: Optional[List[str]] = None
    """
    Prefixes defines the prefixes to strip from the request URL.
    """


class StripPrefixRegex(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StripPrefixRegex"]:
            return StripPrefixRegex

        def build(self) -> "StripPrefixRegex":
            return StripPrefixRegex(**self._attrs)

        def regex(self, value: Optional[List[str]], /) -> Self:
            """
            Regex defines the regular expression to match the path prefix from the request URL.
            """
            return self._set("regex", value)

    class BuilderContext(BuilderContextBase["StripPrefixRegex.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StripPrefixRegex.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StripPrefixRegex."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StripPrefixRegex", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StripPrefixRegex.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    regex: Optional[List[str]] = None
    """
    Regex defines the regular expression to match the path prefix from the request URL.
    """


class MiddlewareSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareSpec"]:
            return MiddlewareSpec

        def build(self) -> "MiddlewareSpec":
            return MiddlewareSpec(**self._attrs)

        @overload
        def add_prefix(
            self, value_or_callback: Optional[AddPrefix], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def add_prefix(
            self,
            value_or_callback: Callable[[AddPrefix.Builder], AddPrefix.Builder | AddPrefix],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def add_prefix(self, value_or_callback: Never = ...) -> "AddPrefix.BuilderContext": ...

        def add_prefix(self, value_or_callback=None, /):
            """
            AddPrefix holds the add prefix middleware configuration.
            This middleware updates the path of a request before forwarding it.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/addprefix/
            """
            if self._in_context and value_or_callback is None:
                context = AddPrefix.BuilderContext()
                context._parent_builder = self
                context._field_name = "add_prefix"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AddPrefix.builder())
                if isinstance(output, AddPrefix.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("add_prefix", value)

        @overload
        def basic_auth(
            self, value_or_callback: Optional[BasicAuth], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def basic_auth(
            self,
            value_or_callback: Callable[[BasicAuth.Builder], BasicAuth.Builder | BasicAuth],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def basic_auth(self, value_or_callback: Never = ...) -> "BasicAuth.BuilderContext": ...

        def basic_auth(self, value_or_callback=None, /):
            """
            BasicAuth holds the basic auth middleware configuration.
            This middleware restricts access to your services to known users.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/
            """
            if self._in_context and value_or_callback is None:
                context = BasicAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "basic_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(BasicAuth.builder())
                if isinstance(output, BasicAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("basic_auth", value)

        @overload
        def buffering(
            self, value_or_callback: Optional[Buffering], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def buffering(
            self,
            value_or_callback: Callable[[Buffering.Builder], Buffering.Builder | Buffering],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def buffering(self, value_or_callback: Never = ...) -> "Buffering.BuilderContext": ...

        def buffering(self, value_or_callback=None, /):
            """
            Buffering holds the buffering middleware configuration.
            This middleware retries or limits the size of requests that can be forwarded to backends.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#maxrequestbodybytes
            """
            if self._in_context and value_or_callback is None:
                context = Buffering.BuilderContext()
                context._parent_builder = self
                context._field_name = "buffering"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Buffering.builder())
                if isinstance(output, Buffering.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("buffering", value)

        @overload
        def chain(self, value_or_callback: Optional[Chain], /) -> "MiddlewareSpec.Builder": ...

        @overload
        def chain(
            self, value_or_callback: Callable[[Chain.Builder], Chain.Builder | Chain], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def chain(self, value_or_callback: Never = ...) -> "Chain.BuilderContext": ...

        def chain(self, value_or_callback=None, /):
            """
            Chain holds the configuration of the chain middleware.
            This middleware enables to define reusable combinations of other pieces of middleware.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/chain/
            """
            if self._in_context and value_or_callback is None:
                context = Chain.BuilderContext()
                context._parent_builder = self
                context._field_name = "chain"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Chain.builder())
                if isinstance(output, Chain.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("chain", value)

        @overload
        def circuit_breaker(
            self, value_or_callback: Optional[CircuitBreaker], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def circuit_breaker(
            self,
            value_or_callback: Callable[
                [CircuitBreaker.Builder], CircuitBreaker.Builder | CircuitBreaker
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def circuit_breaker(
            self, value_or_callback: Never = ...
        ) -> "CircuitBreaker.BuilderContext": ...

        def circuit_breaker(self, value_or_callback=None, /):
            """
            CircuitBreaker holds the circuit breaker configuration.
            """
            if self._in_context and value_or_callback is None:
                context = CircuitBreaker.BuilderContext()
                context._parent_builder = self
                context._field_name = "circuit_breaker"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CircuitBreaker.builder())
                if isinstance(output, CircuitBreaker.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("circuit_breaker", value)

        @overload
        def compress(
            self, value_or_callback: Optional[Compress], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def compress(
            self,
            value_or_callback: Callable[[Compress.Builder], Compress.Builder | Compress],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def compress(self, value_or_callback: Never = ...) -> "Compress.BuilderContext": ...

        def compress(self, value_or_callback=None, /):
            """
            Compress holds the compress middleware configuration.
            This middleware compresses responses before sending them to the client, using gzip, brotli, or zstd compression.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/compress/
            """
            if self._in_context and value_or_callback is None:
                context = Compress.BuilderContext()
                context._parent_builder = self
                context._field_name = "compress"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Compress.builder())
                if isinstance(output, Compress.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("compress", value)

        @overload
        def content_type(
            self, value_or_callback: Optional[ContentType], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def content_type(
            self,
            value_or_callback: Callable[[ContentType.Builder], ContentType.Builder | ContentType],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def content_type(self, value_or_callback: Never = ...) -> "ContentType.BuilderContext": ...

        def content_type(self, value_or_callback=None, /):
            """
            ContentType holds the content-type middleware configuration.
            This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
            """
            if self._in_context and value_or_callback is None:
                context = ContentType.BuilderContext()
                context._parent_builder = self
                context._field_name = "content_type"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ContentType.builder())
                if isinstance(output, ContentType.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("content_type", value)

        @overload
        def digest_auth(
            self, value_or_callback: Optional[DigestAuth], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def digest_auth(
            self,
            value_or_callback: Callable[[DigestAuth.Builder], DigestAuth.Builder | DigestAuth],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def digest_auth(self, value_or_callback: Never = ...) -> "DigestAuth.BuilderContext": ...

        def digest_auth(self, value_or_callback=None, /):
            """
            DigestAuth holds the digest auth middleware configuration.
            This middleware restricts access to your services to known users.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/digestauth/
            """
            if self._in_context and value_or_callback is None:
                context = DigestAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "digest_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DigestAuth.builder())
                if isinstance(output, DigestAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("digest_auth", value)

        @overload
        def errors(self, value_or_callback: Optional[Errors], /) -> "MiddlewareSpec.Builder": ...

        @overload
        def errors(
            self,
            value_or_callback: Callable[[Errors.Builder], Errors.Builder | Errors],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def errors(self, value_or_callback: Never = ...) -> "Errors.BuilderContext": ...

        def errors(self, value_or_callback=None, /):
            """
            ErrorPage holds the custom error middleware configuration.
            This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/errorpages/
            """
            if self._in_context and value_or_callback is None:
                context = Errors.BuilderContext()
                context._parent_builder = self
                context._field_name = "errors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Errors.builder())
                if isinstance(output, Errors.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("errors", value)

        @overload
        def forward_auth(
            self, value_or_callback: Optional[ForwardAuth], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def forward_auth(
            self,
            value_or_callback: Callable[[ForwardAuth.Builder], ForwardAuth.Builder | ForwardAuth],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def forward_auth(self, value_or_callback: Never = ...) -> "ForwardAuth.BuilderContext": ...

        def forward_auth(self, value_or_callback=None, /):
            """
            ForwardAuth holds the forward auth middleware configuration.
            This middleware delegates the request authentication to a Service.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/
            """
            if self._in_context and value_or_callback is None:
                context = ForwardAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "forward_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForwardAuth.builder())
                if isinstance(output, ForwardAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("forward_auth", value)

        @overload
        def grpc_web(self, value_or_callback: Optional[GrpcWeb], /) -> "MiddlewareSpec.Builder": ...

        @overload
        def grpc_web(
            self,
            value_or_callback: Callable[[GrpcWeb.Builder], GrpcWeb.Builder | GrpcWeb],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def grpc_web(self, value_or_callback: Never = ...) -> "GrpcWeb.BuilderContext": ...

        def grpc_web(self, value_or_callback=None, /):
            """
            GrpcWeb holds the gRPC web middleware configuration.
            This middleware converts a gRPC web request to an HTTP/2 gRPC request.
            """
            if self._in_context and value_or_callback is None:
                context = GrpcWeb.BuilderContext()
                context._parent_builder = self
                context._field_name = "grpc_web"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GrpcWeb.builder())
                if isinstance(output, GrpcWeb.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("grpc_web", value)

        @overload
        def headers(self, value_or_callback: Optional[Headers], /) -> "MiddlewareSpec.Builder": ...

        @overload
        def headers(
            self,
            value_or_callback: Callable[[Headers.Builder], Headers.Builder | Headers],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def headers(self, value_or_callback: Never = ...) -> "Headers.BuilderContext": ...

        def headers(self, value_or_callback=None, /):
            """
            Headers holds the headers middleware configuration.
            This middleware manages the requests and responses headers.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/headers/#customrequestheaders
            """
            if self._in_context and value_or_callback is None:
                context = Headers.BuilderContext()
                context._parent_builder = self
                context._field_name = "headers"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Headers.builder())
                if isinstance(output, Headers.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("headers", value)

        @overload
        def in_flight_req(
            self, value_or_callback: Optional[InFlightReq], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def in_flight_req(
            self,
            value_or_callback: Callable[[InFlightReq.Builder], InFlightReq.Builder | InFlightReq],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def in_flight_req(self, value_or_callback: Never = ...) -> "InFlightReq.BuilderContext": ...

        def in_flight_req(self, value_or_callback=None, /):
            """
            InFlightReq holds the in-flight request middleware configuration.
            This middleware limits the number of requests being processed and served concurrently.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/
            """
            if self._in_context and value_or_callback is None:
                context = InFlightReq.BuilderContext()
                context._parent_builder = self
                context._field_name = "in_flight_req"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InFlightReq.builder())
                if isinstance(output, InFlightReq.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("in_flight_req", value)

        @overload
        def ip_allow_list(
            self, value_or_callback: Optional[IpAllowList], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def ip_allow_list(
            self,
            value_or_callback: Callable[[IpAllowList.Builder], IpAllowList.Builder | IpAllowList],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def ip_allow_list(self, value_or_callback: Never = ...) -> "IpAllowList.BuilderContext": ...

        def ip_allow_list(self, value_or_callback=None, /):
            """
            IPAllowList holds the IP allowlist middleware configuration.
            This middleware limits allowed requests based on the client IP.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/
            """
            if self._in_context and value_or_callback is None:
                context = IpAllowList.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_allow_list"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAllowList.builder())
                if isinstance(output, IpAllowList.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_allow_list", value)

        @overload
        def ip_white_list(
            self, value_or_callback: Optional[IpWhiteList], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def ip_white_list(
            self,
            value_or_callback: Callable[[IpWhiteList.Builder], IpWhiteList.Builder | IpWhiteList],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def ip_white_list(self, value_or_callback: Never = ...) -> "IpWhiteList.BuilderContext": ...

        def ip_white_list(self, value_or_callback=None, /):
            """
            Deprecated: please use IPAllowList instead.
            """
            if self._in_context and value_or_callback is None:
                context = IpWhiteList.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_white_list"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpWhiteList.builder())
                if isinstance(output, IpWhiteList.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_white_list", value)

        @overload
        def pass_tls_client_cert(
            self, value_or_callback: Optional[PassTlsClientCert], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def pass_tls_client_cert(
            self,
            value_or_callback: Callable[
                [PassTlsClientCert.Builder],
                PassTlsClientCert.Builder | PassTlsClientCert,
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def pass_tls_client_cert(
            self, value_or_callback: Never = ...
        ) -> "PassTlsClientCert.BuilderContext": ...

        def pass_tls_client_cert(self, value_or_callback=None, /):
            """
            PassTLSClientCert holds the pass TLS client cert middleware configuration.
            This middleware adds the selected data from the passed client TLS certificate to a header.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/passtlsclientcert/
            """
            if self._in_context and value_or_callback is None:
                context = PassTlsClientCert.BuilderContext()
                context._parent_builder = self
                context._field_name = "pass_tls_client_cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PassTlsClientCert.builder())
                if isinstance(output, PassTlsClientCert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("pass_tls_client_cert", value)

        def plugin(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Plugin defines the middleware plugin configuration.
            More info: https://doc.traefik.io/traefik/plugins/
            """
            return self._set("plugin", value)

        @overload
        def rate_limit(
            self, value_or_callback: Optional[RateLimit], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def rate_limit(
            self,
            value_or_callback: Callable[[RateLimit.Builder], RateLimit.Builder | RateLimit],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def rate_limit(self, value_or_callback: Never = ...) -> "RateLimit.BuilderContext": ...

        def rate_limit(self, value_or_callback=None, /):
            """
            RateLimit holds the rate limit configuration.
            This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ratelimit/
            """
            if self._in_context and value_or_callback is None:
                context = RateLimit.BuilderContext()
                context._parent_builder = self
                context._field_name = "rate_limit"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RateLimit.builder())
                if isinstance(output, RateLimit.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("rate_limit", value)

        @overload
        def redirect_regex(
            self, value_or_callback: Optional[RedirectRegex], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def redirect_regex(
            self,
            value_or_callback: Callable[
                [RedirectRegex.Builder], RedirectRegex.Builder | RedirectRegex
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def redirect_regex(
            self, value_or_callback: Never = ...
        ) -> "RedirectRegex.BuilderContext": ...

        def redirect_regex(self, value_or_callback=None, /):
            """
            RedirectRegex holds the redirect regex middleware configuration.
            This middleware redirects a request using regex matching and replacement.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectregex/#regex
            """
            if self._in_context and value_or_callback is None:
                context = RedirectRegex.BuilderContext()
                context._parent_builder = self
                context._field_name = "redirect_regex"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RedirectRegex.builder())
                if isinstance(output, RedirectRegex.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("redirect_regex", value)

        @overload
        def redirect_scheme(
            self, value_or_callback: Optional[RedirectScheme], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def redirect_scheme(
            self,
            value_or_callback: Callable[
                [RedirectScheme.Builder], RedirectScheme.Builder | RedirectScheme
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def redirect_scheme(
            self, value_or_callback: Never = ...
        ) -> "RedirectScheme.BuilderContext": ...

        def redirect_scheme(self, value_or_callback=None, /):
            """
            RedirectScheme holds the redirect scheme middleware configuration.
            This middleware redirects requests from a scheme/port to another.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectscheme/
            """
            if self._in_context and value_or_callback is None:
                context = RedirectScheme.BuilderContext()
                context._parent_builder = self
                context._field_name = "redirect_scheme"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RedirectScheme.builder())
                if isinstance(output, RedirectScheme.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("redirect_scheme", value)

        @overload
        def replace_path(
            self, value_or_callback: Optional[ReplacePath], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def replace_path(
            self,
            value_or_callback: Callable[[ReplacePath.Builder], ReplacePath.Builder | ReplacePath],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def replace_path(self, value_or_callback: Never = ...) -> "ReplacePath.BuilderContext": ...

        def replace_path(self, value_or_callback=None, /):
            """
            ReplacePath holds the replace path middleware configuration.
            This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepath/
            """
            if self._in_context and value_or_callback is None:
                context = ReplacePath.BuilderContext()
                context._parent_builder = self
                context._field_name = "replace_path"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReplacePath.builder())
                if isinstance(output, ReplacePath.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("replace_path", value)

        @overload
        def replace_path_regex(
            self, value_or_callback: Optional[ReplacePathRegex], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def replace_path_regex(
            self,
            value_or_callback: Callable[
                [ReplacePathRegex.Builder], ReplacePathRegex.Builder | ReplacePathRegex
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def replace_path_regex(
            self, value_or_callback: Never = ...
        ) -> "ReplacePathRegex.BuilderContext": ...

        def replace_path_regex(self, value_or_callback=None, /):
            """
            ReplacePathRegex holds the replace path regex middleware configuration.
            This middleware replaces the path of a URL using regex matching and replacement.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepathregex/
            """
            if self._in_context and value_or_callback is None:
                context = ReplacePathRegex.BuilderContext()
                context._parent_builder = self
                context._field_name = "replace_path_regex"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReplacePathRegex.builder())
                if isinstance(output, ReplacePathRegex.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("replace_path_regex", value)

        @overload
        def retry(self, value_or_callback: Optional[Retry], /) -> "MiddlewareSpec.Builder": ...

        @overload
        def retry(
            self, value_or_callback: Callable[[Retry.Builder], Retry.Builder | Retry], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def retry(self, value_or_callback: Never = ...) -> "Retry.BuilderContext": ...

        def retry(self, value_or_callback=None, /):
            """
            Retry holds the retry middleware configuration.
            This middleware reissues requests a given number of times to a backend server if that server does not reply.
            As soon as the server answers, the middleware stops retrying, regardless of the response status.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/retry/
            """
            if self._in_context and value_or_callback is None:
                context = Retry.BuilderContext()
                context._parent_builder = self
                context._field_name = "retry"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Retry.builder())
                if isinstance(output, Retry.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("retry", value)

        @overload
        def strip_prefix(
            self, value_or_callback: Optional[StripPrefix], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def strip_prefix(
            self,
            value_or_callback: Callable[[StripPrefix.Builder], StripPrefix.Builder | StripPrefix],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def strip_prefix(self, value_or_callback: Never = ...) -> "StripPrefix.BuilderContext": ...

        def strip_prefix(self, value_or_callback=None, /):
            """
            StripPrefix holds the strip prefix middleware configuration.
            This middleware removes the specified prefixes from the URL path.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefix/
            """
            if self._in_context and value_or_callback is None:
                context = StripPrefix.BuilderContext()
                context._parent_builder = self
                context._field_name = "strip_prefix"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StripPrefix.builder())
                if isinstance(output, StripPrefix.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("strip_prefix", value)

        @overload
        def strip_prefix_regex(
            self, value_or_callback: Optional[StripPrefixRegex], /
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def strip_prefix_regex(
            self,
            value_or_callback: Callable[
                [StripPrefixRegex.Builder], StripPrefixRegex.Builder | StripPrefixRegex
            ],
            /,
        ) -> "MiddlewareSpec.Builder": ...

        @overload
        def strip_prefix_regex(
            self, value_or_callback: Never = ...
        ) -> "StripPrefixRegex.BuilderContext": ...

        def strip_prefix_regex(self, value_or_callback=None, /):
            """
            StripPrefixRegex holds the strip prefix regex middleware configuration.
            This middleware removes the matching prefixes from the URL path.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefixregex/
            """
            if self._in_context and value_or_callback is None:
                context = StripPrefixRegex.BuilderContext()
                context._parent_builder = self
                context._field_name = "strip_prefix_regex"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StripPrefixRegex.builder())
                if isinstance(output, StripPrefixRegex.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("strip_prefix_regex", value)

    class BuilderContext(BuilderContextBase["MiddlewareSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    add_prefix: Annotated[Optional[AddPrefix], Field(alias="addPrefix")] = None
    """
    AddPrefix holds the add prefix middleware configuration.
    This middleware updates the path of a request before forwarding it.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/addprefix/
    """
    basic_auth: Annotated[Optional[BasicAuth], Field(alias="basicAuth")] = None
    """
    BasicAuth holds the basic auth middleware configuration.
    This middleware restricts access to your services to known users.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/basicauth/
    """
    buffering: Optional[Buffering] = None
    """
    Buffering holds the buffering middleware configuration.
    This middleware retries or limits the size of requests that can be forwarded to backends.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/buffering/#maxrequestbodybytes
    """
    chain: Optional[Chain] = None
    """
    Chain holds the configuration of the chain middleware.
    This middleware enables to define reusable combinations of other pieces of middleware.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/chain/
    """
    circuit_breaker: Annotated[Optional[CircuitBreaker], Field(alias="circuitBreaker")] = None
    """
    CircuitBreaker holds the circuit breaker configuration.
    """
    compress: Optional[Compress] = None
    """
    Compress holds the compress middleware configuration.
    This middleware compresses responses before sending them to the client, using gzip, brotli, or zstd compression.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/compress/
    """
    content_type: Annotated[Optional[ContentType], Field(alias="contentType")] = None
    """
    ContentType holds the content-type middleware configuration.
    This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
    """
    digest_auth: Annotated[Optional[DigestAuth], Field(alias="digestAuth")] = None
    """
    DigestAuth holds the digest auth middleware configuration.
    This middleware restricts access to your services to known users.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/digestauth/
    """
    errors: Optional[Errors] = None
    """
    ErrorPage holds the custom error middleware configuration.
    This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/errorpages/
    """
    forward_auth: Annotated[Optional[ForwardAuth], Field(alias="forwardAuth")] = None
    """
    ForwardAuth holds the forward auth middleware configuration.
    This middleware delegates the request authentication to a Service.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/forwardauth/
    """
    grpc_web: Annotated[Optional[GrpcWeb], Field(alias="grpcWeb")] = None
    """
    GrpcWeb holds the gRPC web middleware configuration.
    This middleware converts a gRPC web request to an HTTP/2 gRPC request.
    """
    headers: Optional[Headers] = None
    """
    Headers holds the headers middleware configuration.
    This middleware manages the requests and responses headers.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/headers/#customrequestheaders
    """
    in_flight_req: Annotated[Optional[InFlightReq], Field(alias="inFlightReq")] = None
    """
    InFlightReq holds the in-flight request middleware configuration.
    This middleware limits the number of requests being processed and served concurrently.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/inflightreq/
    """
    ip_allow_list: Annotated[Optional[IpAllowList], Field(alias="ipAllowList")] = None
    """
    IPAllowList holds the IP allowlist middleware configuration.
    This middleware limits allowed requests based on the client IP.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ipallowlist/
    """
    ip_white_list: Annotated[Optional[IpWhiteList], Field(alias="ipWhiteList")] = None
    """
    Deprecated: please use IPAllowList instead.
    """
    pass_tls_client_cert: Annotated[
        Optional[PassTlsClientCert], Field(alias="passTLSClientCert")
    ] = None
    """
    PassTLSClientCert holds the pass TLS client cert middleware configuration.
    This middleware adds the selected data from the passed client TLS certificate to a header.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/passtlsclientcert/
    """
    plugin: Optional[Dict[str, Any]] = None
    """
    Plugin defines the middleware plugin configuration.
    More info: https://doc.traefik.io/traefik/plugins/
    """
    rate_limit: Annotated[Optional[RateLimit], Field(alias="rateLimit")] = None
    """
    RateLimit holds the rate limit configuration.
    This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/ratelimit/
    """
    redirect_regex: Annotated[Optional[RedirectRegex], Field(alias="redirectRegex")] = None
    """
    RedirectRegex holds the redirect regex middleware configuration.
    This middleware redirects a request using regex matching and replacement.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectregex/#regex
    """
    redirect_scheme: Annotated[Optional[RedirectScheme], Field(alias="redirectScheme")] = None
    """
    RedirectScheme holds the redirect scheme middleware configuration.
    This middleware redirects requests from a scheme/port to another.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/redirectscheme/
    """
    replace_path: Annotated[Optional[ReplacePath], Field(alias="replacePath")] = None
    """
    ReplacePath holds the replace path middleware configuration.
    This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepath/
    """
    replace_path_regex: Annotated[Optional[ReplacePathRegex], Field(alias="replacePathRegex")] = (
        None
    )
    """
    ReplacePathRegex holds the replace path regex middleware configuration.
    This middleware replaces the path of a URL using regex matching and replacement.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/replacepathregex/
    """
    retry: Optional[Retry] = None
    """
    Retry holds the retry middleware configuration.
    This middleware reissues requests a given number of times to a backend server if that server does not reply.
    As soon as the server answers, the middleware stops retrying, regardless of the response status.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/retry/
    """
    strip_prefix: Annotated[Optional[StripPrefix], Field(alias="stripPrefix")] = None
    """
    StripPrefix holds the strip prefix middleware configuration.
    This middleware removes the specified prefixes from the URL path.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefix/
    """
    strip_prefix_regex: Annotated[Optional[StripPrefixRegex], Field(alias="stripPrefixRegex")] = (
        None
    )
    """
    StripPrefixRegex holds the strip prefix regex middleware configuration.
    This middleware removes the matching prefixes from the URL path.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/http/stripprefixregex/
    """


class InFlightConn(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InFlightConn"]:
            return InFlightConn

        def build(self) -> "InFlightConn":
            return InFlightConn(**self._attrs)

        def amount(self, value: Optional[int], /) -> Self:
            """
            Amount defines the maximum amount of allowed simultaneous connections.
            The middleware closes the connection if there are already amount connections opened.
            """
            return self._set("amount", value)

    class BuilderContext(BuilderContextBase["InFlightConn.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InFlightConn.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InFlightConn."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InFlightConn", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InFlightConn.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    amount: Annotated[Optional[int], Field(ge=0)] = None
    """
    Amount defines the maximum amount of allowed simultaneous connections.
    The middleware closes the connection if there are already amount connections opened.
    """


class IpAllowListModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpAllowListModel"]:
            return IpAllowListModel

        def build(self) -> "IpAllowListModel":
            return IpAllowListModel(**self._attrs)

        def source_range(self, value: Optional[List[str]], /) -> Self:
            """
            SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
            """
            return self._set("source_range", value)

    class BuilderContext(BuilderContextBase["IpAllowListModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpAllowListModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpAllowListModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpAllowListModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpAllowListModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source_range: Annotated[Optional[List[str]], Field(alias="sourceRange")] = None
    """
    SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
    """


class IpWhiteListModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IpWhiteListModel"]:
            return IpWhiteListModel

        def build(self) -> "IpWhiteListModel":
            return IpWhiteListModel(**self._attrs)

        def source_range(self, value: Optional[List[str]], /) -> Self:
            """
            SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
            """
            return self._set("source_range", value)

    class BuilderContext(BuilderContextBase["IpWhiteListModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IpWhiteListModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IpWhiteListModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IpWhiteListModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IpWhiteListModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    source_range: Annotated[Optional[List[str]], Field(alias="sourceRange")] = None
    """
    SourceRange defines the allowed IPs (or ranges of allowed IPs by using CIDR notation).
    """


class MiddlewareTCPSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareTCPSpec"]:
            return MiddlewareTCPSpec

        def build(self) -> "MiddlewareTCPSpec":
            return MiddlewareTCPSpec(**self._attrs)

        @overload
        def in_flight_conn(
            self, value_or_callback: Optional[InFlightConn], /
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def in_flight_conn(
            self,
            value_or_callback: Callable[
                [InFlightConn.Builder], InFlightConn.Builder | InFlightConn
            ],
            /,
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def in_flight_conn(
            self, value_or_callback: Never = ...
        ) -> "InFlightConn.BuilderContext": ...

        def in_flight_conn(self, value_or_callback=None, /):
            """
            InFlightConn defines the InFlightConn middleware configuration.
            """
            if self._in_context and value_or_callback is None:
                context = InFlightConn.BuilderContext()
                context._parent_builder = self
                context._field_name = "in_flight_conn"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InFlightConn.builder())
                if isinstance(output, InFlightConn.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("in_flight_conn", value)

        @overload
        def ip_allow_list(
            self, value_or_callback: Optional[IpAllowListModel], /
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def ip_allow_list(
            self,
            value_or_callback: Callable[
                [IpAllowListModel.Builder], IpAllowListModel.Builder | IpAllowListModel
            ],
            /,
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def ip_allow_list(
            self, value_or_callback: Never = ...
        ) -> "IpAllowListModel.BuilderContext": ...

        def ip_allow_list(self, value_or_callback=None, /):
            """
            IPAllowList defines the IPAllowList middleware configuration.
            This middleware accepts/refuses connections based on the client IP.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/ipallowlist/
            """
            if self._in_context and value_or_callback is None:
                context = IpAllowListModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_allow_list"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpAllowListModel.builder())
                if isinstance(output, IpAllowListModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_allow_list", value)

        @overload
        def ip_white_list(
            self, value_or_callback: Optional[IpWhiteListModel], /
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def ip_white_list(
            self,
            value_or_callback: Callable[
                [IpWhiteListModel.Builder], IpWhiteListModel.Builder | IpWhiteListModel
            ],
            /,
        ) -> "MiddlewareTCPSpec.Builder": ...

        @overload
        def ip_white_list(
            self, value_or_callback: Never = ...
        ) -> "IpWhiteListModel.BuilderContext": ...

        def ip_white_list(self, value_or_callback=None, /):
            """
            IPWhiteList defines the IPWhiteList middleware configuration.
            This middleware accepts/refuses connections based on the client IP.
            Deprecated: please use IPAllowList instead.
            More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/ipwhitelist/
            """
            if self._in_context and value_or_callback is None:
                context = IpWhiteListModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "ip_white_list"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IpWhiteListModel.builder())
                if isinstance(output, IpWhiteListModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ip_white_list", value)

    class BuilderContext(BuilderContextBase["MiddlewareTCPSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareTCPSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareTCPSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareTCPSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareTCPSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    in_flight_conn: Annotated[Optional[InFlightConn], Field(alias="inFlightConn")] = None
    """
    InFlightConn defines the InFlightConn middleware configuration.
    """
    ip_allow_list: Annotated[Optional[IpAllowListModel], Field(alias="ipAllowList")] = None
    """
    IPAllowList defines the IPAllowList middleware configuration.
    This middleware accepts/refuses connections based on the client IP.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/ipallowlist/
    """
    ip_white_list: Annotated[Optional[IpWhiteListModel], Field(alias="ipWhiteList")] = None
    """
    IPWhiteList defines the IPWhiteList middleware configuration.
    This middleware accepts/refuses connections based on the client IP.
    Deprecated: please use IPAllowList instead.
    More info: https://doc.traefik.io/traefik/v3.4/middlewares/tcp/ipwhitelist/
    """


class DialTimeoutModel1(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeoutModel1":
            value = cast(int, self._value)
            return DialTimeoutModel1(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """

    class BuilderContext(BuilderContextBase["DialTimeoutModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeoutModel1.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeoutModel1."""
        return cls.BuilderContext()


class DialTimeoutModel2(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeoutModel2":
            value = cast(str, self._value)
            return DialTimeoutModel2(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """

    class BuilderContext(BuilderContextBase["DialTimeoutModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeoutModel2.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeoutModel2."""
        return cls.BuilderContext()


class IdleConnTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
            """
            self._value = value
            return self

        def build(self) -> "IdleConnTimeout":
            value = cast(int, self._value)
            return IdleConnTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
    """

    class BuilderContext(BuilderContextBase["IdleConnTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IdleConnTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IdleConnTimeout."""
        return cls.BuilderContext()


class IdleConnTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
            """
            self._value = value
            return self

        def build(self) -> "IdleConnTimeoutModel":
            value = cast(str, self._value)
            return IdleConnTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
    """

    class BuilderContext(BuilderContextBase["IdleConnTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IdleConnTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IdleConnTimeoutModel."""
        return cls.BuilderContext()


class PingTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
            """
            self._value = value
            return self

        def build(self) -> "PingTimeout":
            value = cast(int, self._value)
            return PingTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
    """

    class BuilderContext(BuilderContextBase["PingTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingTimeout."""
        return cls.BuilderContext()


class PingTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
            """
            self._value = value
            return self

        def build(self) -> "PingTimeoutModel":
            value = cast(str, self._value)
            return PingTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
    """

    class BuilderContext(BuilderContextBase["PingTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PingTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PingTimeoutModel."""
        return cls.BuilderContext()


class ReadIdleTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
            """
            self._value = value
            return self

        def build(self) -> "ReadIdleTimeout":
            value = cast(int, self._value)
            return ReadIdleTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
    """

    class BuilderContext(BuilderContextBase["ReadIdleTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadIdleTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadIdleTimeout."""
        return cls.BuilderContext()


class ReadIdleTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
            """
            self._value = value
            return self

        def build(self) -> "ReadIdleTimeoutModel":
            value = cast(str, self._value)
            return ReadIdleTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
    """

    class BuilderContext(BuilderContextBase["ReadIdleTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadIdleTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadIdleTimeoutModel."""
        return cls.BuilderContext()


class ResponseHeaderTimeout(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
            """
            self._value = value
            return self

        def build(self) -> "ResponseHeaderTimeout":
            value = cast(int, self._value)
            return ResponseHeaderTimeout(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
    """

    class BuilderContext(BuilderContextBase["ResponseHeaderTimeout.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResponseHeaderTimeout.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResponseHeaderTimeout."""
        return cls.BuilderContext()


class ResponseHeaderTimeoutModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
            """
            self._value = value
            return self

        def build(self) -> "ResponseHeaderTimeoutModel":
            value = cast(str, self._value)
            return ResponseHeaderTimeoutModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
    """

    class BuilderContext(BuilderContextBase["ResponseHeaderTimeoutModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResponseHeaderTimeoutModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResponseHeaderTimeoutModel."""
        return cls.BuilderContext()


class ForwardingTimeouts(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ForwardingTimeouts"]:
            return ForwardingTimeouts

        def build(self) -> "ForwardingTimeouts":
            return ForwardingTimeouts(**self._attrs)

        def dial_timeout(
            self, value: Optional[Union[DialTimeoutModel1, DialTimeoutModel2]], /
        ) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            return self._set("dial_timeout", value)

        def idle_conn_timeout(
            self, value: Optional[Union[IdleConnTimeout, IdleConnTimeoutModel]], /
        ) -> Self:
            """
            IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
            """
            return self._set("idle_conn_timeout", value)

        def ping_timeout(self, value: Optional[Union[PingTimeout, PingTimeoutModel]], /) -> Self:
            """
            PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
            """
            return self._set("ping_timeout", value)

        def read_idle_timeout(
            self, value: Optional[Union[ReadIdleTimeout, ReadIdleTimeoutModel]], /
        ) -> Self:
            """
            ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
            """
            return self._set("read_idle_timeout", value)

        def response_header_timeout(
            self,
            value: Optional[Union[ResponseHeaderTimeout, ResponseHeaderTimeoutModel]],
            /,
        ) -> Self:
            """
            ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
            """
            return self._set("response_header_timeout", value)

    class BuilderContext(BuilderContextBase["ForwardingTimeouts.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ForwardingTimeouts.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ForwardingTimeouts."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ForwardingTimeouts", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ForwardingTimeouts.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dial_timeout: Annotated[
        Optional[Union[DialTimeoutModel1, DialTimeoutModel2]],
        Field(alias="dialTimeout"),
    ] = None
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """
    idle_conn_timeout: Annotated[
        Optional[Union[IdleConnTimeout, IdleConnTimeoutModel]],
        Field(alias="idleConnTimeout"),
    ] = None
    """
    IdleConnTimeout is the maximum period for which an idle HTTP keep-alive connection will remain open before closing itself.
    """
    ping_timeout: Annotated[
        Optional[Union[PingTimeout, PingTimeoutModel]], Field(alias="pingTimeout")
    ] = None
    """
    PingTimeout is the timeout after which the HTTP/2 connection will be closed if a response to ping is not received.
    """
    read_idle_timeout: Annotated[
        Optional[Union[ReadIdleTimeout, ReadIdleTimeoutModel]],
        Field(alias="readIdleTimeout"),
    ] = None
    """
    ReadIdleTimeout is the timeout after which a health check using ping frame will be carried out if no frame is received on the HTTP/2 connection.
    """
    response_header_timeout: Annotated[
        Optional[Union[ResponseHeaderTimeout, ResponseHeaderTimeoutModel]],
        Field(alias="responseHeaderTimeout"),
    ] = None
    """
    ResponseHeaderTimeout is the amount of time to wait for a server's response headers after fully writing the request (including its body, if any).
    """


class RootCA(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["RootCA"]:
            return RootCA

        def build(self) -> "RootCA":
            return RootCA(**self._attrs)

        def config_map(self, value: Optional[str], /) -> Self:
            """
            ConfigMap defines the name of a ConfigMap that holds a CA certificate.
            The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
            """
            return self._set("config_map", value)

        def secret(self, value: Optional[str], /) -> Self:
            """
            Secret defines the name of a Secret that holds a CA certificate.
            The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
            """
            return self._set("secret", value)

    class BuilderContext(BuilderContextBase["RootCA.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = RootCA.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for RootCA."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["RootCA", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use RootCA.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map: Annotated[Optional[str], Field(alias="configMap")] = None
    """
    ConfigMap defines the name of a ConfigMap that holds a CA certificate.
    The referenced ConfigMap must contain a certificate under either a tls.ca or a ca.crt key.
    """
    secret: Optional[str] = None
    """
    Secret defines the name of a Secret that holds a CA certificate.
    The referenced Secret must contain a certificate under either a tls.ca or a ca.crt key.
    """


class Spiffe(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Spiffe"]:
            return Spiffe

        def build(self) -> "Spiffe":
            return Spiffe(**self._attrs)

        def ids(self, value: Optional[List[str]], /) -> Self:
            """
            IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
            """
            return self._set("ids", value)

        def trust_domain(self, value: Optional[str], /) -> Self:
            """
            TrustDomain defines the allowed SPIFFE trust domain.
            """
            return self._set("trust_domain", value)

    class BuilderContext(BuilderContextBase["Spiffe.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Spiffe.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Spiffe."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Spiffe", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Spiffe.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ids: Optional[List[str]] = None
    """
    IDs defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain).
    """
    trust_domain: Annotated[Optional[str], Field(alias="trustDomain")] = None
    """
    TrustDomain defines the allowed SPIFFE trust domain.
    """


class ServersTransportSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServersTransportSpec"]:
            return ServersTransportSpec

        def build(self) -> "ServersTransportSpec":
            return ServersTransportSpec(**self._attrs)

        def certificates_secrets(self, value: Optional[List[str]], /) -> Self:
            """
            CertificatesSecrets defines a list of secret storing client certificates for mTLS.
            """
            return self._set("certificates_secrets", value)

        def disable_http2(self, value: Optional[bool], /) -> Self:
            """
            DisableHTTP2 disables HTTP/2 for connections with backend servers.
            """
            return self._set("disable_http2", value)

        @overload
        def forwarding_timeouts(
            self, value_or_callback: Optional[ForwardingTimeouts], /
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def forwarding_timeouts(
            self,
            value_or_callback: Callable[
                [ForwardingTimeouts.Builder],
                ForwardingTimeouts.Builder | ForwardingTimeouts,
            ],
            /,
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def forwarding_timeouts(
            self, value_or_callback: Never = ...
        ) -> "ForwardingTimeouts.BuilderContext": ...

        def forwarding_timeouts(self, value_or_callback=None, /):
            """
            ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
            """
            if self._in_context and value_or_callback is None:
                context = ForwardingTimeouts.BuilderContext()
                context._parent_builder = self
                context._field_name = "forwarding_timeouts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ForwardingTimeouts.builder())
                if isinstance(output, ForwardingTimeouts.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("forwarding_timeouts", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            InsecureSkipVerify disables SSL certificate verification.
            """
            return self._set("insecure_skip_verify", value)

        def max_idle_conns_per_host(self, value: Optional[int], /) -> Self:
            """
            MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
            """
            return self._set("max_idle_conns_per_host", value)

        def peer_cert_uri(self, value: Optional[str], /) -> Self:
            """
            PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
            """
            return self._set("peer_cert_uri", value)

        @overload
        def root_c_as(
            self, value_or_callback: List[RootCA], /
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def root_c_as(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RootCA, RootCA.Builder]],
                GenericListBuilder[RootCA, RootCA.Builder] | List[RootCA],
            ],
            /,
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def root_c_as(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RootCA.Builder]: ...

        def root_c_as(self, value_or_callback=None, /):
            """
            RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RootCA.Builder]()
                context._parent_builder = self
                context._field_name = "root_c_as"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RootCA.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("root_c_as", value)

        def root_c_as_secrets(self, value: Optional[List[str]], /) -> Self:
            """
            RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
            Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
            """
            return self._set("root_c_as_secrets", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            ServerName defines the server name used to contact the server.
            """
            return self._set("server_name", value)

        @overload
        def spiffe(
            self, value_or_callback: Optional[Spiffe], /
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def spiffe(
            self,
            value_or_callback: Callable[[Spiffe.Builder], Spiffe.Builder | Spiffe],
            /,
        ) -> "ServersTransportSpec.Builder": ...

        @overload
        def spiffe(self, value_or_callback: Never = ...) -> "Spiffe.BuilderContext": ...

        def spiffe(self, value_or_callback=None, /):
            """
            Spiffe defines the SPIFFE configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Spiffe.BuilderContext()
                context._parent_builder = self
                context._field_name = "spiffe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spiffe.builder())
                if isinstance(output, Spiffe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spiffe", value)

    class BuilderContext(BuilderContextBase["ServersTransportSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServersTransportSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServersTransportSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServersTransportSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServersTransportSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificates_secrets: Annotated[Optional[List[str]], Field(alias="certificatesSecrets")] = None
    """
    CertificatesSecrets defines a list of secret storing client certificates for mTLS.
    """
    disable_http2: Annotated[Optional[bool], Field(alias="disableHTTP2")] = None
    """
    DisableHTTP2 disables HTTP/2 for connections with backend servers.
    """
    forwarding_timeouts: Annotated[
        Optional[ForwardingTimeouts], Field(alias="forwardingTimeouts")
    ] = None
    """
    ForwardingTimeouts defines the timeouts for requests forwarded to the backend servers.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    InsecureSkipVerify disables SSL certificate verification.
    """
    max_idle_conns_per_host: Annotated[Optional[int], Field(alias="maxIdleConnsPerHost", ge=0)] = (
        None
    )
    """
    MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
    """
    peer_cert_uri: Annotated[Optional[str], Field(alias="peerCertURI")] = None
    """
    PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
    """
    root_c_as: Annotated[Optional[List[RootCA]], Field(alias="rootCAs")] = None
    """
    RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
    """
    root_c_as_secrets: Annotated[Optional[List[str]], Field(alias="rootCAsSecrets")] = None
    """
    RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
    Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    ServerName defines the server name used to contact the server.
    """
    spiffe: Optional[Spiffe] = None
    """
    Spiffe defines the SPIFFE configuration.
    """


class DialKeepAlive(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
            """
            self._value = value
            return self

        def build(self) -> "DialKeepAlive":
            value = cast(int, self._value)
            return DialKeepAlive(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
    """

    class BuilderContext(BuilderContextBase["DialKeepAlive.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialKeepAlive.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialKeepAlive."""
        return cls.BuilderContext()


class DialKeepAliveModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
            """
            self._value = value
            return self

        def build(self) -> "DialKeepAliveModel":
            value = cast(str, self._value)
            return DialKeepAliveModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
    """

    class BuilderContext(BuilderContextBase["DialKeepAliveModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialKeepAliveModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialKeepAliveModel."""
        return cls.BuilderContext()


class DialTimeoutModel3(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeoutModel3":
            value = cast(int, self._value)
            return DialTimeoutModel3(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """

    class BuilderContext(BuilderContextBase["DialTimeoutModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeoutModel3.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeoutModel3."""
        return cls.BuilderContext()


class DialTimeoutModel4(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            self._value = value
            return self

        def build(self) -> "DialTimeoutModel4":
            value = cast(str, self._value)
            return DialTimeoutModel4(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """

    class BuilderContext(BuilderContextBase["DialTimeoutModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DialTimeoutModel4.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DialTimeoutModel4."""
        return cls.BuilderContext()


class TerminationDelay(RootModel[int]):
    class Builder(BaseBuilder):
        _value: int | None = None

        def root(self, value: int, /) -> Self:
            """
            TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
            """
            self._value = value
            return self

        def __call__(self, value: int, /) -> Self:
            """
            TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
            """
            self._value = value
            return self

        def build(self) -> "TerminationDelay":
            value = cast(int, self._value)
            return TerminationDelay(value)

    root: Annotated[int, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
    """

    class BuilderContext(BuilderContextBase["TerminationDelay.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TerminationDelay.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TerminationDelay."""
        return cls.BuilderContext()


class TerminationDelayModel(RootModel[str]):
    class Builder(BaseBuilder):
        _value: str | None = None

        def root(self, value: str, /) -> Self:
            """
            TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
            """
            self._value = value
            return self

        def __call__(self, value: str, /) -> Self:
            """
            TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
            """
            self._value = value
            return self

        def build(self) -> "TerminationDelayModel":
            value = cast(str, self._value)
            return TerminationDelayModel(value)

    root: Annotated[str, Field(pattern="^([0-9]+(ns|us|s|ms|s|m|h)?)+$")]
    """
    TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
    """

    class BuilderContext(BuilderContextBase["TerminationDelayModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TerminationDelayModel.Builder()
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TerminationDelayModel."""
        return cls.BuilderContext()


class TlsModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TlsModel3"]:
            return TlsModel3

        def build(self) -> "TlsModel3":
            return TlsModel3(**self._attrs)

        def certificates_secrets(self, value: Optional[List[str]], /) -> Self:
            """
            CertificatesSecrets defines a list of secret storing client certificates for mTLS.
            """
            return self._set("certificates_secrets", value)

        def insecure_skip_verify(self, value: Optional[bool], /) -> Self:
            """
            InsecureSkipVerify disables TLS certificate verification.
            """
            return self._set("insecure_skip_verify", value)

        def peer_cert_uri(self, value: Optional[str], /) -> Self:
            """
            MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
            PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
            """
            return self._set("peer_cert_uri", value)

        @overload
        def root_c_as(self, value_or_callback: List[RootCA], /) -> "TlsModel3.Builder": ...

        @overload
        def root_c_as(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[RootCA, RootCA.Builder]],
                GenericListBuilder[RootCA, RootCA.Builder] | List[RootCA],
            ],
            /,
        ) -> "TlsModel3.Builder": ...

        @overload
        def root_c_as(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[RootCA.Builder]: ...

        def root_c_as(self, value_or_callback=None, /):
            """
            RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[RootCA.Builder]()
                context._parent_builder = self
                context._field_name = "root_c_as"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(RootCA.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("root_c_as", value)

        def root_c_as_secrets(self, value: Optional[List[str]], /) -> Self:
            """
            RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
            Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
            """
            return self._set("root_c_as_secrets", value)

        def server_name(self, value: Optional[str], /) -> Self:
            """
            ServerName defines the server name used to contact the server.
            """
            return self._set("server_name", value)

        @overload
        def spiffe(self, value_or_callback: Optional[Spiffe], /) -> "TlsModel3.Builder": ...

        @overload
        def spiffe(
            self,
            value_or_callback: Callable[[Spiffe.Builder], Spiffe.Builder | Spiffe],
            /,
        ) -> "TlsModel3.Builder": ...

        @overload
        def spiffe(self, value_or_callback: Never = ...) -> "Spiffe.BuilderContext": ...

        def spiffe(self, value_or_callback=None, /):
            """
            Spiffe defines the SPIFFE configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Spiffe.BuilderContext()
                context._parent_builder = self
                context._field_name = "spiffe"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Spiffe.builder())
                if isinstance(output, Spiffe.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spiffe", value)

    class BuilderContext(BuilderContextBase["TlsModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TlsModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TlsModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TlsModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TlsModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificates_secrets: Annotated[Optional[List[str]], Field(alias="certificatesSecrets")] = None
    """
    CertificatesSecrets defines a list of secret storing client certificates for mTLS.
    """
    insecure_skip_verify: Annotated[Optional[bool], Field(alias="insecureSkipVerify")] = None
    """
    InsecureSkipVerify disables TLS certificate verification.
    """
    peer_cert_uri: Annotated[Optional[str], Field(alias="peerCertURI")] = None
    """
    MaxIdleConnsPerHost controls the maximum idle (keep-alive) to keep per-host.
    PeerCertURI defines the peer cert URI used to match against SAN URI during the peer certificate verification.
    """
    root_c_as: Annotated[Optional[List[RootCA]], Field(alias="rootCAs")] = None
    """
    RootCAs defines a list of CA certificate Secrets or ConfigMaps used to validate server certificates.
    """
    root_c_as_secrets: Annotated[Optional[List[str]], Field(alias="rootCAsSecrets")] = None
    """
    RootCAsSecrets defines a list of CA secret used to validate self-signed certificate.
    Deprecated: RootCAsSecrets is deprecated, please use the RootCAs option instead.
    """
    server_name: Annotated[Optional[str], Field(alias="serverName")] = None
    """
    ServerName defines the server name used to contact the server.
    """
    spiffe: Optional[Spiffe] = None
    """
    Spiffe defines the SPIFFE configuration.
    """


class ServersTransportTCPSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServersTransportTCPSpec"]:
            return ServersTransportTCPSpec

        def build(self) -> "ServersTransportTCPSpec":
            return ServersTransportTCPSpec(**self._attrs)

        def dial_keep_alive(
            self, value: Optional[Union[DialKeepAlive, DialKeepAliveModel]], /
        ) -> Self:
            """
            DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
            """
            return self._set("dial_keep_alive", value)

        def dial_timeout(
            self, value: Optional[Union[DialTimeoutModel3, DialTimeoutModel4]], /
        ) -> Self:
            """
            DialTimeout is the amount of time to wait until a connection to a backend server can be established.
            """
            return self._set("dial_timeout", value)

        def termination_delay(
            self, value: Optional[Union[TerminationDelay, TerminationDelayModel]], /
        ) -> Self:
            """
            TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
            """
            return self._set("termination_delay", value)

        @overload
        def tls(
            self, value_or_callback: Optional[TlsModel3], /
        ) -> "ServersTransportTCPSpec.Builder": ...

        @overload
        def tls(
            self,
            value_or_callback: Callable[[TlsModel3.Builder], TlsModel3.Builder | TlsModel3],
            /,
        ) -> "ServersTransportTCPSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "TlsModel3.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            """
            TLS defines the TLS configuration
            """
            if self._in_context and value_or_callback is None:
                context = TlsModel3.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TlsModel3.builder())
                if isinstance(output, TlsModel3.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

    class BuilderContext(BuilderContextBase["ServersTransportTCPSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServersTransportTCPSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServersTransportTCPSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServersTransportTCPSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServersTransportTCPSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    dial_keep_alive: Annotated[
        Optional[Union[DialKeepAlive, DialKeepAliveModel]], Field(alias="dialKeepAlive")
    ] = None
    """
    DialKeepAlive is the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled.
    """
    dial_timeout: Annotated[
        Optional[Union[DialTimeoutModel3, DialTimeoutModel4]],
        Field(alias="dialTimeout"),
    ] = None
    """
    DialTimeout is the amount of time to wait until a connection to a backend server can be established.
    """
    termination_delay: Annotated[
        Optional[Union[TerminationDelay, TerminationDelayModel]],
        Field(alias="terminationDelay"),
    ] = None
    """
    TerminationDelay defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability.
    """
    tls: Optional[TlsModel3] = None
    """
    TLS defines the TLS configuration
    """


class ClientAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ClientAuth"]:
            return ClientAuth

        def build(self) -> "ClientAuth":
            return ClientAuth(**self._attrs)

        def client_auth_type(
            self,
            value: Optional[
                Literal[
                    "NoClientCert",
                    "RequestClientCert",
                    "RequireAnyClientCert",
                    "VerifyClientCertIfGiven",
                    "RequireAndVerifyClientCert",
                ]
            ],
            /,
        ) -> Self:
            """
            ClientAuthType defines the client authentication type to apply.
            """
            return self._set("client_auth_type", value)

        def secret_names(self, value: Optional[List[str]], /) -> Self:
            """
            SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
            """
            return self._set("secret_names", value)

    class BuilderContext(BuilderContextBase["ClientAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ClientAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ClientAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ClientAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ClientAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    client_auth_type: Annotated[
        Optional[
            Literal[
                "NoClientCert",
                "RequestClientCert",
                "RequireAnyClientCert",
                "VerifyClientCertIfGiven",
                "RequireAndVerifyClientCert",
            ]
        ],
        Field(alias="clientAuthType"),
    ] = None
    """
    ClientAuthType defines the client authentication type to apply.
    """
    secret_names: Annotated[Optional[List[str]], Field(alias="secretNames")] = None
    """
    SecretNames defines the names of the referenced Kubernetes Secret storing certificate details.
    """


class TLSOptionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSOptionSpec"]:
            return TLSOptionSpec

        def build(self) -> "TLSOptionSpec":
            return TLSOptionSpec(**self._attrs)

        def alpn_protocols(self, value: Optional[List[str]], /) -> Self:
            """
            ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
            More info: https://doc.traefik.io/traefik/v3.4/https/tls/#alpn-protocols
            """
            return self._set("alpn_protocols", value)

        def cipher_suites(self, value: Optional[List[str]], /) -> Self:
            """
            CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
            More info: https://doc.traefik.io/traefik/v3.4/https/tls/#cipher-suites
            """
            return self._set("cipher_suites", value)

        @overload
        def client_auth(
            self, value_or_callback: Optional[ClientAuth], /
        ) -> "TLSOptionSpec.Builder": ...

        @overload
        def client_auth(
            self,
            value_or_callback: Callable[[ClientAuth.Builder], ClientAuth.Builder | ClientAuth],
            /,
        ) -> "TLSOptionSpec.Builder": ...

        @overload
        def client_auth(self, value_or_callback: Never = ...) -> "ClientAuth.BuilderContext": ...

        def client_auth(self, value_or_callback=None, /):
            """
            ClientAuth defines the server's policy for TLS Client Authentication.
            """
            if self._in_context and value_or_callback is None:
                context = ClientAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "client_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ClientAuth.builder())
                if isinstance(output, ClientAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("client_auth", value)

        def curve_preferences(self, value: Optional[List[str]], /) -> Self:
            """
            CurvePreferences defines the preferred elliptic curves in a specific order.
            More info: https://doc.traefik.io/traefik/v3.4/https/tls/#curve-preferences
            """
            return self._set("curve_preferences", value)

        def disable_session_tickets(self, value: Optional[bool], /) -> Self:
            """
            DisableSessionTickets disables TLS session resumption via session tickets.
            """
            return self._set("disable_session_tickets", value)

        def max_version(self, value: Optional[str], /) -> Self:
            """
            MaxVersion defines the maximum TLS version that Traefik will accept.
            Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
            Default: None.
            """
            return self._set("max_version", value)

        def min_version(self, value: Optional[str], /) -> Self:
            """
            MinVersion defines the minimum TLS version that Traefik will accept.
            Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
            Default: VersionTLS10.
            """
            return self._set("min_version", value)

        def prefer_server_cipher_suites(self, value: Optional[bool], /) -> Self:
            """
            PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
            It is enabled automatically when minVersion or maxVersion is set.
            Deprecated: https://github.com/golang/go/issues/45430
            """
            return self._set("prefer_server_cipher_suites", value)

        def sni_strict(self, value: Optional[bool], /) -> Self:
            """
            SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
            """
            return self._set("sni_strict", value)

    class BuilderContext(BuilderContextBase["TLSOptionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSOptionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSOptionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSOptionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSOptionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    alpn_protocols: Annotated[Optional[List[str]], Field(alias="alpnProtocols")] = None
    """
    ALPNProtocols defines the list of supported application level protocols for the TLS handshake, in order of preference.
    More info: https://doc.traefik.io/traefik/v3.4/https/tls/#alpn-protocols
    """
    cipher_suites: Annotated[Optional[List[str]], Field(alias="cipherSuites")] = None
    """
    CipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
    More info: https://doc.traefik.io/traefik/v3.4/https/tls/#cipher-suites
    """
    client_auth: Annotated[Optional[ClientAuth], Field(alias="clientAuth")] = None
    """
    ClientAuth defines the server's policy for TLS Client Authentication.
    """
    curve_preferences: Annotated[Optional[List[str]], Field(alias="curvePreferences")] = None
    """
    CurvePreferences defines the preferred elliptic curves in a specific order.
    More info: https://doc.traefik.io/traefik/v3.4/https/tls/#curve-preferences
    """
    disable_session_tickets: Annotated[Optional[bool], Field(alias="disableSessionTickets")] = None
    """
    DisableSessionTickets disables TLS session resumption via session tickets.
    """
    max_version: Annotated[Optional[str], Field(alias="maxVersion")] = None
    """
    MaxVersion defines the maximum TLS version that Traefik will accept.
    Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
    Default: None.
    """
    min_version: Annotated[Optional[str], Field(alias="minVersion")] = None
    """
    MinVersion defines the minimum TLS version that Traefik will accept.
    Possible values: VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13.
    Default: VersionTLS10.
    """
    prefer_server_cipher_suites: Annotated[
        Optional[bool], Field(alias="preferServerCipherSuites")
    ] = None
    """
    PreferServerCipherSuites defines whether the server chooses a cipher suite among his own instead of among the client's.
    It is enabled automatically when minVersion or maxVersion is set.
    Deprecated: https://github.com/golang/go/issues/45430
    """
    sni_strict: Annotated[Optional[bool], Field(alias="sniStrict")] = None
    """
    SniStrict defines whether Traefik allows connections from clients connections that do not specify a server_name extension.
    """


class Certificate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Certificate"]:
            return Certificate

        def build(self) -> "Certificate":
            return Certificate(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["Certificate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Certificate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Certificate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Certificate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Certificate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
    """


class DefaultCertificate(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DefaultCertificate"]:
            return DefaultCertificate

        def build(self) -> "DefaultCertificate":
            return DefaultCertificate(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
            """
            return self._set("secret_name", value)

    class BuilderContext(BuilderContextBase["DefaultCertificate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DefaultCertificate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DefaultCertificate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DefaultCertificate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DefaultCertificate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    SecretName is the name of the referenced Kubernetes Secret to specify the certificate details.
    """


class DefaultGeneratedCert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DefaultGeneratedCert"]:
            return DefaultGeneratedCert

        def build(self) -> "DefaultGeneratedCert":
            return DefaultGeneratedCert(**self._attrs)

        @overload
        def domain(
            self, value_or_callback: Optional[Domain], /
        ) -> "DefaultGeneratedCert.Builder": ...

        @overload
        def domain(
            self,
            value_or_callback: Callable[[Domain.Builder], Domain.Builder | Domain],
            /,
        ) -> "DefaultGeneratedCert.Builder": ...

        @overload
        def domain(self, value_or_callback: Never = ...) -> "Domain.BuilderContext": ...

        def domain(self, value_or_callback=None, /):
            """
            Domain is the domain definition for the DefaultCertificate.
            """
            if self._in_context and value_or_callback is None:
                context = Domain.BuilderContext()
                context._parent_builder = self
                context._field_name = "domain"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Domain.builder())
                if isinstance(output, Domain.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("domain", value)

        def resolver(self, value: Optional[str], /) -> Self:
            """
            Resolver is the name of the resolver that will be used to issue the DefaultCertificate.
            """
            return self._set("resolver", value)

    class BuilderContext(BuilderContextBase["DefaultGeneratedCert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DefaultGeneratedCert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DefaultGeneratedCert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DefaultGeneratedCert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DefaultGeneratedCert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    domain: Optional[Domain] = None
    """
    Domain is the domain definition for the DefaultCertificate.
    """
    resolver: Optional[str] = None
    """
    Resolver is the name of the resolver that will be used to issue the DefaultCertificate.
    """


class TLSStoreSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSStoreSpec"]:
            return TLSStoreSpec

        def build(self) -> "TLSStoreSpec":
            return TLSStoreSpec(**self._attrs)

        @overload
        def certificates(
            self, value_or_callback: List[Certificate], /
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def certificates(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Certificate, Certificate.Builder]],
                GenericListBuilder[Certificate, Certificate.Builder] | List[Certificate],
            ],
            /,
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def certificates(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Certificate.Builder]: ...

        def certificates(self, value_or_callback=None, /):
            """
            Certificates is a list of secret names, each secret holding a key/certificate pair to add to the store.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Certificate.Builder]()
                context._parent_builder = self
                context._field_name = "certificates"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Certificate.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("certificates", value)

        @overload
        def default_certificate(
            self, value_or_callback: Optional[DefaultCertificate], /
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def default_certificate(
            self,
            value_or_callback: Callable[
                [DefaultCertificate.Builder],
                DefaultCertificate.Builder | DefaultCertificate,
            ],
            /,
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def default_certificate(
            self, value_or_callback: Never = ...
        ) -> "DefaultCertificate.BuilderContext": ...

        def default_certificate(self, value_or_callback=None, /):
            """
            DefaultCertificate defines the default certificate configuration.
            """
            if self._in_context and value_or_callback is None:
                context = DefaultCertificate.BuilderContext()
                context._parent_builder = self
                context._field_name = "default_certificate"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DefaultCertificate.builder())
                if isinstance(output, DefaultCertificate.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("default_certificate", value)

        @overload
        def default_generated_cert(
            self, value_or_callback: Optional[DefaultGeneratedCert], /
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def default_generated_cert(
            self,
            value_or_callback: Callable[
                [DefaultGeneratedCert.Builder],
                DefaultGeneratedCert.Builder | DefaultGeneratedCert,
            ],
            /,
        ) -> "TLSStoreSpec.Builder": ...

        @overload
        def default_generated_cert(
            self, value_or_callback: Never = ...
        ) -> "DefaultGeneratedCert.BuilderContext": ...

        def default_generated_cert(self, value_or_callback=None, /):
            """
            DefaultGeneratedCert defines the default generated certificate configuration.
            """
            if self._in_context and value_or_callback is None:
                context = DefaultGeneratedCert.BuilderContext()
                context._parent_builder = self
                context._field_name = "default_generated_cert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DefaultGeneratedCert.builder())
                if isinstance(output, DefaultGeneratedCert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("default_generated_cert", value)

    class BuilderContext(BuilderContextBase["TLSStoreSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSStoreSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSStoreSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSStoreSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSStoreSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    certificates: Optional[List[Certificate]] = None
    """
    Certificates is a list of secret names, each secret holding a key/certificate pair to add to the store.
    """
    default_certificate: Annotated[
        Optional[DefaultCertificate], Field(alias="defaultCertificate")
    ] = None
    """
    DefaultCertificate defines the default certificate configuration.
    """
    default_generated_cert: Annotated[
        Optional[DefaultGeneratedCert], Field(alias="defaultGeneratedCert")
    ] = None
    """
    DefaultGeneratedCert defines the default generated certificate configuration.
    """


class Mirror(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Mirror"]:
            return Mirror

        def build(self) -> "Mirror":
            return Mirror(**self._attrs)

        @overload
        def health_check(self, value_or_callback: Optional[HealthCheck], /) -> "Mirror.Builder": ...

        @overload
        def health_check(
            self,
            value_or_callback: Callable[[HealthCheck.Builder], HealthCheck.Builder | HealthCheck],
            /,
        ) -> "Mirror.Builder": ...

        @overload
        def health_check(self, value_or_callback: Never = ...) -> "HealthCheck.BuilderContext": ...

        def health_check(self, value_or_callback=None, /):
            """
            Healthcheck defines health checks for ExternalName services.
            """
            if self._in_context and value_or_callback is None:
                context = HealthCheck.BuilderContext()
                context._parent_builder = self
                context._field_name = "health_check"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.builder())
                if isinstance(output, HealthCheck.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_check", value)

        def kind(self, value: Optional[Literal["Service", "TraefikService"]], /) -> Self:
            """
            Kind defines the kind of the Service.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service or TraefikService.
            The differentiation between the two is specified in the Kind field.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def pass_host_header(self, value: Optional[bool], /) -> Self:
            """
            PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
            By default, passHostHeader is true.
            """
            return self._set("pass_host_header", value)

        def percent(self, value: Optional[int], /) -> Self:
            """
            Percent defines the part of the traffic to mirror.
            Supported values: 0 to 100.
            """
            return self._set("percent", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        @overload
        def response_forwarding(
            self, value_or_callback: Optional[ResponseForwarding], /
        ) -> "Mirror.Builder": ...

        @overload
        def response_forwarding(
            self,
            value_or_callback: Callable[
                [ResponseForwarding.Builder],
                ResponseForwarding.Builder | ResponseForwarding,
            ],
            /,
        ) -> "Mirror.Builder": ...

        @overload
        def response_forwarding(
            self, value_or_callback: Never = ...
        ) -> "ResponseForwarding.BuilderContext": ...

        def response_forwarding(self, value_or_callback=None, /):
            """
            ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
            """
            if self._in_context and value_or_callback is None:
                context = ResponseForwarding.BuilderContext()
                context._parent_builder = self
                context._field_name = "response_forwarding"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResponseForwarding.builder())
                if isinstance(output, ResponseForwarding.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response_forwarding", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
            It defaults to https when Kubernetes Service port is 443, http otherwise.
            """
            return self._set("scheme", value)

        def servers_transport(self, value: Optional[str], /) -> Self:
            """
            ServersTransport defines the name of ServersTransport resource to use.
            It allows to configure the transport between Traefik and your servers.
            Can only be used on a Kubernetes Service.
            """
            return self._set("servers_transport", value)

        @overload
        def sticky(self, value_or_callback: Optional[Sticky], /) -> "Mirror.Builder": ...

        @overload
        def sticky(
            self,
            value_or_callback: Callable[[Sticky.Builder], Sticky.Builder | Sticky],
            /,
        ) -> "Mirror.Builder": ...

        @overload
        def sticky(self, value_or_callback: Never = ...) -> "Sticky.BuilderContext": ...

        def sticky(self, value_or_callback=None, /):
            """
            Sticky defines the sticky sessions configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
            """
            if self._in_context and value_or_callback is None:
                context = Sticky.BuilderContext()
                context._parent_builder = self
                context._field_name = "sticky"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sticky.builder())
                if isinstance(output, Sticky.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky", value)

        def strategy(self, value: Optional[Literal["wrr", "p2c", "RoundRobin"]], /) -> Self:
            """
            Strategy defines the load balancing strategy between the servers.
            Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
            RoundRobin value is deprecated and supported for backward compatibility.
            """
            return self._set("strategy", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight and should only be specified when Name references a TraefikService object
            (and to be precise, one that embeds a Weighted Round Robin).
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Mirror.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Mirror.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Mirror."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Mirror", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Mirror.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    health_check: Annotated[Optional[HealthCheck], Field(alias="healthCheck")] = None
    """
    Healthcheck defines health checks for ExternalName services.
    """
    kind: Optional[Literal["Service", "TraefikService"]] = None
    """
    Kind defines the kind of the Service.
    """
    name: str
    """
    Name defines the name of the referenced Kubernetes Service or TraefikService.
    The differentiation between the two is specified in the Kind field.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    pass_host_header: Annotated[Optional[bool], Field(alias="passHostHeader")] = None
    """
    PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
    By default, passHostHeader is true.
    """
    percent: Optional[int] = None
    """
    Percent defines the part of the traffic to mirror.
    Supported values: 0 to 100.
    """
    port: Optional[Union[int, str]] = None
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    response_forwarding: Annotated[
        Optional[ResponseForwarding], Field(alias="responseForwarding")
    ] = None
    """
    ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
    """
    scheme: Optional[str] = None
    """
    Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
    It defaults to https when Kubernetes Service port is 443, http otherwise.
    """
    servers_transport: Annotated[Optional[str], Field(alias="serversTransport")] = None
    """
    ServersTransport defines the name of ServersTransport resource to use.
    It allows to configure the transport between Traefik and your servers.
    Can only be used on a Kubernetes Service.
    """
    sticky: Optional[Sticky] = None
    """
    Sticky defines the sticky sessions configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
    """
    strategy: Optional[Literal["wrr", "p2c", "RoundRobin"]] = None
    """
    Strategy defines the load balancing strategy between the servers.
    Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
    RoundRobin value is deprecated and supported for backward compatibility.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight and should only be specified when Name references a TraefikService object
    (and to be precise, one that embeds a Weighted Round Robin).
    """


class Mirroring(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Mirroring"]:
            return Mirroring

        def build(self) -> "Mirroring":
            return Mirroring(**self._attrs)

        @overload
        def health_check(
            self, value_or_callback: Optional[HealthCheck], /
        ) -> "Mirroring.Builder": ...

        @overload
        def health_check(
            self,
            value_or_callback: Callable[[HealthCheck.Builder], HealthCheck.Builder | HealthCheck],
            /,
        ) -> "Mirroring.Builder": ...

        @overload
        def health_check(self, value_or_callback: Never = ...) -> "HealthCheck.BuilderContext": ...

        def health_check(self, value_or_callback=None, /):
            """
            Healthcheck defines health checks for ExternalName services.
            """
            if self._in_context and value_or_callback is None:
                context = HealthCheck.BuilderContext()
                context._parent_builder = self
                context._field_name = "health_check"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HealthCheck.builder())
                if isinstance(output, HealthCheck.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("health_check", value)

        def kind(self, value: Optional[Literal["Service", "TraefikService"]], /) -> Self:
            """
            Kind defines the kind of the Service.
            """
            return self._set("kind", value)

        def max_body_size(self, value: Optional[int], /) -> Self:
            """
            MaxBodySize defines the maximum size allowed for the body of the request.
            If the body is larger, the request is not mirrored.
            Default value is -1, which means unlimited size.
            """
            return self._set("max_body_size", value)

        def mirror_body(self, value: Optional[bool], /) -> Self:
            """
            MirrorBody defines whether the body of the request should be mirrored.
            Default value is true.
            """
            return self._set("mirror_body", value)

        @overload
        def mirrors(self, value_or_callback: List[Mirror], /) -> "Mirroring.Builder": ...

        @overload
        def mirrors(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Mirror, Mirror.Builder]],
                GenericListBuilder[Mirror, Mirror.Builder] | List[Mirror],
            ],
            /,
        ) -> "Mirroring.Builder": ...

        @overload
        def mirrors(self, value_or_callback: Never = ...) -> ListBuilderContext[Mirror.Builder]: ...

        def mirrors(self, value_or_callback=None, /):
            """
            Mirrors defines the list of mirrors where Traefik will duplicate the traffic.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Mirror.Builder]()
                context._parent_builder = self
                context._field_name = "mirrors"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mirror.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("mirrors", value)

        def name(self, value: str, /) -> Self:
            """
            Name defines the name of the referenced Kubernetes Service or TraefikService.
            The differentiation between the two is specified in the Kind field.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
            """
            return self._set("namespace", value)

        def native_lb(self, value: Optional[bool], /) -> Self:
            """
            NativeLB controls, when creating the load-balancer,
            whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
            The Kubernetes Service itself does load-balance to the pods.
            By default, NativeLB is false.
            """
            return self._set("native_lb", value)

        def node_port_lb(self, value: Optional[bool], /) -> Self:
            """
            NodePortLB controls, when creating the load-balancer,
            whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
            It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
            By default, NodePortLB is false.
            """
            return self._set("node_port_lb", value)

        def pass_host_header(self, value: Optional[bool], /) -> Self:
            """
            PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
            By default, passHostHeader is true.
            """
            return self._set("pass_host_header", value)

        def port(self, value: Optional[Union[int, str]], /) -> Self:
            """
            Port defines the port of a Kubernetes Service.
            This can be a reference to a named port.
            """
            return self._set("port", value)

        @overload
        def response_forwarding(
            self, value_or_callback: Optional[ResponseForwarding], /
        ) -> "Mirroring.Builder": ...

        @overload
        def response_forwarding(
            self,
            value_or_callback: Callable[
                [ResponseForwarding.Builder],
                ResponseForwarding.Builder | ResponseForwarding,
            ],
            /,
        ) -> "Mirroring.Builder": ...

        @overload
        def response_forwarding(
            self, value_or_callback: Never = ...
        ) -> "ResponseForwarding.BuilderContext": ...

        def response_forwarding(self, value_or_callback=None, /):
            """
            ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
            """
            if self._in_context and value_or_callback is None:
                context = ResponseForwarding.BuilderContext()
                context._parent_builder = self
                context._field_name = "response_forwarding"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResponseForwarding.builder())
                if isinstance(output, ResponseForwarding.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("response_forwarding", value)

        def scheme(self, value: Optional[str], /) -> Self:
            """
            Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
            It defaults to https when Kubernetes Service port is 443, http otherwise.
            """
            return self._set("scheme", value)

        def servers_transport(self, value: Optional[str], /) -> Self:
            """
            ServersTransport defines the name of ServersTransport resource to use.
            It allows to configure the transport between Traefik and your servers.
            Can only be used on a Kubernetes Service.
            """
            return self._set("servers_transport", value)

        @overload
        def sticky(self, value_or_callback: Optional[Sticky], /) -> "Mirroring.Builder": ...

        @overload
        def sticky(
            self,
            value_or_callback: Callable[[Sticky.Builder], Sticky.Builder | Sticky],
            /,
        ) -> "Mirroring.Builder": ...

        @overload
        def sticky(self, value_or_callback: Never = ...) -> "Sticky.BuilderContext": ...

        def sticky(self, value_or_callback=None, /):
            """
            Sticky defines the sticky sessions configuration.
            More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
            """
            if self._in_context and value_or_callback is None:
                context = Sticky.BuilderContext()
                context._parent_builder = self
                context._field_name = "sticky"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sticky.builder())
                if isinstance(output, Sticky.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky", value)

        def strategy(self, value: Optional[Literal["wrr", "p2c", "RoundRobin"]], /) -> Self:
            """
            Strategy defines the load balancing strategy between the servers.
            Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
            RoundRobin value is deprecated and supported for backward compatibility.
            """
            return self._set("strategy", value)

        def weight(self, value: Optional[int], /) -> Self:
            """
            Weight defines the weight and should only be specified when Name references a TraefikService object
            (and to be precise, one that embeds a Weighted Round Robin).
            """
            return self._set("weight", value)

    class BuilderContext(BuilderContextBase["Mirroring.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Mirroring.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Mirroring."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Mirroring", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Mirroring.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    health_check: Annotated[Optional[HealthCheck], Field(alias="healthCheck")] = None
    """
    Healthcheck defines health checks for ExternalName services.
    """
    kind: Optional[Literal["Service", "TraefikService"]] = None
    """
    Kind defines the kind of the Service.
    """
    max_body_size: Annotated[Optional[int], Field(alias="maxBodySize")] = None
    """
    MaxBodySize defines the maximum size allowed for the body of the request.
    If the body is larger, the request is not mirrored.
    Default value is -1, which means unlimited size.
    """
    mirror_body: Annotated[Optional[bool], Field(alias="mirrorBody")] = None
    """
    MirrorBody defines whether the body of the request should be mirrored.
    Default value is true.
    """
    mirrors: Optional[List[Mirror]] = None
    """
    Mirrors defines the list of mirrors where Traefik will duplicate the traffic.
    """
    name: str
    """
    Name defines the name of the referenced Kubernetes Service or TraefikService.
    The differentiation between the two is specified in the Kind field.
    """
    namespace: Optional[str] = None
    """
    Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
    """
    native_lb: Annotated[Optional[bool], Field(alias="nativeLB")] = None
    """
    NativeLB controls, when creating the load-balancer,
    whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP.
    The Kubernetes Service itself does load-balance to the pods.
    By default, NativeLB is false.
    """
    node_port_lb: Annotated[Optional[bool], Field(alias="nodePortLB")] = None
    """
    NodePortLB controls, when creating the load-balancer,
    whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort.
    It allows services to be reachable when Traefik runs externally from the Kubernetes cluster but within the same network of the nodes.
    By default, NodePortLB is false.
    """
    pass_host_header: Annotated[Optional[bool], Field(alias="passHostHeader")] = None
    """
    PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service.
    By default, passHostHeader is true.
    """
    port: Optional[Union[int, str]] = None
    """
    Port defines the port of a Kubernetes Service.
    This can be a reference to a named port.
    """
    response_forwarding: Annotated[
        Optional[ResponseForwarding], Field(alias="responseForwarding")
    ] = None
    """
    ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
    """
    scheme: Optional[str] = None
    """
    Scheme defines the scheme to use for the request to the upstream Kubernetes Service.
    It defaults to https when Kubernetes Service port is 443, http otherwise.
    """
    servers_transport: Annotated[Optional[str], Field(alias="serversTransport")] = None
    """
    ServersTransport defines the name of ServersTransport resource to use.
    It allows to configure the transport between Traefik and your servers.
    Can only be used on a Kubernetes Service.
    """
    sticky: Optional[Sticky] = None
    """
    Sticky defines the sticky sessions configuration.
    More info: https://doc.traefik.io/traefik/v3.4/routing/services/#sticky-sessions
    """
    strategy: Optional[Literal["wrr", "p2c", "RoundRobin"]] = None
    """
    Strategy defines the load balancing strategy between the servers.
    Supported values are: wrr (Weighed round-robin) and p2c (Power of two choices).
    RoundRobin value is deprecated and supported for backward compatibility.
    """
    weight: Annotated[Optional[int], Field(ge=0)] = None
    """
    Weight defines the weight and should only be specified when Name references a TraefikService object
    (and to be precise, one that embeds a Weighted Round Robin).
    """


class Weighted(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Weighted"]:
            return Weighted

        def build(self) -> "Weighted":
            return Weighted(**self._attrs)

        @overload
        def services(self, value_or_callback: List[ServiceModel2], /) -> "Weighted.Builder": ...

        @overload
        def services(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ServiceModel2, ServiceModel2.Builder]],
                GenericListBuilder[ServiceModel2, ServiceModel2.Builder] | List[ServiceModel2],
            ],
            /,
        ) -> "Weighted.Builder": ...

        @overload
        def services(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ServiceModel2.Builder]: ...

        def services(self, value_or_callback=None, /):
            """
            Services defines the list of Kubernetes Service and/or TraefikService to load-balance, with weight.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ServiceModel2.Builder]()
                context._parent_builder = self
                context._field_name = "services"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceModel2.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("services", value)

        @overload
        def sticky(self, value_or_callback: Optional[Sticky], /) -> "Weighted.Builder": ...

        @overload
        def sticky(
            self,
            value_or_callback: Callable[[Sticky.Builder], Sticky.Builder | Sticky],
            /,
        ) -> "Weighted.Builder": ...

        @overload
        def sticky(self, value_or_callback: Never = ...) -> "Sticky.BuilderContext": ...

        def sticky(self, value_or_callback=None, /):
            """
            Sticky defines whether sticky sessions are enabled.
            More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
            """
            if self._in_context and value_or_callback is None:
                context = Sticky.BuilderContext()
                context._parent_builder = self
                context._field_name = "sticky"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Sticky.builder())
                if isinstance(output, Sticky.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("sticky", value)

    class BuilderContext(BuilderContextBase["Weighted.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Weighted.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Weighted."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Weighted", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Weighted.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    services: Optional[List[ServiceModel2]] = None
    """
    Services defines the list of Kubernetes Service and/or TraefikService to load-balance, with weight.
    """
    sticky: Optional[Sticky] = None
    """
    Sticky defines whether sticky sessions are enabled.
    More info: https://doc.traefik.io/traefik/v3.4/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
    """


class TraefikServiceSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TraefikServiceSpec"]:
            return TraefikServiceSpec

        def build(self) -> "TraefikServiceSpec":
            return TraefikServiceSpec(**self._attrs)

        @overload
        def mirroring(
            self, value_or_callback: Optional[Mirroring], /
        ) -> "TraefikServiceSpec.Builder": ...

        @overload
        def mirroring(
            self,
            value_or_callback: Callable[[Mirroring.Builder], Mirroring.Builder | Mirroring],
            /,
        ) -> "TraefikServiceSpec.Builder": ...

        @overload
        def mirroring(self, value_or_callback: Never = ...) -> "Mirroring.BuilderContext": ...

        def mirroring(self, value_or_callback=None, /):
            """
            Mirroring defines the Mirroring service configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Mirroring.BuilderContext()
                context._parent_builder = self
                context._field_name = "mirroring"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Mirroring.builder())
                if isinstance(output, Mirroring.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("mirroring", value)

        @overload
        def weighted(
            self, value_or_callback: Optional[Weighted], /
        ) -> "TraefikServiceSpec.Builder": ...

        @overload
        def weighted(
            self,
            value_or_callback: Callable[[Weighted.Builder], Weighted.Builder | Weighted],
            /,
        ) -> "TraefikServiceSpec.Builder": ...

        @overload
        def weighted(self, value_or_callback: Never = ...) -> "Weighted.BuilderContext": ...

        def weighted(self, value_or_callback=None, /):
            """
            Weighted defines the Weighted Round Robin configuration.
            """
            if self._in_context and value_or_callback is None:
                context = Weighted.BuilderContext()
                context._parent_builder = self
                context._field_name = "weighted"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Weighted.builder())
                if isinstance(output, Weighted.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("weighted", value)

    class BuilderContext(BuilderContextBase["TraefikServiceSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TraefikServiceSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TraefikServiceSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TraefikServiceSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TraefikServiceSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mirroring: Optional[Mirroring] = None
    """
    Mirroring defines the Mirroring service configuration.
    """
    weighted: Optional[Weighted] = None
    """
    Weighted defines the Weighted Round Robin configuration.
    """


class IngressRoute(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRoute"]:
            return IngressRoute

        def build(self) -> "IngressRoute":
            return IngressRoute(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IngressRoute"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "IngressRoute.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "IngressRoute.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: IngressRouteSpec, /) -> "IngressRoute.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IngressRouteSpec.Builder], IngressRouteSpec.Builder | IngressRouteSpec
            ],
            /,
        ) -> "IngressRoute.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IngressRouteSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IngressRouteSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressRouteSpec.builder())
                if isinstance(output, IngressRouteSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["IngressRoute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRoute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRoute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRoute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRoute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["IngressRoute"]] = "IngressRoute"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: IngressRouteSpec


class IngressRouteTCP(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRouteTCP"]:
            return IngressRouteTCP

        def build(self) -> "IngressRouteTCP":
            return IngressRouteTCP(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IngressRouteTCP"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "IngressRouteTCP.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "IngressRouteTCP.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: IngressRouteTCPSpec, /) -> "IngressRouteTCP.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IngressRouteTCPSpec.Builder],
                IngressRouteTCPSpec.Builder | IngressRouteTCPSpec,
            ],
            /,
        ) -> "IngressRouteTCP.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IngressRouteTCPSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IngressRouteTCPSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressRouteTCPSpec.builder())
                if isinstance(output, IngressRouteTCPSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["IngressRouteTCP.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRouteTCP.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRouteTCP."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRouteTCP", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRouteTCP.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["IngressRouteTCP"]] = "IngressRouteTCP"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: IngressRouteTCPSpec


class IngressRouteUDP(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IngressRouteUDP"]:
            return IngressRouteUDP

        def build(self) -> "IngressRouteUDP":
            return IngressRouteUDP(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["IngressRouteUDP"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "IngressRouteUDP.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "IngressRouteUDP.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: IngressRouteUDPSpec, /) -> "IngressRouteUDP.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [IngressRouteUDPSpec.Builder],
                IngressRouteUDPSpec.Builder | IngressRouteUDPSpec,
            ],
            /,
        ) -> "IngressRouteUDP.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "IngressRouteUDPSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = IngressRouteUDPSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IngressRouteUDPSpec.builder())
                if isinstance(output, IngressRouteUDPSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["IngressRouteUDP.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IngressRouteUDP.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IngressRouteUDP."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IngressRouteUDP", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IngressRouteUDP.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["IngressRouteUDP"]] = "IngressRouteUDP"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: IngressRouteUDPSpec


class MiddlewareModel2(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareModel2"]:
            return MiddlewareModel2

        def build(self) -> "MiddlewareModel2":
            return MiddlewareModel2(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Middleware"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "MiddlewareModel2.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "MiddlewareModel2.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: MiddlewareSpec, /) -> "MiddlewareModel2.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [MiddlewareSpec.Builder], MiddlewareSpec.Builder | MiddlewareSpec
            ],
            /,
        ) -> "MiddlewareModel2.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "MiddlewareSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MiddlewareSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MiddlewareSpec.builder())
                if isinstance(output, MiddlewareSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["MiddlewareModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Middleware"]] = "Middleware"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: MiddlewareSpec


class MiddlewareTCP(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MiddlewareTCP"]:
            return MiddlewareTCP

        def build(self) -> "MiddlewareTCP":
            return MiddlewareTCP(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["MiddlewareTCP"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "MiddlewareTCP.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "MiddlewareTCP.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: MiddlewareTCPSpec, /) -> "MiddlewareTCP.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [MiddlewareTCPSpec.Builder],
                MiddlewareTCPSpec.Builder | MiddlewareTCPSpec,
            ],
            /,
        ) -> "MiddlewareTCP.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "MiddlewareTCPSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = MiddlewareTCPSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MiddlewareTCPSpec.builder())
                if isinstance(output, MiddlewareTCPSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["MiddlewareTCP.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MiddlewareTCP.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MiddlewareTCP."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MiddlewareTCP", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MiddlewareTCP.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["MiddlewareTCP"]] = "MiddlewareTCP"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: MiddlewareTCPSpec


class ServersTransport(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServersTransport"]:
            return ServersTransport

        def build(self) -> "ServersTransport":
            return ServersTransport(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServersTransport"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "ServersTransport.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "ServersTransport.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ServersTransportSpec, /
        ) -> "ServersTransport.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServersTransportSpec.Builder],
                ServersTransportSpec.Builder | ServersTransportSpec,
            ],
            /,
        ) -> "ServersTransport.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ServersTransportSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServersTransportSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServersTransportSpec.builder())
                if isinstance(output, ServersTransportSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ServersTransport.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServersTransport.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServersTransport."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServersTransport", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServersTransport.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ServersTransport"]] = "ServersTransport"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: ServersTransportSpec


class ServersTransportTCP(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServersTransportTCP"]:
            return ServersTransportTCP

        def build(self) -> "ServersTransportTCP":
            return ServersTransportTCP(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ServersTransportTCP"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "ServersTransportTCP.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "ServersTransportTCP.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ServersTransportTCPSpec, /
        ) -> "ServersTransportTCP.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ServersTransportTCPSpec.Builder],
                ServersTransportTCPSpec.Builder | ServersTransportTCPSpec,
            ],
            /,
        ) -> "ServersTransportTCP.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ServersTransportTCPSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServersTransportTCPSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServersTransportTCPSpec.builder())
                if isinstance(output, ServersTransportTCPSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ServersTransportTCP.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServersTransportTCP.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServersTransportTCP."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServersTransportTCP", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServersTransportTCP.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ServersTransportTCP"]] = "ServersTransportTCP"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: ServersTransportTCPSpec


class TLSOption(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSOption"]:
            return TLSOption

        def build(self) -> "TLSOption":
            return TLSOption(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["TLSOption"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "TLSOption.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "TLSOption.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: TLSOptionSpec, /) -> "TLSOption.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [TLSOptionSpec.Builder], TLSOptionSpec.Builder | TLSOptionSpec
            ],
            /,
        ) -> "TLSOption.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TLSOptionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TLSOptionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TLSOptionSpec.builder())
                if isinstance(output, TLSOptionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["TLSOption.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSOption.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSOption."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSOption", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSOption.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["TLSOption"]] = "TLSOption"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: TLSOptionSpec


class TLSStore(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TLSStore"]:
            return TLSStore

        def build(self) -> "TLSStore":
            return TLSStore(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["TLSStore"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(self, value_or_callback: Optional[v1.ObjectMeta], /) -> "TLSStore.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "TLSStore.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: TLSStoreSpec, /) -> "TLSStore.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [TLSStoreSpec.Builder], TLSStoreSpec.Builder | TLSStoreSpec
            ],
            /,
        ) -> "TLSStore.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TLSStoreSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TLSStoreSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TLSStoreSpec.builder())
                if isinstance(output, TLSStoreSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["TLSStore.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TLSStore.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TLSStore."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TLSStore", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TLSStore.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["TLSStore"]] = "TLSStore"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: TLSStoreSpec


class TraefikService(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TraefikService"]:
            return TraefikService

        def build(self) -> "TraefikService":
            return TraefikService(**self._attrs)

        def api_version(self, value: Optional[Literal["traefik.io/v1alpha1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["TraefikService"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "TraefikService.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "TraefikService.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: TraefikServiceSpec, /) -> "TraefikService.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [TraefikServiceSpec.Builder],
                TraefikServiceSpec.Builder | TraefikServiceSpec,
            ],
            /,
        ) -> "TraefikService.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "TraefikServiceSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TraefikServiceSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TraefikServiceSpec.builder())
                if isinstance(output, TraefikServiceSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["TraefikService.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TraefikService.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TraefikService."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TraefikService", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TraefikService.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[Literal["traefik.io/v1alpha1"]], Field(alias="apiVersion")] = (
        "traefik.io/v1alpha1"
    )
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["TraefikService"]] = "TraefikService"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: TraefikServiceSpec
