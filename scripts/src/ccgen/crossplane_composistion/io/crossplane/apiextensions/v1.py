# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ...k8s.apimachinery.pkg.apis.meta import v1


class CompositeTypeRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositeTypeRef"]:
            return CompositeTypeRef

        def build(self) -> "CompositeTypeRef":
            return CompositeTypeRef(**self._attrs)

        def api_version(self, value: str, /) -> Self:
            """
            APIVersion of the type.
            """
            return self._set("api_version", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind of the type.
            """
            return self._set("kind", value)

    class BuilderContext(BuilderContextBase["CompositeTypeRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositeTypeRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositeTypeRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositeTypeRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositeTypeRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[str, Field(alias="apiVersion")]
    """
    APIVersion of the type.
    """
    kind: str
    """
    Kind of the type.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            The name of the object.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    The name of the object.
    """


class MatchLabel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchLabel"]:
            return MatchLabel

        def build(self) -> "MatchLabel":
            return MatchLabel(**self._attrs)

        def from_field_path_policy(
            self, value: Optional[Literal["Optional", "Required"]], /
        ) -> Self:
            """
            FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
            The default is Required, meaning that an error will be returned if the
            field is not found in the composite resource.
            Optional means that if the field is not found in the composite resource,
            that label pair will just be skipped. N.B. other specified label
            matchers will still be used to retrieve the desired
            environment config, if any.
            """
            return self._set("from_field_path_policy", value)

        def key(self, value: str, /) -> Self:
            """
            Key of the label to match.
            """
            return self._set("key", value)

        def type(self, value: Optional[Literal["FromCompositeFieldPath", "Value"]], /) -> Self:
            """
            Type specifies where the value for a label comes from.
            """
            return self._set("type", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value specifies a literal label value.
            """
            return self._set("value", value)

        def value_from_field_path(self, value: Optional[str], /) -> Self:
            """
            ValueFromFieldPath specifies the field path to look for the label value.
            """
            return self._set("value_from_field_path", value)

    class BuilderContext(BuilderContextBase["MatchLabel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchLabel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchLabel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchLabel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchLabel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path_policy: Annotated[
        Optional[Literal["Optional", "Required"]], Field(alias="fromFieldPathPolicy")
    ] = "Required"
    """
    FromFieldPathPolicy specifies the policy for the valueFromFieldPath.
    The default is Required, meaning that an error will be returned if the
    field is not found in the composite resource.
    Optional means that if the field is not found in the composite resource,
    that label pair will just be skipped. N.B. other specified label
    matchers will still be used to retrieve the desired
    environment config, if any.
    """
    key: str
    """
    Key of the label to match.
    """
    type: Optional[Literal["FromCompositeFieldPath", "Value"]] = "FromCompositeFieldPath"
    """
    Type specifies where the value for a label comes from.
    """
    value: Optional[str] = None
    """
    Value specifies a literal label value.
    """
    value_from_field_path: Annotated[Optional[str], Field(alias="valueFromFieldPath")] = None
    """
    ValueFromFieldPath specifies the field path to look for the label value.
    """


class Selector(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Selector"]:
            return Selector

        def build(self) -> "Selector":
            return Selector(**self._attrs)

        @overload
        def match_labels(self, value_or_callback: List[MatchLabel], /) -> "Selector.Builder": ...

        @overload
        def match_labels(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchLabel, MatchLabel.Builder]],
                GenericListBuilder[MatchLabel, MatchLabel.Builder] | List[MatchLabel],
            ],
            /,
        ) -> "Selector.Builder": ...

        @overload
        def match_labels(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchLabel.Builder]: ...

        def match_labels(self, value_or_callback=None, /):
            """
            MatchLabels ensures an object with matching labels is selected.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchLabel.Builder]()
                context._parent_builder = self
                context._field_name = "match_labels"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchLabel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_labels", value)

        def max_match(self, value: Optional[int], /) -> Self:
            """
            MaxMatch specifies the number of extracted EnvironmentConfigs in Multiple mode, extracts all if nil.
            """
            return self._set("max_match", value)

        def min_match(self, value: Optional[int], /) -> Self:
            """
            MinMatch specifies the required minimum of extracted EnvironmentConfigs in Multiple mode.
            """
            return self._set("min_match", value)

        def mode(self, value: Optional[Literal["Single", "Multiple"]], /) -> Self:
            """
            Mode specifies retrieval strategy: "Single" or "Multiple".
            """
            return self._set("mode", value)

        def sort_by_field_path(self, value: Optional[str], /) -> Self:
            """
            SortByFieldPath is the path to the field based on which list of EnvironmentConfigs is alphabetically sorted.
            """
            return self._set("sort_by_field_path", value)

    class BuilderContext(BuilderContextBase["Selector.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Selector.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Selector."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Selector", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Selector.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_labels: Annotated[Optional[List[MatchLabel]], Field(alias="matchLabels")] = None
    """
    MatchLabels ensures an object with matching labels is selected.
    """
    max_match: Annotated[Optional[int], Field(alias="maxMatch")] = None
    """
    MaxMatch specifies the number of extracted EnvironmentConfigs in Multiple mode, extracts all if nil.
    """
    min_match: Annotated[Optional[int], Field(alias="minMatch")] = None
    """
    MinMatch specifies the required minimum of extracted EnvironmentConfigs in Multiple mode.
    """
    mode: Optional[Literal["Single", "Multiple"]] = "Single"
    """
    Mode specifies retrieval strategy: "Single" or "Multiple".
    """
    sort_by_field_path: Annotated[Optional[str], Field(alias="sortByFieldPath")] = "metadata.name"
    """
    SortByFieldPath is the path to the field based on which list of EnvironmentConfigs is alphabetically sorted.
    """


class EnvironmentConfig(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["EnvironmentConfig"]:
            return EnvironmentConfig

        def build(self) -> "EnvironmentConfig":
            return EnvironmentConfig(**self._attrs)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "EnvironmentConfig.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "EnvironmentConfig.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Ref is a named reference to a single EnvironmentConfig.
            Either Ref or Selector is required.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def selector(
            self, value_or_callback: Optional[Selector], /
        ) -> "EnvironmentConfig.Builder": ...

        @overload
        def selector(
            self,
            value_or_callback: Callable[[Selector.Builder], Selector.Builder | Selector],
            /,
        ) -> "EnvironmentConfig.Builder": ...

        @overload
        def selector(self, value_or_callback: Never = ...) -> "Selector.BuilderContext": ...

        def selector(self, value_or_callback=None, /):
            """
            Selector selects EnvironmentConfig(s) via labels.
            """
            if self._in_context and value_or_callback is None:
                context = Selector.BuilderContext()
                context._parent_builder = self
                context._field_name = "selector"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Selector.builder())
                if isinstance(output, Selector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("selector", value)

        def type(self, value: Optional[Literal["Reference", "Selector"]], /) -> Self:
            """
            Type specifies the way the EnvironmentConfig is selected.
            Default is `Reference`
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["EnvironmentConfig.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = EnvironmentConfig.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for EnvironmentConfig."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["EnvironmentConfig", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use EnvironmentConfig.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ref: Optional[Ref] = None
    """
    Ref is a named reference to a single EnvironmentConfig.
    Either Ref or Selector is required.
    """
    selector: Optional[Selector] = None
    """
    Selector selects EnvironmentConfig(s) via labels.
    """
    type: Optional[Literal["Reference", "Selector"]] = "Reference"
    """
    Type specifies the way the EnvironmentConfig is selected.
    Default is `Reference`
    """


class String(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["String"]:
            return String

        def build(self) -> "String":
            return String(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["String.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = String.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for String."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["String", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use String.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class Variable(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Variable"]:
            return Variable

        def build(self) -> "Variable":
            return Variable(**self._attrs)

        def from_field_path(self, value: str, /) -> Self:
            """
            FromFieldPath is the path of the field on the source whose value is
            to be used as input.
            """
            return self._set("from_field_path", value)

    class BuilderContext(BuilderContextBase["Variable.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Variable.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Variable."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Variable", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Variable.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path: Annotated[str, Field(alias="fromFieldPath")]
    """
    FromFieldPath is the path of the field on the source whose value is
    to be used as input.
    """


class Combine(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Combine"]:
            return Combine

        def build(self) -> "Combine":
            return Combine(**self._attrs)

        def strategy(self, value: Literal["string"], /) -> Self:
            """
            Strategy defines the strategy to use to combine the input variable values.
            Currently only string is supported.
            """
            return self._set("strategy", value)

        @overload
        def string(self, value_or_callback: Optional[String], /) -> "Combine.Builder": ...

        @overload
        def string(
            self,
            value_or_callback: Callable[[String.Builder], String.Builder | String],
            /,
        ) -> "Combine.Builder": ...

        @overload
        def string(self, value_or_callback: Never = ...) -> "String.BuilderContext": ...

        def string(self, value_or_callback=None, /):
            """
            String declares that input variables should be combined into a single
            string, using the relevant settings for formatting purposes.
            """
            if self._in_context and value_or_callback is None:
                context = String.BuilderContext()
                context._parent_builder = self
                context._field_name = "string"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(String.builder())
                if isinstance(output, String.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("string", value)

        @overload
        def variables(self, value_or_callback: List[Variable], /) -> "Combine.Builder": ...

        @overload
        def variables(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Variable, Variable.Builder]],
                GenericListBuilder[Variable, Variable.Builder] | List[Variable],
            ],
            /,
        ) -> "Combine.Builder": ...

        @overload
        def variables(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Variable.Builder]: ...

        def variables(self, value_or_callback=None, /):
            """
            Variables are the list of variables whose values will be retrieved and
            combined.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Variable.Builder]()
                context._parent_builder = self
                context._field_name = "variables"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Variable.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("variables", value)

    class BuilderContext(BuilderContextBase["Combine.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Combine.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Combine."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Combine", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Combine.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    strategy: Literal["string"]
    """
    Strategy defines the strategy to use to combine the input variable values.
    Currently only string is supported.
    """
    string: Optional[String] = None
    """
    String declares that input variables should be combined into a single
    string, using the relevant settings for formatting purposes.
    """
    variables: Annotated[List[Variable], Field(min_length=1)]
    """
    Variables are the list of variables whose values will be retrieved and
    combined.
    """


class MergeOptions(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MergeOptions"]:
            return MergeOptions

        def build(self) -> "MergeOptions":
            return MergeOptions(**self._attrs)

        def append_slice(self, value: Optional[bool], /) -> Self:
            """
            Specifies that already existing elements in a merged slice should be preserved
            """
            return self._set("append_slice", value)

        def keep_map_values(self, value: Optional[bool], /) -> Self:
            """
            Specifies that already existing values in a merged map should be preserved
            """
            return self._set("keep_map_values", value)

    class BuilderContext(BuilderContextBase["MergeOptions.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MergeOptions.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MergeOptions."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MergeOptions", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MergeOptions.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    append_slice: Annotated[Optional[bool], Field(alias="appendSlice")] = None
    """
    Specifies that already existing elements in a merged slice should be preserved
    """
    keep_map_values: Annotated[Optional[bool], Field(alias="keepMapValues")] = None
    """
    Specifies that already existing values in a merged map should be preserved
    """


class Policy(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Policy"]:
            return Policy

        def build(self) -> "Policy":
            return Policy(**self._attrs)

        def from_field_path(self, value: Optional[Literal["Optional", "Required"]], /) -> Self:
            """
            FromFieldPath specifies how to patch from a field path. The default is
            'Optional', which means the patch will be a no-op if the specified
            fromFieldPath does not exist. Use 'Required' if the patch should fail if
            the specified path does not exist.
            """
            return self._set("from_field_path", value)

        @overload
        def merge_options(
            self, value_or_callback: Optional[MergeOptions], /
        ) -> "Policy.Builder": ...

        @overload
        def merge_options(
            self,
            value_or_callback: Callable[
                [MergeOptions.Builder], MergeOptions.Builder | MergeOptions
            ],
            /,
        ) -> "Policy.Builder": ...

        @overload
        def merge_options(
            self, value_or_callback: Never = ...
        ) -> "MergeOptions.BuilderContext": ...

        def merge_options(self, value_or_callback=None, /):
            """
            MergeOptions Specifies merge options on a field path.
            """
            if self._in_context and value_or_callback is None:
                context = MergeOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "merge_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MergeOptions.builder())
                if isinstance(output, MergeOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("merge_options", value)

    class BuilderContext(BuilderContextBase["Policy.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Policy.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Policy."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Policy", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Policy.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path: Annotated[
        Optional[Literal["Optional", "Required"]], Field(alias="fromFieldPath")
    ] = None
    """
    FromFieldPath specifies how to patch from a field path. The default is
    'Optional', which means the patch will be a no-op if the specified
    fromFieldPath does not exist. Use 'Required' if the patch should fail if
    the specified path does not exist.
    """
    merge_options: Annotated[Optional[MergeOptions], Field(alias="mergeOptions")] = None
    """
    MergeOptions Specifies merge options on a field path.
    """


class Convert(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Convert"]:
            return Convert

        def build(self) -> "Convert":
            return Convert(**self._attrs)

        def format(self, value: Optional[Literal["none", "quantity", "json"]], /) -> Self:
            """
            The expected input format.


            * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
            Only used during `string -> float64` conversions.
            * `json` - parses the input as a JSON string.
            Only used during `string -> object` or `string -> list` conversions.


            If this property is null, the default conversion is applied.
            """
            return self._set("format", value)

        def to_type(
            self,
            value: Literal["string", "int", "int64", "bool", "float64", "object", "array"],
            /,
        ) -> Self:
            """
            ToType is the type of the output of this transform.
            """
            return self._set("to_type", value)

    class BuilderContext(BuilderContextBase["Convert.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Convert.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Convert."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Convert", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Convert.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    format: Optional[Literal["none", "quantity", "json"]] = None
    """
    The expected input format.


    * `quantity` - parses the input as a K8s [`resource.Quantity`](https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity).
    Only used during `string -> float64` conversions.
    * `json` - parses the input as a JSON string.
    Only used during `string -> object` or `string -> list` conversions.


    If this property is null, the default conversion is applied.
    """
    to_type: Annotated[
        Literal["string", "int", "int64", "bool", "float64", "object", "array"],
        Field(alias="toType"),
    ]
    """
    ToType is the type of the output of this transform.
    """


class Pattern(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pattern"]:
            return Pattern

        def build(self) -> "Pattern":
            return Pattern(**self._attrs)

        def literal(self, value: Optional[str], /) -> Self:
            """
            Literal exactly matches the input string (case sensitive).
            Is required if `type` is `literal`.
            """
            return self._set("literal", value)

        def regexp(self, value: Optional[str], /) -> Self:
            """
            Regexp to match against the input string.
            Is required if `type` is `regexp`.
            """
            return self._set("regexp", value)

        def result(self, value: Any, /) -> Self:
            """
            The value that is used as result of the transform if the pattern matches.
            """
            return self._set("result", value)

        def type(self, value: Optional[Literal["literal", "regexp"]], /) -> Self:
            """
            Type specifies how the pattern matches the input.


            * `literal` - the pattern value has to exactly match (case sensitive) the
            input string. This is the default.


            * `regexp` - the pattern treated as a regular expression against
            which the input string is tested. Crossplane will throw an error if the
            key is not a valid regexp.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Pattern.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pattern.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pattern."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pattern", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pattern.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    literal: Optional[str] = None
    """
    Literal exactly matches the input string (case sensitive).
    Is required if `type` is `literal`.
    """
    regexp: Optional[str] = None
    """
    Regexp to match against the input string.
    Is required if `type` is `regexp`.
    """
    result: Any
    """
    The value that is used as result of the transform if the pattern matches.
    """
    type: Optional[Literal["literal", "regexp"]] = "literal"
    """
    Type specifies how the pattern matches the input.


    * `literal` - the pattern value has to exactly match (case sensitive) the
    input string. This is the default.


    * `regexp` - the pattern treated as a regular expression against
    which the input string is tested. Crossplane will throw an error if the
    key is not a valid regexp.
    """


class Match(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Match"]:
            return Match

        def build(self) -> "Match":
            return Match(**self._attrs)

        def fallback_to(self, value: Optional[Literal["Value", "Input"]], /) -> Self:
            """
            Determines to what value the transform should fallback if no pattern matches.
            """
            return self._set("fallback_to", value)

        def fallback_value(self, value: Optional[Any], /) -> Self:
            """
            The fallback value that should be returned by the transform if now pattern
            matches.
            """
            return self._set("fallback_value", value)

        @overload
        def patterns(self, value_or_callback: List[Pattern], /) -> "Match.Builder": ...

        @overload
        def patterns(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pattern, Pattern.Builder]],
                GenericListBuilder[Pattern, Pattern.Builder] | List[Pattern],
            ],
            /,
        ) -> "Match.Builder": ...

        @overload
        def patterns(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Pattern.Builder]: ...

        def patterns(self, value_or_callback=None, /):
            """
            The patterns that should be tested against the input string.
            Patterns are tested in order. The value of the first match is used as
            result of this transform.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pattern.Builder]()
                context._parent_builder = self
                context._field_name = "patterns"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pattern.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patterns", value)

    class BuilderContext(BuilderContextBase["Match.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Match.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Match."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Match", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Match.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fallback_to: Annotated[Optional[Literal["Value", "Input"]], Field(alias="fallbackTo")] = "Value"
    """
    Determines to what value the transform should fallback if no pattern matches.
    """
    fallback_value: Annotated[Optional[Any], Field(alias="fallbackValue")] = None
    """
    The fallback value that should be returned by the transform if now pattern
    matches.
    """
    patterns: Optional[List[Pattern]] = None
    """
    The patterns that should be tested against the input string.
    Patterns are tested in order. The value of the first match is used as
    result of this transform.
    """


class Math(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Math"]:
            return Math

        def build(self) -> "Math":
            return Math(**self._attrs)

        def clamp_max(self, value: Optional[int], /) -> Self:
            """
            ClampMax makes sure that the value is not bigger than the given value.
            """
            return self._set("clamp_max", value)

        def clamp_min(self, value: Optional[int], /) -> Self:
            """
            ClampMin makes sure that the value is not smaller than the given value.
            """
            return self._set("clamp_min", value)

        def multiply(self, value: Optional[int], /) -> Self:
            """
            Multiply the value.
            """
            return self._set("multiply", value)

        def type(self, value: Optional[Literal["Multiply", "ClampMin", "ClampMax"]], /) -> Self:
            """
            Type of the math transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Math.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Math.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Math."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Math", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Math.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    clamp_max: Annotated[Optional[int], Field(alias="clampMax")] = None
    """
    ClampMax makes sure that the value is not bigger than the given value.
    """
    clamp_min: Annotated[Optional[int], Field(alias="clampMin")] = None
    """
    ClampMin makes sure that the value is not smaller than the given value.
    """
    multiply: Optional[int] = None
    """
    Multiply the value.
    """
    type: Optional[Literal["Multiply", "ClampMin", "ClampMax"]] = "Multiply"
    """
    Type of the math transform to be run.
    """


class Join(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Join"]:
            return Join

        def build(self) -> "Join":
            return Join(**self._attrs)

        def separator(self, value: str, /) -> Self:
            """
            Separator defines the character that should separate the values from each
            other in the joined string.
            """
            return self._set("separator", value)

    class BuilderContext(BuilderContextBase["Join.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Join.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Join."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Join", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Join.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    separator: str
    """
    Separator defines the character that should separate the values from each
    other in the joined string.
    """


class Regexp(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Regexp"]:
            return Regexp

        def build(self) -> "Regexp":
            return Regexp(**self._attrs)

        def group(self, value: Optional[int], /) -> Self:
            """
            Group number to match. 0 (the default) matches the entire expression.
            """
            return self._set("group", value)

        def match(self, value: str, /) -> Self:
            """
            Match string. May optionally include submatches, aka capture groups.
            See https://pkg.go.dev/regexp/ for details.
            """
            return self._set("match", value)

    class BuilderContext(BuilderContextBase["Regexp.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Regexp.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Regexp."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Regexp", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Regexp.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    group: Optional[int] = None
    """
    Group number to match. 0 (the default) matches the entire expression.
    """
    match: str
    """
    Match string. May optionally include submatches, aka capture groups.
    See https://pkg.go.dev/regexp/ for details.
    """


class StringModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel"]:
            return StringModel

        def build(self) -> "StringModel":
            return StringModel(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                    "ToAdler32",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            `ToAdler32` generate a addler32 hash based on the input string.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join defines parameters to join a slice of values to a string.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[
                Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]
            ],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
            "ToAdler32",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    `ToAdler32` generate a addler32 hash based on the input string.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join defines parameters to join a slice of values to a string.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]] = (
        "Format"
    )
    """
    Type of the string transform to be run.
    """


class Transform(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Transform"]:
            return Transform

        def build(self) -> "Transform":
            return Transform(**self._attrs)

        @overload
        def convert(self, value_or_callback: Optional[Convert], /) -> "Transform.Builder": ...

        @overload
        def convert(
            self,
            value_or_callback: Callable[[Convert.Builder], Convert.Builder | Convert],
            /,
        ) -> "Transform.Builder": ...

        @overload
        def convert(self, value_or_callback: Never = ...) -> "Convert.BuilderContext": ...

        def convert(self, value_or_callback=None, /):
            """
            Convert is used to cast the input into the given output type.
            """
            if self._in_context and value_or_callback is None:
                context = Convert.BuilderContext()
                context._parent_builder = self
                context._field_name = "convert"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Convert.builder())
                if isinstance(output, Convert.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("convert", value)

        def map(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Map uses the input as a key in the given map and returns the value.
            """
            return self._set("map", value)

        @overload
        def match(self, value_or_callback: Optional[Match], /) -> "Transform.Builder": ...

        @overload
        def match(
            self, value_or_callback: Callable[[Match.Builder], Match.Builder | Match], /
        ) -> "Transform.Builder": ...

        @overload
        def match(self, value_or_callback: Never = ...) -> "Match.BuilderContext": ...

        def match(self, value_or_callback=None, /):
            """
            Match is a more complex version of Map that matches a list of patterns.
            """
            if self._in_context and value_or_callback is None:
                context = Match.BuilderContext()
                context._parent_builder = self
                context._field_name = "match"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Match.builder())
                if isinstance(output, Match.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match", value)

        @overload
        def math(self, value_or_callback: Optional[Math], /) -> "Transform.Builder": ...

        @overload
        def math(
            self, value_or_callback: Callable[[Math.Builder], Math.Builder | Math], /
        ) -> "Transform.Builder": ...

        @overload
        def math(self, value_or_callback: Never = ...) -> "Math.BuilderContext": ...

        def math(self, value_or_callback=None, /):
            """
            Math is used to transform the input via mathematical operations such as
            multiplication.
            """
            if self._in_context and value_or_callback is None:
                context = Math.BuilderContext()
                context._parent_builder = self
                context._field_name = "math"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Math.builder())
                if isinstance(output, Math.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("math", value)

        @overload
        def string(self, value_or_callback: Optional[StringModel], /) -> "Transform.Builder": ...

        @overload
        def string(
            self,
            value_or_callback: Callable[[StringModel.Builder], StringModel.Builder | StringModel],
            /,
        ) -> "Transform.Builder": ...

        @overload
        def string(self, value_or_callback: Never = ...) -> "StringModel.BuilderContext": ...

        def string(self, value_or_callback=None, /):
            """
            String is used to transform the input into a string or a different kind
            of string. Note that the input does not necessarily need to be a string.
            """
            if self._in_context and value_or_callback is None:
                context = StringModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "string"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StringModel.builder())
                if isinstance(output, StringModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("string", value)

        def type(self, value: Literal["map", "match", "math", "string", "convert"], /) -> Self:
            """
            Type of the transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Transform.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Transform.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Transform."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Transform", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Transform.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[Convert] = None
    """
    Convert is used to cast the input into the given output type.
    """
    map: Optional[Dict[str, Any]] = None
    """
    Map uses the input as a key in the given map and returns the value.
    """
    match: Optional[Match] = None
    """
    Match is a more complex version of Map that matches a list of patterns.
    """
    math: Optional[Math] = None
    """
    Math is used to transform the input via mathematical operations such as
    multiplication.
    """
    string: Optional[StringModel] = None
    """
    String is used to transform the input into a string or a different kind
    of string. Note that the input does not necessarily need to be a string.
    """
    type: Literal["map", "match", "math", "string", "convert"]
    """
    Type of the transform to be run.
    """


class Patch(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Patch"]:
            return Patch

        def build(self) -> "Patch":
            return Patch(**self._attrs)

        @overload
        def combine(self, value_or_callback: Optional[Combine], /) -> "Patch.Builder": ...

        @overload
        def combine(
            self,
            value_or_callback: Callable[[Combine.Builder], Combine.Builder | Combine],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def combine(self, value_or_callback: Never = ...) -> "Combine.BuilderContext": ...

        def combine(self, value_or_callback=None, /):
            """
            Combine is the patch configuration for a CombineFromComposite or
            CombineToComposite patch.
            """
            if self._in_context and value_or_callback is None:
                context = Combine.BuilderContext()
                context._parent_builder = self
                context._field_name = "combine"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Combine.builder())
                if isinstance(output, Combine.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("combine", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the resource whose value is
            to be used as input. Required when type is FromCompositeFieldPath or
            ToCompositeFieldPath.
            """
            return self._set("from_field_path", value)

        @overload
        def policy(self, value_or_callback: Optional[Policy], /) -> "Patch.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[Policy.Builder], Policy.Builder | Policy],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "Policy.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy configures the specifics of patching behaviour.
            """
            if self._in_context and value_or_callback is None:
                context = Policy.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Policy.builder())
                if isinstance(output, Policy.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

        def to_field_path(self, value: Optional[str], /) -> Self:
            """
            ToFieldPath is the path of the field on the resource whose value will
            be changed with the result of transforms. Leave empty if you'd like to
            propagate to the same path as fromFieldPath.
            """
            return self._set("to_field_path", value)

        @overload
        def transforms(self, value_or_callback: List[Transform], /) -> "Patch.Builder": ...

        @overload
        def transforms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Transform, Transform.Builder]],
                GenericListBuilder[Transform, Transform.Builder] | List[Transform],
            ],
            /,
        ) -> "Patch.Builder": ...

        @overload
        def transforms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Transform.Builder]: ...

        def transforms(self, value_or_callback=None, /):
            """
            Transforms are the list of functions that are used as a FIFO pipe for the
            input to be transformed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Transform.Builder]()
                context._parent_builder = self
                context._field_name = "transforms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Transform.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("transforms", value)

        def type(
            self,
            value: Optional[
                Literal[
                    "FromCompositeFieldPath",
                    "ToCompositeFieldPath",
                    "CombineFromComposite",
                    "CombineToComposite",
                ]
            ],
            /,
        ) -> Self:
            """
            Type sets the patching behaviour to be used. Each patch type may require
            its own fields to be set on the Patch object.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Patch.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Patch.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Patch."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Patch", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Patch.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    combine: Optional[Combine] = None
    """
    Combine is the patch configuration for a CombineFromComposite or
    CombineToComposite patch.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the resource whose value is
    to be used as input. Required when type is FromCompositeFieldPath or
    ToCompositeFieldPath.
    """
    policy: Optional[Policy] = None
    """
    Policy configures the specifics of patching behaviour.
    """
    to_field_path: Annotated[Optional[str], Field(alias="toFieldPath")] = None
    """
    ToFieldPath is the path of the field on the resource whose value will
    be changed with the result of transforms. Leave empty if you'd like to
    propagate to the same path as fromFieldPath.
    """
    transforms: Optional[List[Transform]] = None
    """
    Transforms are the list of functions that are used as a FIFO pipe for the
    input to be transformed.
    """
    type: Optional[
        Literal[
            "FromCompositeFieldPath",
            "ToCompositeFieldPath",
            "CombineFromComposite",
            "CombineToComposite",
        ]
    ] = "FromCompositeFieldPath"
    """
    Type sets the patching behaviour to be used. Each patch type may require
    its own fields to be set on the Patch object.
    """


class PolicyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyModel"]:
            return PolicyModel

        def build(self) -> "PolicyModel":
            return PolicyModel(**self._attrs)

        def resolution(self, value: Optional[Literal["Required", "Optional"]], /) -> Self:
            """
            Resolution specifies whether resolution of this reference is required.
            The default is 'Required', which means the reconcile will fail if the
            reference cannot be resolved. 'Optional' means this reference will be
            a no-op if it cannot be resolved.
            """
            return self._set("resolution", value)

        def resolve(self, value: Optional[Literal["Always", "IfNotPresent"]], /) -> Self:
            """
            Resolve specifies when this reference should be resolved. The default
            is 'IfNotPresent', which will attempt to resolve the reference only when
            the corresponding field is not present. Use 'Always' to resolve the
            reference on every reconcile.
            """
            return self._set("resolve", value)

    class BuilderContext(BuilderContextBase["PolicyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resolution: Optional[Literal["Required", "Optional"]] = "Required"
    """
    Resolution specifies whether resolution of this reference is required.
    The default is 'Required', which means the reconcile will fail if the
    reference cannot be resolved. 'Optional' means this reference will be
    a no-op if it cannot be resolved.
    """
    resolve: Optional[Literal["Always", "IfNotPresent"]] = None
    """
    Resolve specifies when this reference should be resolved. The default
    is 'IfNotPresent', which will attempt to resolve the reference only when
    the corresponding field is not present. Use 'Always' to resolve the
    reference on every reconcile.
    """


class Environment(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Environment"]:
            return Environment

        def build(self) -> "Environment":
            return Environment(**self._attrs)

        def default_data(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            DefaultData statically defines the initial state of the environment.
            It has the same schema-less structure as the data field in
            environment configs.
            It is overwritten by the selected environment configs.
            """
            return self._set("default_data", value)

        @overload
        def environment_configs(
            self, value_or_callback: List[EnvironmentConfig], /
        ) -> "Environment.Builder": ...

        @overload
        def environment_configs(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[EnvironmentConfig, EnvironmentConfig.Builder]],
                GenericListBuilder[EnvironmentConfig, EnvironmentConfig.Builder]
                | List[EnvironmentConfig],
            ],
            /,
        ) -> "Environment.Builder": ...

        @overload
        def environment_configs(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[EnvironmentConfig.Builder]: ...

        def environment_configs(self, value_or_callback=None, /):
            """
            EnvironmentConfigs selects a list of `EnvironmentConfig`s. The resolved
            resources are stored in the composite resource at
            `spec.environmentConfigRefs` and is only updated if it is null.


            The list of references is used to compute an in-memory environment at
            compose time. The data of all object is merged in the order they are
            listed, meaning the values of EnvironmentConfigs with a larger index take
            priority over ones with smaller indices.


            The computed environment can be accessed in a composition using
            `FromEnvironmentFieldPath` and `CombineFromEnvironment` patches.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[EnvironmentConfig.Builder]()
                context._parent_builder = self
                context._field_name = "environment_configs"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(EnvironmentConfig.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment_configs", value)

        @overload
        def patches(self, value_or_callback: List[Patch], /) -> "Environment.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Patch, Patch.Builder]],
                GenericListBuilder[Patch, Patch.Builder] | List[Patch],
            ],
            /,
        ) -> "Environment.Builder": ...

        @overload
        def patches(self, value_or_callback: Never = ...) -> ListBuilderContext[Patch.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches is a list of environment patches that are executed before a
            composition's resources are composed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Patch.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Patch.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

        @overload
        def policy(self, value_or_callback: Optional[PolicyModel], /) -> "Environment.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[[PolicyModel.Builder], PolicyModel.Builder | PolicyModel],
            /,
        ) -> "Environment.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "PolicyModel.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy represents the Resolve and Resolution policies which apply to
            all EnvironmentSourceReferences in EnvironmentConfigs list.
            """
            if self._in_context and value_or_callback is None:
                context = PolicyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicyModel.builder())
                if isinstance(output, PolicyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

    class BuilderContext(BuilderContextBase["Environment.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Environment.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Environment."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Environment", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Environment.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    default_data: Annotated[Optional[Dict[str, Any]], Field(alias="defaultData")] = None
    """
    DefaultData statically defines the initial state of the environment.
    It has the same schema-less structure as the data field in
    environment configs.
    It is overwritten by the selected environment configs.
    """
    environment_configs: Annotated[
        Optional[List[EnvironmentConfig]], Field(alias="environmentConfigs")
    ] = None
    """
    EnvironmentConfigs selects a list of `EnvironmentConfig`s. The resolved
    resources are stored in the composite resource at
    `spec.environmentConfigRefs` and is only updated if it is null.


    The list of references is used to compute an in-memory environment at
    compose time. The data of all object is merged in the order they are
    listed, meaning the values of EnvironmentConfigs with a larger index take
    priority over ones with smaller indices.


    The computed environment can be accessed in a composition using
    `FromEnvironmentFieldPath` and `CombineFromEnvironment` patches.
    """
    patches: Optional[List[Patch]] = None
    """
    Patches is a list of environment patches that are executed before a
    composition's resources are composed.
    """
    policy: Optional[PolicyModel] = None
    """
    Policy represents the Resolve and Resolution policies which apply to
    all EnvironmentSourceReferences in EnvironmentConfigs list.
    """


class StringModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel1"]:
            return StringModel1

        def build(self) -> "StringModel1":
            return StringModel1(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["StringModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class PolicyModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PolicyModel1"]:
            return PolicyModel1

        def build(self) -> "PolicyModel1":
            return PolicyModel1(**self._attrs)

        def from_field_path(self, value: Optional[Literal["Optional", "Required"]], /) -> Self:
            """
            FromFieldPath specifies how to patch from a field path. The default is
            'Optional', which means the patch will be a no-op if the specified
            fromFieldPath does not exist. Use 'Required' if the patch should fail if
            the specified path does not exist.
            """
            return self._set("from_field_path", value)

        @overload
        def merge_options(
            self, value_or_callback: Optional[MergeOptions], /
        ) -> "PolicyModel1.Builder": ...

        @overload
        def merge_options(
            self,
            value_or_callback: Callable[
                [MergeOptions.Builder], MergeOptions.Builder | MergeOptions
            ],
            /,
        ) -> "PolicyModel1.Builder": ...

        @overload
        def merge_options(
            self, value_or_callback: Never = ...
        ) -> "MergeOptions.BuilderContext": ...

        def merge_options(self, value_or_callback=None, /):
            """
            MergeOptions Specifies merge options on a field path.
            """
            if self._in_context and value_or_callback is None:
                context = MergeOptions.BuilderContext()
                context._parent_builder = self
                context._field_name = "merge_options"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MergeOptions.builder())
                if isinstance(output, MergeOptions.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("merge_options", value)

    class BuilderContext(BuilderContextBase["PolicyModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PolicyModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PolicyModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PolicyModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PolicyModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_field_path: Annotated[
        Optional[Literal["Optional", "Required"]], Field(alias="fromFieldPath")
    ] = None
    """
    FromFieldPath specifies how to patch from a field path. The default is
    'Optional', which means the patch will be a no-op if the specified
    fromFieldPath does not exist. Use 'Required' if the patch should fail if
    the specified path does not exist.
    """
    merge_options: Annotated[Optional[MergeOptions], Field(alias="mergeOptions")] = None
    """
    MergeOptions Specifies merge options on a field path.
    """


class StringModel2(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel2"]:
            return StringModel2

        def build(self) -> "StringModel2":
            return StringModel2(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                    "ToAdler32",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            `ToAdler32` generate a addler32 hash based on the input string.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel2.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel2.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join defines parameters to join a slice of values to a string.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel2.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel2.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[
                Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]
            ],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel2.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel2.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel2."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel2", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel2.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
            "ToAdler32",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    `ToAdler32` generate a addler32 hash based on the input string.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join defines parameters to join a slice of values to a string.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]] = (
        "Format"
    )
    """
    Type of the string transform to be run.
    """


class PatchModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PatchModel"]:
            return PatchModel

        def build(self) -> "PatchModel":
            return PatchModel(**self._attrs)

        @overload
        def combine(self, value_or_callback: Optional[Combine], /) -> "PatchModel.Builder": ...

        @overload
        def combine(
            self,
            value_or_callback: Callable[[Combine.Builder], Combine.Builder | Combine],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def combine(self, value_or_callback: Never = ...) -> "Combine.BuilderContext": ...

        def combine(self, value_or_callback=None, /):
            """
            Combine is the patch configuration for a CombineFromComposite,
            CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
            """
            if self._in_context and value_or_callback is None:
                context = Combine.BuilderContext()
                context._parent_builder = self
                context._field_name = "combine"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Combine.builder())
                if isinstance(output, Combine.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("combine", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the resource whose value is
            to be used as input. Required when type is FromCompositeFieldPath,
            FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
            """
            return self._set("from_field_path", value)

        def patch_set_name(self, value: Optional[str], /) -> Self:
            """
            PatchSetName to include patches from. Required when type is PatchSet.
            """
            return self._set("patch_set_name", value)

        @overload
        def policy(self, value_or_callback: Optional[PolicyModel1], /) -> "PatchModel.Builder": ...

        @overload
        def policy(
            self,
            value_or_callback: Callable[
                [PolicyModel1.Builder], PolicyModel1.Builder | PolicyModel1
            ],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def policy(self, value_or_callback: Never = ...) -> "PolicyModel1.BuilderContext": ...

        def policy(self, value_or_callback=None, /):
            """
            Policy configures the specifics of patching behaviour.
            """
            if self._in_context and value_or_callback is None:
                context = PolicyModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "policy"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PolicyModel1.builder())
                if isinstance(output, PolicyModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("policy", value)

        def to_field_path(self, value: Optional[str], /) -> Self:
            """
            ToFieldPath is the path of the field on the resource whose value will
            be changed with the result of transforms. Leave empty if you'd like to
            propagate to the same path as fromFieldPath.
            """
            return self._set("to_field_path", value)

        @overload
        def transforms(self, value_or_callback: List[Transform], /) -> "PatchModel.Builder": ...

        @overload
        def transforms(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Transform, Transform.Builder]],
                GenericListBuilder[Transform, Transform.Builder] | List[Transform],
            ],
            /,
        ) -> "PatchModel.Builder": ...

        @overload
        def transforms(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Transform.Builder]: ...

        def transforms(self, value_or_callback=None, /):
            """
            Transforms are the list of functions that are used as a FIFO pipe for the
            input to be transformed.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Transform.Builder]()
                context._parent_builder = self
                context._field_name = "transforms"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Transform.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("transforms", value)

        def type(
            self,
            value: Optional[
                Literal[
                    "FromCompositeFieldPath",
                    "FromEnvironmentFieldPath",
                    "PatchSet",
                    "ToCompositeFieldPath",
                    "ToEnvironmentFieldPath",
                    "CombineFromEnvironment",
                    "CombineFromComposite",
                    "CombineToComposite",
                    "CombineToEnvironment",
                ]
            ],
            /,
        ) -> Self:
            """
            Type sets the patching behaviour to be used. Each patch type may require
            its own fields to be set on the Patch object.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["PatchModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PatchModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PatchModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PatchModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    combine: Optional[Combine] = None
    """
    Combine is the patch configuration for a CombineFromComposite,
    CombineFromEnvironment, CombineToComposite or CombineToEnvironment patch.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the resource whose value is
    to be used as input. Required when type is FromCompositeFieldPath,
    FromEnvironmentFieldPath, ToCompositeFieldPath, ToEnvironmentFieldPath.
    """
    patch_set_name: Annotated[Optional[str], Field(alias="patchSetName")] = None
    """
    PatchSetName to include patches from. Required when type is PatchSet.
    """
    policy: Optional[PolicyModel1] = None
    """
    Policy configures the specifics of patching behaviour.
    """
    to_field_path: Annotated[Optional[str], Field(alias="toFieldPath")] = None
    """
    ToFieldPath is the path of the field on the resource whose value will
    be changed with the result of transforms. Leave empty if you'd like to
    propagate to the same path as fromFieldPath.
    """
    transforms: Optional[List[Transform]] = None
    """
    Transforms are the list of functions that are used as a FIFO pipe for the
    input to be transformed.
    """
    type: Optional[
        Literal[
            "FromCompositeFieldPath",
            "FromEnvironmentFieldPath",
            "PatchSet",
            "ToCompositeFieldPath",
            "ToEnvironmentFieldPath",
            "CombineFromEnvironment",
            "CombineFromComposite",
            "CombineToComposite",
            "CombineToEnvironment",
        ]
    ] = "FromCompositeFieldPath"
    """
    Type sets the patching behaviour to be used. Each patch type may require
    its own fields to be set on the Patch object.
    """


class PatchSet(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PatchSet"]:
            return PatchSet

        def build(self) -> "PatchSet":
            return PatchSet(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of this PatchSet.
            """
            return self._set("name", value)

        @overload
        def patches(self, value_or_callback: List[PatchModel], /) -> "PatchSet.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchModel, PatchModel.Builder]],
                GenericListBuilder[PatchModel, PatchModel.Builder] | List[PatchModel],
            ],
            /,
        ) -> "PatchSet.Builder": ...

        @overload
        def patches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchModel.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches will be applied as an overlay to the base resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchModel.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

    class BuilderContext(BuilderContextBase["PatchSet.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PatchSet.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PatchSet."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PatchSet", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PatchSet.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of this PatchSet.
    """
    patches: List[PatchModel]
    """
    Patches will be applied as an overlay to the base resource.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the secret.
            """
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            """
            Namespace of the secret.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the secret.
    """
    namespace: str
    """
    Namespace of the secret.
    """


class Credential(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credential"]:
            return Credential

        def build(self) -> "Credential":
            return Credential(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of this set of credentials.
            """
            return self._set("name", value)

        @overload
        def secret_ref(self, value_or_callback: Optional[SecretRef], /) -> "Credential.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Credential.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            A SecretRef is a reference to a secret containing credentials that should
            be supplied to the function.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def source(self, value: Literal["None", "Secret"], /) -> Self:
            """
            Source of the function credentials.
            """
            return self._set("source", value)

    class BuilderContext(BuilderContextBase["Credential.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credential.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credential."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credential", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credential.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of this set of credentials.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    A SecretRef is a reference to a secret containing credentials that should
    be supplied to the function.
    """
    source: Literal["None", "Secret"]
    """
    Source of the function credentials.
    """


class FunctionRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["FunctionRef"]:
            return FunctionRef

        def build(self) -> "FunctionRef":
            return FunctionRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced Function.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["FunctionRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = FunctionRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for FunctionRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["FunctionRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use FunctionRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced Function.
    """


class Pipeline(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Pipeline"]:
            return Pipeline

        def build(self) -> "Pipeline":
            return Pipeline(**self._attrs)

        @overload
        def credentials(self, value_or_callback: List[Credential], /) -> "Pipeline.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Credential, Credential.Builder]],
                GenericListBuilder[Credential, Credential.Builder] | List[Credential],
            ],
            /,
        ) -> "Pipeline.Builder": ...

        @overload
        def credentials(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Credential.Builder]: ...

        def credentials(self, value_or_callback=None, /):
            """
            Credentials are optional credentials that the Composition Function needs.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Credential.Builder]()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credential.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        @overload
        def function_ref(self, value_or_callback: FunctionRef, /) -> "Pipeline.Builder": ...

        @overload
        def function_ref(
            self,
            value_or_callback: Callable[[FunctionRef.Builder], FunctionRef.Builder | FunctionRef],
            /,
        ) -> "Pipeline.Builder": ...

        @overload
        def function_ref(self, value_or_callback: Never = ...) -> "FunctionRef.BuilderContext": ...

        def function_ref(self, value_or_callback=None, /):
            """
            FunctionRef is a reference to the Composition Function this step should
            execute.
            """
            if self._in_context and value_or_callback is None:
                context = FunctionRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "function_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(FunctionRef.builder())
                if isinstance(output, FunctionRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("function_ref", value)

        def input(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Input is an optional, arbitrary Kubernetes resource (i.e. a resource
            with an apiVersion and kind) that will be passed to the Composition
            Function as the 'input' of its RunFunctionRequest.
            """
            return self._set("input", value)

        def step(self, value: str, /) -> Self:
            """
            Step name. Must be unique within its Pipeline.
            """
            return self._set("step", value)

    class BuilderContext(BuilderContextBase["Pipeline.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Pipeline.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Pipeline."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Pipeline", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Pipeline.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials: Optional[List[Credential]] = None
    """
    Credentials are optional credentials that the Composition Function needs.
    """
    function_ref: Annotated[FunctionRef, Field(alias="functionRef")]
    """
    FunctionRef is a reference to the Composition Function this step should
    execute.
    """
    input: Optional[Dict[str, Any]] = None
    """
    Input is an optional, arbitrary Kubernetes resource (i.e. a resource
    with an apiVersion and kind) that will be passed to the Composition
    Function as the 'input' of its RunFunctionRequest.
    """
    step: str
    """
    Step name. Must be unique within its Pipeline.
    """


class PublishConnectionDetailsWithStoreConfigRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PublishConnectionDetailsWithStoreConfigRef"]:
            return PublishConnectionDetailsWithStoreConfigRef

        def build(self) -> "PublishConnectionDetailsWithStoreConfigRef":
            return PublishConnectionDetailsWithStoreConfigRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referenced StoreConfig.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["PublishConnectionDetailsWithStoreConfigRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PublishConnectionDetailsWithStoreConfigRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PublishConnectionDetailsWithStoreConfigRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PublishConnectionDetailsWithStoreConfigRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PublishConnectionDetailsWithStoreConfigRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referenced StoreConfig.
    """


class ConnectionDetail(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ConnectionDetail"]:
            return ConnectionDetail

        def build(self) -> "ConnectionDetail":
            return ConnectionDetail(**self._attrs)

        def from_connection_secret_key(self, value: Optional[str], /) -> Self:
            """
            FromConnectionSecretKey is the key that will be used to fetch the value
            from the composed resource's connection secret.
            """
            return self._set("from_connection_secret_key", value)

        def from_field_path(self, value: Optional[str], /) -> Self:
            """
            FromFieldPath is the path of the field on the composed resource whose
            value to be used as input. Name must be specified if the type is
            FromFieldPath.
            """
            return self._set("from_field_path", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the connection secret key that will be propagated to the
            connection secret of the composition instance. Leave empty if you'd like
            to use the same key name.
            """
            return self._set("name", value)

        def type(
            self,
            value: Optional[Literal["FromConnectionSecretKey", "FromFieldPath", "FromValue"]],
            /,
        ) -> Self:
            """
            Type sets the connection detail fetching behaviour to be used. Each
            connection detail type may require its own fields to be set on the
            ConnectionDetail object. If the type is omitted Crossplane will attempt
            to infer it based on which other fields were specified. If multiple
            fields are specified the order of precedence is:
            1. FromValue
            2. FromConnectionSecretKey
            3. FromFieldPath
            """
            return self._set("type", value)

        def value(self, value: Optional[str], /) -> Self:
            """
            Value that will be propagated to the connection secret of the composite
            resource. May be set to inject a fixed, non-sensitive connection secret
            value, for example a well-known port.
            """
            return self._set("value", value)

    class BuilderContext(BuilderContextBase["ConnectionDetail.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ConnectionDetail.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ConnectionDetail."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ConnectionDetail", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ConnectionDetail.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_connection_secret_key: Annotated[Optional[str], Field(alias="fromConnectionSecretKey")] = (
        None
    )
    """
    FromConnectionSecretKey is the key that will be used to fetch the value
    from the composed resource's connection secret.
    """
    from_field_path: Annotated[Optional[str], Field(alias="fromFieldPath")] = None
    """
    FromFieldPath is the path of the field on the composed resource whose
    value to be used as input. Name must be specified if the type is
    FromFieldPath.
    """
    name: Optional[str] = None
    """
    Name of the connection secret key that will be propagated to the
    connection secret of the composition instance. Leave empty if you'd like
    to use the same key name.
    """
    type: Optional[Literal["FromConnectionSecretKey", "FromFieldPath", "FromValue"]] = None
    """
    Type sets the connection detail fetching behaviour to be used. Each
    connection detail type may require its own fields to be set on the
    ConnectionDetail object. If the type is omitted Crossplane will attempt
    to infer it based on which other fields were specified. If multiple
    fields are specified the order of precedence is:
    1. FromValue
    2. FromConnectionSecretKey
    3. FromFieldPath
    """
    value: Optional[str] = None
    """
    Value that will be propagated to the connection secret of the composite
    resource. May be set to inject a fixed, non-sensitive connection secret
    value, for example a well-known port.
    """


class StringModel3(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel3"]:
            return StringModel3

        def build(self) -> "StringModel3":
            return StringModel3(**self._attrs)

        def fmt(self, value: str, /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

    class BuilderContext(BuilderContextBase["StringModel3.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel3.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel3."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel3", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel3.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    fmt: str
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """


class StringModel4(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StringModel4"]:
            return StringModel4

        def build(self) -> "StringModel4":
            return StringModel4(**self._attrs)

        def convert(
            self,
            value: Optional[
                Literal[
                    "ToUpper",
                    "ToLower",
                    "ToBase64",
                    "FromBase64",
                    "ToJson",
                    "ToSha1",
                    "ToSha256",
                    "ToSha512",
                    "ToAdler32",
                ]
            ],
            /,
        ) -> Self:
            """
            Optional conversion method to be specified.
            `ToUpper` and `ToLower` change the letter case of the input string.
            `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
            `ToJson` converts any input value into its raw JSON representation.
            `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
            converted to JSON.
            `ToAdler32` generate a addler32 hash based on the input string.
            """
            return self._set("convert", value)

        def fmt(self, value: Optional[str], /) -> Self:
            """
            Format the input using a Go format string. See
            https://golang.org/pkg/fmt/ for details.
            """
            return self._set("fmt", value)

        @overload
        def join(self, value_or_callback: Optional[Join], /) -> "StringModel4.Builder": ...

        @overload
        def join(
            self, value_or_callback: Callable[[Join.Builder], Join.Builder | Join], /
        ) -> "StringModel4.Builder": ...

        @overload
        def join(self, value_or_callback: Never = ...) -> "Join.BuilderContext": ...

        def join(self, value_or_callback=None, /):
            """
            Join defines parameters to join a slice of values to a string.
            """
            if self._in_context and value_or_callback is None:
                context = Join.BuilderContext()
                context._parent_builder = self
                context._field_name = "join"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Join.builder())
                if isinstance(output, Join.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("join", value)

        @overload
        def regexp(self, value_or_callback: Optional[Regexp], /) -> "StringModel4.Builder": ...

        @overload
        def regexp(
            self,
            value_or_callback: Callable[[Regexp.Builder], Regexp.Builder | Regexp],
            /,
        ) -> "StringModel4.Builder": ...

        @overload
        def regexp(self, value_or_callback: Never = ...) -> "Regexp.BuilderContext": ...

        def regexp(self, value_or_callback=None, /):
            """
            Extract a match from the input using a regular expression.
            """
            if self._in_context and value_or_callback is None:
                context = Regexp.BuilderContext()
                context._parent_builder = self
                context._field_name = "regexp"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Regexp.builder())
                if isinstance(output, Regexp.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("regexp", value)

        def trim(self, value: Optional[str], /) -> Self:
            """
            Trim the prefix or suffix from the input
            """
            return self._set("trim", value)

        def type(
            self,
            value: Optional[
                Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]
            ],
            /,
        ) -> Self:
            """
            Type of the string transform to be run.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["StringModel4.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StringModel4.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StringModel4."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StringModel4", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StringModel4.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    convert: Optional[
        Literal[
            "ToUpper",
            "ToLower",
            "ToBase64",
            "FromBase64",
            "ToJson",
            "ToSha1",
            "ToSha256",
            "ToSha512",
            "ToAdler32",
        ]
    ] = None
    """
    Optional conversion method to be specified.
    `ToUpper` and `ToLower` change the letter case of the input string.
    `ToBase64` and `FromBase64` perform a base64 conversion based on the input string.
    `ToJson` converts any input value into its raw JSON representation.
    `ToSha1`, `ToSha256` and `ToSha512` generate a hash value based on the input
    converted to JSON.
    `ToAdler32` generate a addler32 hash based on the input string.
    """
    fmt: Optional[str] = None
    """
    Format the input using a Go format string. See
    https://golang.org/pkg/fmt/ for details.
    """
    join: Optional[Join] = None
    """
    Join defines parameters to join a slice of values to a string.
    """
    regexp: Optional[Regexp] = None
    """
    Extract a match from the input using a regular expression.
    """
    trim: Optional[str] = None
    """
    Trim the prefix or suffix from the input
    """
    type: Optional[Literal["Format", "Convert", "TrimPrefix", "TrimSuffix", "Regexp", "Join"]] = (
        "Format"
    )
    """
    Type of the string transform to be run.
    """


class MatchCondition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchCondition"]:
            return MatchCondition

        def build(self) -> "MatchCondition":
            return MatchCondition(**self._attrs)

        def status(self, value: Optional[str], /) -> Self:
            """
            Status is the status of the condition you'd like to match.
            """
            return self._set("status", value)

        def type(self, value: Optional[str], /) -> Self:
            """
            Type indicates the type of condition you'd like to use.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["MatchCondition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchCondition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchCondition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchCondition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchCondition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    status: Optional[str] = "True"
    """
    Status is the status of the condition you'd like to match.
    """
    type: Optional[str] = "Ready"
    """
    Type indicates the type of condition you'd like to use.
    """


class ReadinessCheck(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ReadinessCheck"]:
            return ReadinessCheck

        def build(self) -> "ReadinessCheck":
            return ReadinessCheck(**self._attrs)

        def field_path(self, value: Optional[str], /) -> Self:
            """
            FieldPath shows the path of the field whose value will be used.
            """
            return self._set("field_path", value)

        @overload
        def match_condition(
            self, value_or_callback: Optional[MatchCondition], /
        ) -> "ReadinessCheck.Builder": ...

        @overload
        def match_condition(
            self,
            value_or_callback: Callable[
                [MatchCondition.Builder], MatchCondition.Builder | MatchCondition
            ],
            /,
        ) -> "ReadinessCheck.Builder": ...

        @overload
        def match_condition(
            self, value_or_callback: Never = ...
        ) -> "MatchCondition.BuilderContext": ...

        def match_condition(self, value_or_callback=None, /):
            """
            MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
            """
            if self._in_context and value_or_callback is None:
                context = MatchCondition.BuilderContext()
                context._parent_builder = self
                context._field_name = "match_condition"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchCondition.builder())
                if isinstance(output, MatchCondition.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_condition", value)

        def match_integer(self, value: Optional[int], /) -> Self:
            """
            MatchInt is the value you'd like to match if you're using "MatchInt" type.
            """
            return self._set("match_integer", value)

        def match_string(self, value: Optional[str], /) -> Self:
            """
            MatchString is the value you'd like to match if you're using "MatchString" type.
            """
            return self._set("match_string", value)

        def type(
            self,
            value: Literal[
                "MatchString",
                "MatchInteger",
                "NonEmpty",
                "MatchCondition",
                "MatchTrue",
                "MatchFalse",
                "None",
            ],
            /,
        ) -> Self:
            """
            Type indicates the type of probe you'd like to use.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["ReadinessCheck.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ReadinessCheck.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ReadinessCheck."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ReadinessCheck", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ReadinessCheck.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    field_path: Annotated[Optional[str], Field(alias="fieldPath")] = None
    """
    FieldPath shows the path of the field whose value will be used.
    """
    match_condition: Annotated[Optional[MatchCondition], Field(alias="matchCondition")] = None
    """
    MatchCondition specifies the condition you'd like to match if you're using "MatchCondition" type.
    """
    match_integer: Annotated[Optional[int], Field(alias="matchInteger")] = None
    """
    MatchInt is the value you'd like to match if you're using "MatchInt" type.
    """
    match_string: Annotated[Optional[str], Field(alias="matchString")] = None
    """
    MatchString is the value you'd like to match if you're using "MatchString" type.
    """
    type: Literal[
        "MatchString",
        "MatchInteger",
        "NonEmpty",
        "MatchCondition",
        "MatchTrue",
        "MatchFalse",
        "None",
    ]
    """
    Type indicates the type of probe you'd like to use.
    """


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def base(self, value: Dict[str, Any], /) -> Self:
            """
            Base is the target resource that the patches will be applied on.
            """
            return self._set("base", value)

        @overload
        def connection_details(
            self, value_or_callback: List[ConnectionDetail], /
        ) -> "ResourceModel.Builder": ...

        @overload
        def connection_details(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ConnectionDetail, ConnectionDetail.Builder]],
                GenericListBuilder[ConnectionDetail, ConnectionDetail.Builder]
                | List[ConnectionDetail],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def connection_details(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ConnectionDetail.Builder]: ...

        def connection_details(self, value_or_callback=None, /):
            """
            ConnectionDetails lists the propagation secret keys from this target
            resource to the composition instance connection secret.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ConnectionDetail.Builder]()
                context._parent_builder = self
                context._field_name = "connection_details"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ConnectionDetail.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("connection_details", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            A Name uniquely identifies this entry within its Composition's resources
            array. Names are optional but *strongly* recommended. When all entries in
            the resources array are named entries may added, deleted, and reordered
            as long as their names do not change. When entries are not named the
            length and order of the resources array should be treated as immutable.
            Either all or no entries must be named.
            """
            return self._set("name", value)

        @overload
        def patches(self, value_or_callback: List[PatchModel], /) -> "ResourceModel.Builder": ...

        @overload
        def patches(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchModel, PatchModel.Builder]],
                GenericListBuilder[PatchModel, PatchModel.Builder] | List[PatchModel],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def patches(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchModel.Builder]: ...

        def patches(self, value_or_callback=None, /):
            """
            Patches will be applied as overlay to the base resource.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchModel.Builder]()
                context._parent_builder = self
                context._field_name = "patches"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patches", value)

        @overload
        def readiness_checks(
            self, value_or_callback: List[ReadinessCheck], /
        ) -> "ResourceModel.Builder": ...

        @overload
        def readiness_checks(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ReadinessCheck, ReadinessCheck.Builder]],
                GenericListBuilder[ReadinessCheck, ReadinessCheck.Builder] | List[ReadinessCheck],
            ],
            /,
        ) -> "ResourceModel.Builder": ...

        @overload
        def readiness_checks(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ReadinessCheck.Builder]: ...

        def readiness_checks(self, value_or_callback=None, /):
            """
            ReadinessChecks allows users to define custom readiness checks. All checks
            have to return true in order for resource to be considered ready. The
            default readiness check is to have the "Ready" condition to be "True".
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ReadinessCheck.Builder]()
                context._parent_builder = self
                context._field_name = "readiness_checks"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ReadinessCheck.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("readiness_checks", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    base: Dict[str, Any]
    """
    Base is the target resource that the patches will be applied on.
    """
    connection_details: Annotated[
        Optional[List[ConnectionDetail]], Field(alias="connectionDetails")
    ] = None
    """
    ConnectionDetails lists the propagation secret keys from this target
    resource to the composition instance connection secret.
    """
    name: Optional[str] = None
    """
    A Name uniquely identifies this entry within its Composition's resources
    array. Names are optional but *strongly* recommended. When all entries in
    the resources array are named entries may added, deleted, and reordered
    as long as their names do not change. When entries are not named the
    length and order of the resources array should be treated as immutable.
    Either all or no entries must be named.
    """
    patches: Optional[List[PatchModel]] = None
    """
    Patches will be applied as overlay to the base resource.
    """
    readiness_checks: Annotated[Optional[List[ReadinessCheck]], Field(alias="readinessChecks")] = [
        {
            "matchCondition": {"status": "True", "type": "Ready"},
            "type": "MatchCondition",
        }
    ]
    """
    ReadinessChecks allows users to define custom readiness checks. All checks
    have to return true in order for resource to be considered ready. The
    default readiness check is to have the "Ready" condition to be "True".
    """


class CompositionSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CompositionSpec"]:
            return CompositionSpec

        def build(self) -> "CompositionSpec":
            return CompositionSpec(**self._attrs)

        @overload
        def composite_type_ref(
            self, value_or_callback: CompositeTypeRef, /
        ) -> "CompositionSpec.Builder": ...

        @overload
        def composite_type_ref(
            self,
            value_or_callback: Callable[
                [CompositeTypeRef.Builder], CompositeTypeRef.Builder | CompositeTypeRef
            ],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def composite_type_ref(
            self, value_or_callback: Never = ...
        ) -> "CompositeTypeRef.BuilderContext": ...

        def composite_type_ref(self, value_or_callback=None, /):
            """
            CompositeTypeRef specifies the type of composite resource that this
            composition is compatible with.
            """
            if self._in_context and value_or_callback is None:
                context = CompositeTypeRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "composite_type_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositeTypeRef.builder())
                if isinstance(output, CompositeTypeRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("composite_type_ref", value)

        @overload
        def environment(
            self, value_or_callback: Optional[Environment], /
        ) -> "CompositionSpec.Builder": ...

        @overload
        def environment(
            self,
            value_or_callback: Callable[[Environment.Builder], Environment.Builder | Environment],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def environment(self, value_or_callback: Never = ...) -> "Environment.BuilderContext": ...

        def environment(self, value_or_callback=None, /):
            """
            Environment configures the environment in which resources are rendered.


            THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
            unless the relevant Crossplane feature flag is enabled, and may be
            changed or removed without notice.
            """
            if self._in_context and value_or_callback is None:
                context = Environment.BuilderContext()
                context._parent_builder = self
                context._field_name = "environment"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Environment.builder())
                if isinstance(output, Environment.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("environment", value)

        def mode(self, value: Optional[Literal["Resources", "Pipeline"]], /) -> Self:
            """
            Mode controls what type or "mode" of Composition will be used.


            "Pipeline" indicates that a Composition specifies a pipeline of
            Composition Functions, each of which is responsible for producing
            composed resources that Crossplane should create or update.


            "Resources" indicates that a Composition uses what is commonly referred
            to as "Patch & Transform" or P&T composition. This mode of Composition
            uses an array of resources, each a template for a composed resource.


            All Compositions should use Pipeline mode. Resources mode is deprecated.
            Resources mode won't be removed in Crossplane 1.x, and will remain the
            default to avoid breaking legacy Compositions. However, it's no longer
            accepting new features, and only accepting security related bug fixes.
            """
            return self._set("mode", value)

        @overload
        def patch_sets(self, value_or_callback: List[PatchSet], /) -> "CompositionSpec.Builder": ...

        @overload
        def patch_sets(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[PatchSet, PatchSet.Builder]],
                GenericListBuilder[PatchSet, PatchSet.Builder] | List[PatchSet],
            ],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def patch_sets(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[PatchSet.Builder]: ...

        def patch_sets(self, value_or_callback=None, /):
            """
            PatchSets define a named set of patches that may be included by any
            resource in this Composition. PatchSets cannot themselves refer to other
            PatchSets.


            PatchSets are only used by the "Resources" mode of Composition. They
            are ignored by other modes.


            Deprecated: Use Composition Functions instead.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[PatchSet.Builder]()
                context._parent_builder = self
                context._field_name = "patch_sets"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PatchSet.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("patch_sets", value)

        @overload
        def pipeline(self, value_or_callback: List[Pipeline], /) -> "CompositionSpec.Builder": ...

        @overload
        def pipeline(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Pipeline, Pipeline.Builder]],
                GenericListBuilder[Pipeline, Pipeline.Builder] | List[Pipeline],
            ],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def pipeline(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Pipeline.Builder]: ...

        def pipeline(self, value_or_callback=None, /):
            """
            Pipeline is a list of composition function steps that will be used when a
            composite resource referring to this composition is created. One of
            resources and pipeline must be specified - you cannot specify both.


            The Pipeline is only used by the "Pipeline" mode of Composition. It is
            ignored by other modes.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Pipeline.Builder]()
                context._parent_builder = self
                context._field_name = "pipeline"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Pipeline.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("pipeline", value)

        @overload
        def publish_connection_details_with_store_config_ref(
            self,
            value_or_callback: Optional[PublishConnectionDetailsWithStoreConfigRef],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def publish_connection_details_with_store_config_ref(
            self,
            value_or_callback: Callable[
                [PublishConnectionDetailsWithStoreConfigRef.Builder],
                PublishConnectionDetailsWithStoreConfigRef.Builder
                | PublishConnectionDetailsWithStoreConfigRef,
            ],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def publish_connection_details_with_store_config_ref(
            self, value_or_callback: Never = ...
        ) -> "PublishConnectionDetailsWithStoreConfigRef.BuilderContext": ...

        def publish_connection_details_with_store_config_ref(self, value_or_callback=None, /):
            """
            PublishConnectionDetailsWithStoreConfig specifies the secret store config
            with which the connection details of composite resources dynamically
            provisioned using this composition will be published.


            THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
            unless the relevant Crossplane feature flag is enabled, and may be
            changed or removed without notice.
            """
            if self._in_context and value_or_callback is None:
                context = PublishConnectionDetailsWithStoreConfigRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "publish_connection_details_with_store_config_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PublishConnectionDetailsWithStoreConfigRef.builder())
                if isinstance(output, PublishConnectionDetailsWithStoreConfigRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("publish_connection_details_with_store_config_ref", value)

        @overload
        def resources(
            self, value_or_callback: List[ResourceModel], /
        ) -> "CompositionSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "CompositionSpec.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resources is a list of resource templates that will be used when a
            composite resource referring to this composition is created.


            Resources are only used by the "Resources" mode of Composition. They are
            ignored by other modes.


            Deprecated: Use Composition Functions instead.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def write_connection_secrets_to_namespace(self, value: Optional[str], /) -> Self:
            """
            WriteConnectionSecretsToNamespace specifies the namespace in which the
            connection secrets of composite resource dynamically provisioned using
            this composition will be created.
            This field is planned to be replaced in a future release in favor of
            PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
            set independently and connection details would be published to both
            without affecting each other as long as related fields at MR level
            specified.
            """
            return self._set("write_connection_secrets_to_namespace", value)

    class BuilderContext(BuilderContextBase["CompositionSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CompositionSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CompositionSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CompositionSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CompositionSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    composite_type_ref: Annotated[CompositeTypeRef, Field(alias="compositeTypeRef")]
    """
    CompositeTypeRef specifies the type of composite resource that this
    composition is compatible with.
    """
    environment: Optional[Environment] = None
    """
    Environment configures the environment in which resources are rendered.


    THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
    unless the relevant Crossplane feature flag is enabled, and may be
    changed or removed without notice.
    """
    mode: Optional[Literal["Resources", "Pipeline"]] = "Resources"
    """
    Mode controls what type or "mode" of Composition will be used.


    "Pipeline" indicates that a Composition specifies a pipeline of
    Composition Functions, each of which is responsible for producing
    composed resources that Crossplane should create or update.


    "Resources" indicates that a Composition uses what is commonly referred
    to as "Patch & Transform" or P&T composition. This mode of Composition
    uses an array of resources, each a template for a composed resource.


    All Compositions should use Pipeline mode. Resources mode is deprecated.
    Resources mode won't be removed in Crossplane 1.x, and will remain the
    default to avoid breaking legacy Compositions. However, it's no longer
    accepting new features, and only accepting security related bug fixes.
    """
    patch_sets: Annotated[Optional[List[PatchSet]], Field(alias="patchSets")] = None
    """
    PatchSets define a named set of patches that may be included by any
    resource in this Composition. PatchSets cannot themselves refer to other
    PatchSets.


    PatchSets are only used by the "Resources" mode of Composition. They
    are ignored by other modes.


    Deprecated: Use Composition Functions instead.
    """
    pipeline: Optional[List[Pipeline]] = None
    """
    Pipeline is a list of composition function steps that will be used when a
    composite resource referring to this composition is created. One of
    resources and pipeline must be specified - you cannot specify both.


    The Pipeline is only used by the "Pipeline" mode of Composition. It is
    ignored by other modes.
    """
    publish_connection_details_with_store_config_ref: Annotated[
        Optional[PublishConnectionDetailsWithStoreConfigRef],
        Field(alias="publishConnectionDetailsWithStoreConfigRef"),
    ] = {"name": "default"}
    """
    PublishConnectionDetailsWithStoreConfig specifies the secret store config
    with which the connection details of composite resources dynamically
    provisioned using this composition will be published.


    THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
    unless the relevant Crossplane feature flag is enabled, and may be
    changed or removed without notice.
    """
    resources: Optional[List[ResourceModel]] = None
    """
    Resources is a list of resource templates that will be used when a
    composite resource referring to this composition is created.


    Resources are only used by the "Resources" mode of Composition. They are
    ignored by other modes.


    Deprecated: Use Composition Functions instead.
    """
    write_connection_secrets_to_namespace: Annotated[
        Optional[str], Field(alias="writeConnectionSecretsToNamespace")
    ] = None
    """
    WriteConnectionSecretsToNamespace specifies the namespace in which the
    connection secrets of composite resource dynamically provisioned using
    this composition will be created.
    This field is planned to be replaced in a future release in favor of
    PublishConnectionDetailsWithStoreConfigRef. Currently, both could be
    set independently and connection details would be published to both
    without affecting each other as long as related fields at MR level
    specified.
    """


class Composition(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Composition"]:
            return Composition

        def build(self) -> "Composition":
            return Composition(**self._attrs)

        def api_version(
            self, value: Optional[Literal["apiextensions.crossplane.io/v1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["Composition"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "Composition.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "Composition.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[CompositionSpec], /
        ) -> "Composition.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [CompositionSpec.Builder], CompositionSpec.Builder | CompositionSpec
            ],
            /,
        ) -> "Composition.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "CompositionSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CompositionSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CompositionSpec.builder())
                if isinstance(output, CompositionSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["Composition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Composition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Composition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Composition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Composition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["apiextensions.crossplane.io/v1"]], Field(alias="apiVersion")
    ] = "apiextensions.crossplane.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["Composition"]] = "Composition"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[CompositionSpec] = None
