# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ....k8s.apimachinery.pkg.apis.meta import v1


class Repository(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Repository"]:
            return Repository

        def build(self) -> "Repository":
            return Repository(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["Repository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Repository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Repository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Repository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Repository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Include(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Include"]:
            return Include

        def build(self) -> "Include":
            return Include(**self._attrs)

        def from_path(self, value: Optional[str], /) -> Self:
            """
            FromPath specifies the path to copy contents from, defaults to the root
            of the Artifact.
            """
            return self._set("from_path", value)

        @overload
        def repository(self, value_or_callback: Repository, /) -> "Include.Builder": ...

        @overload
        def repository(
            self,
            value_or_callback: Callable[[Repository.Builder], Repository.Builder | Repository],
            /,
        ) -> "Include.Builder": ...

        @overload
        def repository(self, value_or_callback: Never = ...) -> "Repository.BuilderContext": ...

        def repository(self, value_or_callback=None, /):
            """
            GitRepositoryRef specifies the GitRepository which Artifact contents
            must be included.
            """
            if self._in_context and value_or_callback is None:
                context = Repository.BuilderContext()
                context._parent_builder = self
                context._field_name = "repository"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Repository.builder())
                if isinstance(output, Repository.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("repository", value)

        def to_path(self, value: Optional[str], /) -> Self:
            """
            ToPath specifies the path to copy contents to, defaults to the name of
            the GitRepositoryRef.
            """
            return self._set("to_path", value)

    class BuilderContext(BuilderContextBase["Include.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Include.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Include."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Include", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Include.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[Optional[str], Field(alias="fromPath")] = None
    """
    FromPath specifies the path to copy contents from, defaults to the root
    of the Artifact.
    """
    repository: Repository
    """
    GitRepositoryRef specifies the GitRepository which Artifact contents
    must be included.
    """
    to_path: Annotated[Optional[str], Field(alias="toPath")] = None
    """
    ToPath specifies the path to copy contents to, defaults to the name of
    the GitRepositoryRef.
    """


class ProxySecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ProxySecretRef"]:
            return ProxySecretRef

        def build(self) -> "ProxySecretRef":
            return ProxySecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ProxySecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ProxySecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ProxySecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ProxySecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ProxySecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Ref(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Ref"]:
            return Ref

        def build(self) -> "Ref":
            return Ref(**self._attrs)

        def branch(self, value: Optional[str], /) -> Self:
            """
            Branch to check out, defaults to 'master' if no other field is defined.
            """
            return self._set("branch", value)

        def commit(self, value: Optional[str], /) -> Self:
            """
            Commit SHA to check out, takes precedence over all reference fields.

            This can be combined with Branch to shallow clone the branch, in which
            the commit is expected to exist.
            """
            return self._set("commit", value)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

            It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
            Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
            """
            return self._set("name", value)

        def semver(self, value: Optional[str], /) -> Self:
            """
            SemVer tag expression to check out, takes precedence over Tag.
            """
            return self._set("semver", value)

        def tag(self, value: Optional[str], /) -> Self:
            """
            Tag to check out, takes precedence over Branch.
            """
            return self._set("tag", value)

    class BuilderContext(BuilderContextBase["Ref.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Ref.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Ref."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Ref", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Ref.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    branch: Optional[str] = None
    """
    Branch to check out, defaults to 'master' if no other field is defined.
    """
    commit: Optional[str] = None
    """
    Commit SHA to check out, takes precedence over all reference fields.

    This can be combined with Branch to shallow clone the branch, in which
    the commit is expected to exist.
    """
    name: Optional[str] = None
    """
    Name of the reference to check out; takes precedence over Branch, Tag and SemVer.

    It must be a valid Git reference: https://git-scm.com/docs/git-check-ref-format#_description
    Examples: "refs/heads/main", "refs/tags/v0.1.0", "refs/pull/420/head", "refs/merge-requests/1/head"
    """
    semver: Optional[str] = None
    """
    SemVer tag expression to check out, takes precedence over Tag.
    """
    tag: Optional[str] = None
    """
    Tag to check out, takes precedence over Branch.
    """


class SecretRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretRef"]:
            return SecretRef

        def build(self) -> "SecretRef":
            return SecretRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SecretRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name of the referent.
    """


class Verify(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Verify"]:
            return Verify

        def build(self) -> "Verify":
            return Verify(**self._attrs)

        def mode(self, value: Optional[Literal["head", "HEAD", "Tag", "TagAndHEAD"]], /) -> Self:
            """
            Mode specifies which Git object(s) should be verified.

            The variants "head" and "HEAD" both imply the same thing, i.e. verify
            the commit that the HEAD of the Git repository points to. The variant
            "head" solely exists to ensure backwards compatibility.
            """
            return self._set("mode", value)

        @overload
        def secret_ref(self, value_or_callback: SecretRef, /) -> "Verify.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "Verify.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing the public keys of trusted Git
            authors.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["Verify.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Verify.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Verify."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Verify", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Verify.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    mode: Optional[Literal["head", "HEAD", "Tag", "TagAndHEAD"]] = "HEAD"
    """
    Mode specifies which Git object(s) should be verified.

    The variants "head" and "HEAD" both imply the same thing, i.e. verify
    the commit that the HEAD of the Git repository points to. The variant
    "head" solely exists to ensure backwards compatibility.
    """
    secret_ref: Annotated[SecretRef, Field(alias="secretRef")]
    """
    SecretRef specifies the Secret containing the public keys of trusted Git
    authors.
    """


class GitRepositorySpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositorySpec"]:
            return GitRepositorySpec

        def build(self) -> "GitRepositorySpec":
            return GitRepositorySpec(**self._attrs)

        def ignore(self, value: Optional[str], /) -> Self:
            """
            Ignore overrides the set of excluded patterns in the .sourceignore format
            (which is the same as .gitignore). If not provided, a default will be used,
            consult the documentation for your version to find out what those are.
            """
            return self._set("ignore", value)

        @overload
        def include(self, value_or_callback: List[Include], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Include, Include.Builder]],
                GenericListBuilder[Include, Include.Builder] | List[Include],
            ],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def include(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Include.Builder]: ...

        def include(self, value_or_callback=None, /):
            """
            Include specifies a list of GitRepository resources which Artifacts
            should be included in the Artifact produced for this GitRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Include.Builder]()
                context._parent_builder = self
                context._field_name = "include"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Include.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("include", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which the GitRepository URL is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def provider(self, value: Optional[Literal["generic", "azure", "github"]], /) -> Self:
            """
            Provider used for authentication, can be 'azure', 'github', 'generic'.
            When not specified, defaults to 'generic'.
            """
            return self._set("provider", value)

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Optional[ProxySecretRef], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self,
            value_or_callback: Callable[
                [ProxySecretRef.Builder], ProxySecretRef.Builder | ProxySecretRef
            ],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def proxy_secret_ref(
            self, value_or_callback: Never = ...
        ) -> "ProxySecretRef.BuilderContext": ...

        def proxy_secret_ref(self, value_or_callback=None, /):
            """
            ProxySecretRef specifies the Secret containing the proxy configuration
            to use while communicating with the Git server.
            """
            if self._in_context and value_or_callback is None:
                context = ProxySecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "proxy_secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ProxySecretRef.builder())
                if isinstance(output, ProxySecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("proxy_secret_ref", value)

        def recurse_submodules(self, value: Optional[bool], /) -> Self:
            """
            RecurseSubmodules enables the initialization of all submodules within
            the GitRepository as cloned from the URL, using their default settings.
            """
            return self._set("recurse_submodules", value)

        @overload
        def ref(self, value_or_callback: Optional[Ref], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(
            self, value_or_callback: Callable[[Ref.Builder], Ref.Builder | Ref], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def ref(self, value_or_callback: Never = ...) -> "Ref.BuilderContext": ...

        def ref(self, value_or_callback=None, /):
            """
            Reference specifies the Git reference to resolve and monitor for
            changes, defaults to the 'master' branch.
            """
            if self._in_context and value_or_callback is None:
                context = Ref.BuilderContext()
                context._parent_builder = self
                context._field_name = "ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Ref.builder())
                if isinstance(output, Ref.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ref", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Secret containing authentication credentials for
            the GitRepository.
            For HTTPS repositories the Secret must contain 'username' and 'password'
            fields for basic auth or 'bearerToken' field for token auth.
            For SSH repositories the Secret must contain 'identity'
            and 'known_hosts' fields.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

        def sparse_checkout(self, value: Optional[List[str]], /) -> Self:
            """
            SparseCheckout specifies a list of directories to checkout when cloning
            the repository. If specified, only these directories are included in the
            Artifact produced for this GitRepository.
            """
            return self._set("sparse_checkout", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            GitRepository.
            """
            return self._set("suspend", value)

        def timeout(self, value: Optional[str], /) -> Self:
            """
            Timeout for Git operations like cloning, defaults to 60s.
            """
            return self._set("timeout", value)

        def url(self, value: str, /) -> Self:
            """
            URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
            """
            return self._set("url", value)

        @overload
        def verify(self, value_or_callback: Optional[Verify], /) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[Verify.Builder], Verify.Builder | Verify],
            /,
        ) -> "GitRepositorySpec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "Verify.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verification specifies the configuration to verify the Git commit
            signature(s).
            """
            if self._in_context and value_or_callback is None:
                context = Verify.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Verify.builder())
                if isinstance(output, Verify.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

    class BuilderContext(BuilderContextBase["GitRepositorySpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositorySpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositorySpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositorySpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositorySpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ignore: Optional[str] = None
    """
    Ignore overrides the set of excluded patterns in the .sourceignore format
    (which is the same as .gitignore). If not provided, a default will be used,
    consult the documentation for your version to find out what those are.
    """
    include: Optional[List[Include]] = None
    """
    Include specifies a list of GitRepository resources which Artifacts
    should be included in the Artifact produced for this GitRepository.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which the GitRepository URL is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    provider: Optional[Literal["generic", "azure", "github"]] = None
    """
    Provider used for authentication, can be 'azure', 'github', 'generic'.
    When not specified, defaults to 'generic'.
    """
    proxy_secret_ref: Annotated[Optional[ProxySecretRef], Field(alias="proxySecretRef")] = None
    """
    ProxySecretRef specifies the Secret containing the proxy configuration
    to use while communicating with the Git server.
    """
    recurse_submodules: Annotated[Optional[bool], Field(alias="recurseSubmodules")] = None
    """
    RecurseSubmodules enables the initialization of all submodules within
    the GitRepository as cloned from the URL, using their default settings.
    """
    ref: Optional[Ref] = None
    """
    Reference specifies the Git reference to resolve and monitor for
    changes, defaults to the 'master' branch.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Secret containing authentication credentials for
    the GitRepository.
    For HTTPS repositories the Secret must contain 'username' and 'password'
    fields for basic auth or 'bearerToken' field for token auth.
    For SSH repositories the Secret must contain 'identity'
    and 'known_hosts' fields.
    """
    sparse_checkout: Annotated[Optional[List[str]], Field(alias="sparseCheckout")] = None
    """
    SparseCheckout specifies a list of directories to checkout when cloning
    the repository. If specified, only these directories are included in the
    Artifact produced for this GitRepository.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    GitRepository.
    """
    timeout: Annotated[Optional[str], Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m))+$")] = "60s"
    """
    Timeout for Git operations like cloning, defaults to 60s.
    """
    url: Annotated[str, Field(pattern="^(http|https|ssh)://.*$")]
    """
    URL specifies the Git repository URL, it can be an HTTP/S or SSH address.
    """
    verify: Optional[Verify] = None
    """
    Verification specifies the configuration to verify the Git commit
    signature(s).
    """


class Artifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Artifact"]:
            return Artifact

        def build(self) -> "Artifact":
            return Artifact(**self._attrs)

        def digest(self, value: Optional[str], /) -> Self:
            """
            Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
            """
            return self._set("digest", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of the
            Artifact.
            """
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Metadata holds upstream information such as OCI annotations.
            """
            return self._set("metadata", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of the Artifact. It can be used to locate
            the file in the root of the Artifact storage on the local file system of
            the controller managing the Source.
            """
            return self._set("path", value)

        def revision(self, value: str, /) -> Self:
            """
            Revision is a human-readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
            """
            return self._set("revision", value)

        def size(self, value: Optional[int], /) -> Self:
            """
            Size is the number of bytes in the file.
            """
            return self._set("size", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of the Artifact as exposed by the controller
            managing the Source. It can be used to retrieve the Artifact for
            consumption, e.g. by another controller applying the Artifact contents.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["Artifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Artifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Artifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Artifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Artifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str], Field(pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$")
    ] = None
    """
    Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of the
    Artifact.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    Metadata holds upstream information such as OCI annotations.
    """
    path: str
    """
    Path is the relative file path of the Artifact. It can be used to locate
    the file in the root of the Artifact storage on the local file system of
    the controller managing the Source.
    """
    revision: str
    """
    Revision is a human-readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
    """
    size: Optional[int] = None
    """
    Size is the number of bytes in the file.
    """
    url: str
    """
    URL is the HTTP address of the Artifact as exposed by the controller
    managing the Source. It can be used to retrieve the Artifact for
    consumption, e.g. by another controller applying the Artifact contents.
    """


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another.
            This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition.
            This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon.
            For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
            with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition.
            Producers of specific condition types may define expected values and meanings for this field,
            and whether the values are considered a guaranteed API.
            The value should be a CamelCase string.
            This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase.
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another.
    This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition.
    This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon.
    For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
    with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition.
    Producers of specific condition types may define expected values and meanings for this field,
    and whether the values are considered a guaranteed API.
    The value should be a CamelCase string.
    This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase.
    """


class IncludedArtifact(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["IncludedArtifact"]:
            return IncludedArtifact

        def build(self) -> "IncludedArtifact":
            return IncludedArtifact(**self._attrs)

        def digest(self, value: Optional[str], /) -> Self:
            """
            Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
            """
            return self._set("digest", value)

        def last_update_time(self, value: datetime, /) -> Self:
            """
            LastUpdateTime is the timestamp corresponding to the last update of the
            Artifact.
            """
            return self._set("last_update_time", value)

        def metadata(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            Metadata holds upstream information such as OCI annotations.
            """
            return self._set("metadata", value)

        def path(self, value: str, /) -> Self:
            """
            Path is the relative file path of the Artifact. It can be used to locate
            the file in the root of the Artifact storage on the local file system of
            the controller managing the Source.
            """
            return self._set("path", value)

        def revision(self, value: str, /) -> Self:
            """
            Revision is a human-readable identifier traceable in the origin source
            system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
            """
            return self._set("revision", value)

        def size(self, value: Optional[int], /) -> Self:
            """
            Size is the number of bytes in the file.
            """
            return self._set("size", value)

        def url(self, value: str, /) -> Self:
            """
            URL is the HTTP address of the Artifact as exposed by the controller
            managing the Source. It can be used to retrieve the Artifact for
            consumption, e.g. by another controller applying the Artifact contents.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["IncludedArtifact.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = IncludedArtifact.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for IncludedArtifact."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["IncludedArtifact", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use IncludedArtifact.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    digest: Annotated[
        Optional[str], Field(pattern="^[a-z0-9]+(?:[.+_-][a-z0-9]+)*:[a-zA-Z0-9=_-]+$")
    ] = None
    """
    Digest is the digest of the file in the form of '<algorithm>:<checksum>'.
    """
    last_update_time: Annotated[datetime, Field(alias="lastUpdateTime")]
    """
    LastUpdateTime is the timestamp corresponding to the last update of the
    Artifact.
    """
    metadata: Optional[Dict[str, str]] = None
    """
    Metadata holds upstream information such as OCI annotations.
    """
    path: str
    """
    Path is the relative file path of the Artifact. It can be used to locate
    the file in the root of the Artifact storage on the local file system of
    the controller managing the Source.
    """
    revision: str
    """
    Revision is a human-readable identifier traceable in the origin source
    system. It can be a Git commit SHA, Git tag, a Helm chart version, etc.
    """
    size: Optional[int] = None
    """
    Size is the number of bytes in the file.
    """
    url: str
    """
    URL is the HTTP address of the Artifact as exposed by the controller
    managing the Source. It can be used to retrieve the Artifact for
    consumption, e.g. by another controller applying the Artifact contents.
    """


class ObservedInclude(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ObservedInclude"]:
            return ObservedInclude

        def build(self) -> "ObservedInclude":
            return ObservedInclude(**self._attrs)

        def from_path(self, value: Optional[str], /) -> Self:
            """
            FromPath specifies the path to copy contents from, defaults to the root
            of the Artifact.
            """
            return self._set("from_path", value)

        @overload
        def repository(self, value_or_callback: Repository, /) -> "ObservedInclude.Builder": ...

        @overload
        def repository(
            self,
            value_or_callback: Callable[[Repository.Builder], Repository.Builder | Repository],
            /,
        ) -> "ObservedInclude.Builder": ...

        @overload
        def repository(self, value_or_callback: Never = ...) -> "Repository.BuilderContext": ...

        def repository(self, value_or_callback=None, /):
            """
            GitRepositoryRef specifies the GitRepository which Artifact contents
            must be included.
            """
            if self._in_context and value_or_callback is None:
                context = Repository.BuilderContext()
                context._parent_builder = self
                context._field_name = "repository"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Repository.builder())
                if isinstance(output, Repository.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("repository", value)

        def to_path(self, value: Optional[str], /) -> Self:
            """
            ToPath specifies the path to copy contents to, defaults to the name of
            the GitRepositoryRef.
            """
            return self._set("to_path", value)

    class BuilderContext(BuilderContextBase["ObservedInclude.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ObservedInclude.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ObservedInclude."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ObservedInclude", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ObservedInclude.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    from_path: Annotated[Optional[str], Field(alias="fromPath")] = None
    """
    FromPath specifies the path to copy contents from, defaults to the root
    of the Artifact.
    """
    repository: Repository
    """
    GitRepositoryRef specifies the GitRepository which Artifact contents
    must be included.
    """
    to_path: Annotated[Optional[str], Field(alias="toPath")] = None
    """
    ToPath specifies the path to copy contents to, defaults to the name of
    the GitRepositoryRef.
    """


class GitRepositoryStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepositoryStatus"]:
            return GitRepositoryStatus

        def build(self) -> "GitRepositoryStatus":
            return GitRepositoryStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the last successful GitRepository reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the GitRepository.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        @overload
        def included_artifacts(
            self, value_or_callback: List[IncludedArtifact], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]],
                GenericListBuilder[IncludedArtifact, IncludedArtifact.Builder]
                | List[IncludedArtifact],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def included_artifacts(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[IncludedArtifact.Builder]: ...

        def included_artifacts(self, value_or_callback=None, /):
            """
            IncludedArtifacts contains a list of the last successfully included
            Artifacts as instructed by GitRepositorySpec.Include.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[IncludedArtifact.Builder]()
                context._parent_builder = self
                context._field_name = "included_artifacts"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(IncludedArtifact.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("included_artifacts", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the GitRepository
            object.
            """
            return self._set("observed_generation", value)

        def observed_ignore(self, value: Optional[str], /) -> Self:
            """
            ObservedIgnore is the observed exclusion patterns used for constructing
            the source artifact.
            """
            return self._set("observed_ignore", value)

        @overload
        def observed_include(
            self, value_or_callback: List[ObservedInclude], /
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def observed_include(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ObservedInclude, ObservedInclude.Builder]],
                GenericListBuilder[ObservedInclude, ObservedInclude.Builder]
                | List[ObservedInclude],
            ],
            /,
        ) -> "GitRepositoryStatus.Builder": ...

        @overload
        def observed_include(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ObservedInclude.Builder]: ...

        def observed_include(self, value_or_callback=None, /):
            """
            ObservedInclude is the observed list of GitRepository resources used to
            produce the current Artifact.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ObservedInclude.Builder]()
                context._parent_builder = self
                context._field_name = "observed_include"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ObservedInclude.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("observed_include", value)

        def observed_recurse_submodules(self, value: Optional[bool], /) -> Self:
            """
            ObservedRecurseSubmodules is the observed resource submodules
            configuration used to produce the current Artifact.
            """
            return self._set("observed_recurse_submodules", value)

        def observed_sparse_checkout(self, value: Optional[List[str]], /) -> Self:
            """
            ObservedSparseCheckout is the observed list of directories used to
            produce the current Artifact.
            """
            return self._set("observed_sparse_checkout", value)

        def source_verification_mode(self, value: Optional[str], /) -> Self:
            """
            SourceVerificationMode is the last used verification mode indicating
            which Git object(s) have been verified.
            """
            return self._set("source_verification_mode", value)

    class BuilderContext(BuilderContextBase["GitRepositoryStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepositoryStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepositoryStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepositoryStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepositoryStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the last successful GitRepository reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the GitRepository.
    """
    included_artifacts: Annotated[
        Optional[List[IncludedArtifact]], Field(alias="includedArtifacts")
    ] = None
    """
    IncludedArtifacts contains a list of the last successfully included
    Artifacts as instructed by GitRepositorySpec.Include.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the GitRepository
    object.
    """
    observed_ignore: Annotated[Optional[str], Field(alias="observedIgnore")] = None
    """
    ObservedIgnore is the observed exclusion patterns used for constructing
    the source artifact.
    """
    observed_include: Annotated[Optional[List[ObservedInclude]], Field(alias="observedInclude")] = (
        None
    )
    """
    ObservedInclude is the observed list of GitRepository resources used to
    produce the current Artifact.
    """
    observed_recurse_submodules: Annotated[
        Optional[bool], Field(alias="observedRecurseSubmodules")
    ] = None
    """
    ObservedRecurseSubmodules is the observed resource submodules
    configuration used to produce the current Artifact.
    """
    observed_sparse_checkout: Annotated[
        Optional[List[str]], Field(alias="observedSparseCheckout")
    ] = None
    """
    ObservedSparseCheckout is the observed list of directories used to
    produce the current Artifact.
    """
    source_verification_mode: Annotated[Optional[str], Field(alias="sourceVerificationMode")] = None
    """
    SourceVerificationMode is the last used verification mode indicating
    which Git object(s) have been verified.
    """


class SourceRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SourceRef"]:
            return SourceRef

        def build(self) -> "SourceRef":
            return SourceRef(**self._attrs)

        def api_version(self, value: Optional[str], /) -> Self:
            """
            APIVersion of the referent.
            """
            return self._set("api_version", value)

        def kind(self, value: Literal["HelmRepository", "GitRepository", "Bucket"], /) -> Self:
            """
            Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
            'Bucket').
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name of the referent.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["SourceRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SourceRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SourceRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SourceRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SourceRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[Optional[str], Field(alias="apiVersion")] = None
    """
    APIVersion of the referent.
    """
    kind: Literal["HelmRepository", "GitRepository", "Bucket"]
    """
    Kind of the referent, valid values are ('HelmRepository', 'GitRepository',
    'Bucket').
    """
    name: str
    """
    Name of the referent.
    """


class MatchOidcIdentity(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["MatchOidcIdentity"]:
            return MatchOidcIdentity

        def build(self) -> "MatchOidcIdentity":
            return MatchOidcIdentity(**self._attrs)

        def issuer(self, value: str, /) -> Self:
            """
            Issuer specifies the regex pattern to match against to verify
            the OIDC issuer in the Fulcio certificate. The pattern must be a
            valid Go regular expression.
            """
            return self._set("issuer", value)

        def subject(self, value: str, /) -> Self:
            """
            Subject specifies the regex pattern to match against to verify
            the identity subject in the Fulcio certificate. The pattern must
            be a valid Go regular expression.
            """
            return self._set("subject", value)

    class BuilderContext(BuilderContextBase["MatchOidcIdentity.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = MatchOidcIdentity.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for MatchOidcIdentity."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["MatchOidcIdentity", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use MatchOidcIdentity.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    issuer: str
    """
    Issuer specifies the regex pattern to match against to verify
    the OIDC issuer in the Fulcio certificate. The pattern must be a
    valid Go regular expression.
    """
    subject: str
    """
    Subject specifies the regex pattern to match against to verify
    the identity subject in the Fulcio certificate. The pattern must
    be a valid Go regular expression.
    """


class VerifyModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VerifyModel"]:
            return VerifyModel

        def build(self) -> "VerifyModel":
            return VerifyModel(**self._attrs)

        @overload
        def match_oidc_identity(
            self, value_or_callback: List[MatchOidcIdentity], /
        ) -> "VerifyModel.Builder": ...

        @overload
        def match_oidc_identity(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder]],
                GenericListBuilder[MatchOidcIdentity, MatchOidcIdentity.Builder]
                | List[MatchOidcIdentity],
            ],
            /,
        ) -> "VerifyModel.Builder": ...

        @overload
        def match_oidc_identity(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[MatchOidcIdentity.Builder]: ...

        def match_oidc_identity(self, value_or_callback=None, /):
            """
            MatchOIDCIdentity specifies the identity matching criteria to use
            while verifying an OCI artifact which was signed using Cosign keyless
            signing. The artifact's identity is deemed to be verified if any of the
            specified matchers match against the identity.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[MatchOidcIdentity.Builder]()
                context._parent_builder = self
                context._field_name = "match_oidc_identity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(MatchOidcIdentity.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("match_oidc_identity", value)

        def provider(self, value: Optional[Literal["cosign", "notation"]], /) -> Self:
            """
            Provider specifies the technology used to sign the OCI Artifact.
            """
            return self._set("provider", value)

        @overload
        def secret_ref(
            self, value_or_callback: Optional[SecretRef], /
        ) -> "VerifyModel.Builder": ...

        @overload
        def secret_ref(
            self,
            value_or_callback: Callable[[SecretRef.Builder], SecretRef.Builder | SecretRef],
            /,
        ) -> "VerifyModel.Builder": ...

        @overload
        def secret_ref(self, value_or_callback: Never = ...) -> "SecretRef.BuilderContext": ...

        def secret_ref(self, value_or_callback=None, /):
            """
            SecretRef specifies the Kubernetes Secret containing the
            trusted public keys.
            """
            if self._in_context and value_or_callback is None:
                context = SecretRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "secret_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretRef.builder())
                if isinstance(output, SecretRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secret_ref", value)

    class BuilderContext(BuilderContextBase["VerifyModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VerifyModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VerifyModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VerifyModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VerifyModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    match_oidc_identity: Annotated[
        Optional[List[MatchOidcIdentity]], Field(alias="matchOIDCIdentity")
    ] = None
    """
    MatchOIDCIdentity specifies the identity matching criteria to use
    while verifying an OCI artifact which was signed using Cosign keyless
    signing. The artifact's identity is deemed to be verified if any of the
    specified matchers match against the identity.
    """
    provider: Optional[Literal["cosign", "notation"]] = "cosign"
    """
    Provider specifies the technology used to sign the OCI Artifact.
    """
    secret_ref: Annotated[Optional[SecretRef], Field(alias="secretRef")] = None
    """
    SecretRef specifies the Kubernetes Secret containing the
    trusted public keys.
    """


class HelmChartSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartSpec"]:
            return HelmChartSpec

        def build(self) -> "HelmChartSpec":
            return HelmChartSpec(**self._attrs)

        def chart(self, value: str, /) -> Self:
            """
            Chart is the name or path the Helm chart is available at in the
            SourceRef.
            """
            return self._set("chart", value)

        def ignore_missing_values_files(self, value: Optional[bool], /) -> Self:
            """
            IgnoreMissingValuesFiles controls whether to silently ignore missing values
            files rather than failing.
            """
            return self._set("ignore_missing_values_files", value)

        def interval(self, value: str, /) -> Self:
            """
            Interval at which the HelmChart SourceRef is checked for updates.
            This interval is approximate and may be subject to jitter to ensure
            efficient use of resources.
            """
            return self._set("interval", value)

        def reconcile_strategy(
            self, value: Optional[Literal["ChartVersion", "Revision"]], /
        ) -> Self:
            """
            ReconcileStrategy determines what enables the creation of a new artifact.
            Valid values are ('ChartVersion', 'Revision').
            See the documentation of the values for an explanation on their behavior.
            Defaults to ChartVersion when omitted.
            """
            return self._set("reconcile_strategy", value)

        @overload
        def source_ref(self, value_or_callback: SourceRef, /) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(
            self,
            value_or_callback: Callable[[SourceRef.Builder], SourceRef.Builder | SourceRef],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def source_ref(self, value_or_callback: Never = ...) -> "SourceRef.BuilderContext": ...

        def source_ref(self, value_or_callback=None, /):
            """
            SourceRef is the reference to the Source the chart is available at.
            """
            if self._in_context and value_or_callback is None:
                context = SourceRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "source_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SourceRef.builder())
                if isinstance(output, SourceRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("source_ref", value)

        def suspend(self, value: Optional[bool], /) -> Self:
            """
            Suspend tells the controller to suspend the reconciliation of this
            source.
            """
            return self._set("suspend", value)

        def values_files(self, value: Optional[List[str]], /) -> Self:
            """
            ValuesFiles is an alternative list of values files to use as the chart
            values (values.yaml is not included by default), expected to be a
            relative path in the SourceRef.
            Values files are merged in the order of this list with the last file
            overriding the first. Ignored when omitted.
            """
            return self._set("values_files", value)

        @overload
        def verify(
            self, value_or_callback: Optional[VerifyModel], /
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def verify(
            self,
            value_or_callback: Callable[[VerifyModel.Builder], VerifyModel.Builder | VerifyModel],
            /,
        ) -> "HelmChartSpec.Builder": ...

        @overload
        def verify(self, value_or_callback: Never = ...) -> "VerifyModel.BuilderContext": ...

        def verify(self, value_or_callback=None, /):
            """
            Verify contains the secret name containing the trusted public keys
            used to verify the signature and specifies which provider to use to check
            whether OCI image is authentic.
            This field is only supported when using HelmRepository source with spec.type 'oci'.
            Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
            """
            if self._in_context and value_or_callback is None:
                context = VerifyModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "verify"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VerifyModel.builder())
                if isinstance(output, VerifyModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("verify", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            Version is the chart version semver expression, ignored for charts from
            GitRepository and Bucket sources. Defaults to latest when omitted.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["HelmChartSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    chart: str
    """
    Chart is the name or path the Helm chart is available at in the
    SourceRef.
    """
    ignore_missing_values_files: Annotated[
        Optional[bool], Field(alias="ignoreMissingValuesFiles")
    ] = None
    """
    IgnoreMissingValuesFiles controls whether to silently ignore missing values
    files rather than failing.
    """
    interval: Annotated[str, Field(pattern="^([0-9]+(\\.[0-9]+)?(ms|s|m|h))+$")]
    """
    Interval at which the HelmChart SourceRef is checked for updates.
    This interval is approximate and may be subject to jitter to ensure
    efficient use of resources.
    """
    reconcile_strategy: Annotated[
        Optional[Literal["ChartVersion", "Revision"]], Field(alias="reconcileStrategy")
    ] = "ChartVersion"
    """
    ReconcileStrategy determines what enables the creation of a new artifact.
    Valid values are ('ChartVersion', 'Revision').
    See the documentation of the values for an explanation on their behavior.
    Defaults to ChartVersion when omitted.
    """
    source_ref: Annotated[SourceRef, Field(alias="sourceRef")]
    """
    SourceRef is the reference to the Source the chart is available at.
    """
    suspend: Optional[bool] = None
    """
    Suspend tells the controller to suspend the reconciliation of this
    source.
    """
    values_files: Annotated[Optional[List[str]], Field(alias="valuesFiles")] = None
    """
    ValuesFiles is an alternative list of values files to use as the chart
    values (values.yaml is not included by default), expected to be a
    relative path in the SourceRef.
    Values files are merged in the order of this list with the last file
    overriding the first. Ignored when omitted.
    """
    verify: Optional[VerifyModel] = None
    """
    Verify contains the secret name containing the trusted public keys
    used to verify the signature and specifies which provider to use to check
    whether OCI image is authentic.
    This field is only supported when using HelmRepository source with spec.type 'oci'.
    Chart dependencies, which are not bundled in the umbrella chart artifact, are not verified.
    """
    version: Optional[str] = "*"
    """
    Version is the chart version semver expression, ignored for charts from
    GitRepository and Bucket sources. Defaults to latest when omitted.
    """


class HelmChartStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChartStatus"]:
            return HelmChartStatus

        def build(self) -> "HelmChartStatus":
            return HelmChartStatus(**self._attrs)

        @overload
        def artifact(
            self, value_or_callback: Optional[Artifact], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(
            self,
            value_or_callback: Callable[[Artifact.Builder], Artifact.Builder | Artifact],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def artifact(self, value_or_callback: Never = ...) -> "Artifact.BuilderContext": ...

        def artifact(self, value_or_callback=None, /):
            """
            Artifact represents the output of the last successful reconciliation.
            """
            if self._in_context and value_or_callback is None:
                context = Artifact.BuilderContext()
                context._parent_builder = self
                context._field_name = "artifact"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Artifact.builder())
                if isinstance(output, Artifact.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("artifact", value)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "HelmChartStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            """
            Conditions holds the conditions for the HelmChart.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

        def last_handled_reconcile_at(self, value: Optional[str], /) -> Self:
            """
            LastHandledReconcileAt holds the value of the most recent
            reconcile request value, so a change of the annotation value
            can be detected.
            """
            return self._set("last_handled_reconcile_at", value)

        def observed_chart_name(self, value: Optional[str], /) -> Self:
            """
            ObservedChartName is the last observed chart name as specified by the
            resolved chart reference.
            """
            return self._set("observed_chart_name", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            ObservedGeneration is the last observed generation of the HelmChart
            object.
            """
            return self._set("observed_generation", value)

        def observed_source_artifact_revision(self, value: Optional[str], /) -> Self:
            """
            ObservedSourceArtifactRevision is the last observed Artifact.Revision
            of the HelmChartSpec.SourceRef.
            """
            return self._set("observed_source_artifact_revision", value)

        def observed_values_files(self, value: Optional[List[str]], /) -> Self:
            """
            ObservedValuesFiles are the observed value files of the last successful
            reconciliation.
            It matches the chart in the last successfully reconciled artifact.
            """
            return self._set("observed_values_files", value)

        def url(self, value: Optional[str], /) -> Self:
            """
            URL is the dynamic fetch link for the latest Artifact.
            It is provided on a "best effort" basis, and using the precise
            BucketStatus.Artifact data is recommended.
            """
            return self._set("url", value)

    class BuilderContext(BuilderContextBase["HelmChartStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChartStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChartStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChartStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChartStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    artifact: Optional[Artifact] = None
    """
    Artifact represents the output of the last successful reconciliation.
    """
    conditions: Optional[List[Condition]] = None
    """
    Conditions holds the conditions for the HelmChart.
    """
    last_handled_reconcile_at: Annotated[Optional[str], Field(alias="lastHandledReconcileAt")] = (
        None
    )
    """
    LastHandledReconcileAt holds the value of the most recent
    reconcile request value, so a change of the annotation value
    can be detected.
    """
    observed_chart_name: Annotated[Optional[str], Field(alias="observedChartName")] = None
    """
    ObservedChartName is the last observed chart name as specified by the
    resolved chart reference.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration")] = None
    """
    ObservedGeneration is the last observed generation of the HelmChart
    object.
    """
    observed_source_artifact_revision: Annotated[
        Optional[str], Field(alias="observedSourceArtifactRevision")
    ] = None
    """
    ObservedSourceArtifactRevision is the last observed Artifact.Revision
    of the HelmChartSpec.SourceRef.
    """
    observed_values_files: Annotated[Optional[List[str]], Field(alias="observedValuesFiles")] = None
    """
    ObservedValuesFiles are the observed value files of the last successful
    reconciliation.
    It matches the chart in the last successfully reconciled artifact.
    """
    url: Optional[str] = None
    """
    URL is the dynamic fetch link for the latest Artifact.
    It is provided on a "best effort" basis, and using the precise
    BucketStatus.Artifact data is recommended.
    """


class GitRepository(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GitRepository"]:
            return GitRepository

        def build(self) -> "GitRepository":
            return GitRepository(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["GitRepository"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[GitRepositorySpec], /
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [GitRepositorySpec.Builder],
                GitRepositorySpec.Builder | GitRepositorySpec,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "GitRepositorySpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositorySpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositorySpec.builder())
                if isinstance(output, GitRepositorySpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[GitRepositoryStatus], /
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [GitRepositoryStatus.Builder],
                GitRepositoryStatus.Builder | GitRepositoryStatus,
            ],
            /,
        ) -> "GitRepository.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "GitRepositoryStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GitRepositoryStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GitRepositoryStatus.builder())
                if isinstance(output, GitRepositoryStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["GitRepository.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GitRepository.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GitRepository."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GitRepository", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GitRepository.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["GitRepository"]] = "GitRepository"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[GitRepositorySpec] = None
    status: Optional[GitRepositoryStatus] = None


class HelmChart(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["HelmChart"]:
            return HelmChart

        def build(self) -> "HelmChart":
            return HelmChart(**self._attrs)

        def api_version(self, value: Optional[Literal["source.toolkit.fluxcd.io/v1"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["HelmChart"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[HelmChartSpec], /) -> "HelmChart.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [HelmChartSpec.Builder], HelmChartSpec.Builder | HelmChartSpec
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "HelmChartSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartSpec.builder())
                if isinstance(output, HelmChartSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[HelmChartStatus], /
        ) -> "HelmChart.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [HelmChartStatus.Builder], HelmChartStatus.Builder | HelmChartStatus
            ],
            /,
        ) -> "HelmChart.Builder": ...

        @overload
        def status(self, value_or_callback: Never = ...) -> "HelmChartStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = HelmChartStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(HelmChartStatus.builder())
                if isinstance(output, HelmChartStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["HelmChart.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = HelmChart.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for HelmChart."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["HelmChart", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use HelmChart.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["source.toolkit.fluxcd.io/v1"]], Field(alias="apiVersion")
    ] = "source.toolkit.fluxcd.io/v1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["HelmChart"]] = "HelmChart"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[HelmChartSpec] = None
    status: Optional[HelmChartStatus] = None
