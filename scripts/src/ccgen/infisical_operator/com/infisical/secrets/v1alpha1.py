# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from datetime import datetime
from typing import (
    Annotated,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ....io.k8s.apimachinery.pkg.apis.meta import v1


class SecretsScope(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScope"]:
            return SecretsScope

        def build(self) -> "SecretsScope":
            return SecretsScope(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def project_slug(self, value: str, /) -> Self:
            return self._set("project_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScope.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScope.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScope."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScope", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScope.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    project_slug: Annotated[str, Field(alias="projectSlug")]
    recursive: Optional[bool] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class AwsIamAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AwsIamAuth"]:
            return AwsIamAuth

        def build(self) -> "AwsIamAuth":
            return AwsIamAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "AwsIamAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "AwsIamAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["AwsIamAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AwsIamAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AwsIamAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AwsIamAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AwsIamAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class AzureAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AzureAuth"]:
            return AzureAuth

        def build(self) -> "AzureAuth":
            return AzureAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        def resource(self, value: Optional[str], /) -> Self:
            return self._set("resource", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "AzureAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "AzureAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["AzureAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AzureAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AzureAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AzureAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AzureAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    resource: Optional[str] = None
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class GcpIamAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIamAuth"]:
            return GcpIamAuth

        def build(self) -> "GcpIamAuth":
            return GcpIamAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "GcpIamAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "GcpIamAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        def service_account_key_file_path(self, value: str, /) -> Self:
            return self._set("service_account_key_file_path", value)

    class BuilderContext(BuilderContextBase["GcpIamAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIamAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIamAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIamAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIamAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]
    service_account_key_file_path: Annotated[str, Field(alias="serviceAccountKeyFilePath")]


class GcpIdTokenAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["GcpIdTokenAuth"]:
            return GcpIdTokenAuth

        def build(self) -> "GcpIdTokenAuth":
            return GcpIdTokenAuth(**self._attrs)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "GcpIdTokenAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "GcpIdTokenAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["GcpIdTokenAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = GcpIdTokenAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for GcpIdTokenAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["GcpIdTokenAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use GcpIdTokenAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]


class ServiceAccountRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountRef"]:
            return ServiceAccountRef

        def build(self) -> "ServiceAccountRef":
            return ServiceAccountRef(**self._attrs)

        def name(self, value: str, /) -> Self:
            return self._set("name", value)

        def namespace(self, value: str, /) -> Self:
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ServiceAccountRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    namespace: str


class KubernetesAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KubernetesAuth"]:
            return KubernetesAuth

        def build(self) -> "KubernetesAuth":
            return KubernetesAuth(**self._attrs)

        def auto_create_service_account_token(self, value: Optional[bool], /) -> Self:
            """
            Optionally automatically create a service account token for the configured service account. If this is set to `true`, the operator will automatically create a service account token for the configured service account.
            """
            return self._set("auto_create_service_account_token", value)

        def identity_id(self, value: str, /) -> Self:
            return self._set("identity_id", value)

        @overload
        def secrets_scope(self, value_or_callback: SecretsScope, /) -> "KubernetesAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScope.Builder], SecretsScope.Builder | SecretsScope
            ],
            /,
        ) -> "KubernetesAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScope.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScope.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScope.builder())
                if isinstance(output, SecretsScope.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        @overload
        def service_account_ref(
            self, value_or_callback: ServiceAccountRef, /
        ) -> "KubernetesAuth.Builder": ...

        @overload
        def service_account_ref(
            self,
            value_or_callback: Callable[
                [ServiceAccountRef.Builder],
                ServiceAccountRef.Builder | ServiceAccountRef,
            ],
            /,
        ) -> "KubernetesAuth.Builder": ...

        @overload
        def service_account_ref(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountRef.BuilderContext": ...

        def service_account_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccountRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountRef.builder())
                if isinstance(output, ServiceAccountRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_ref", value)

        def service_account_token_audiences(self, value: Optional[List[str]], /) -> Self:
            """
            The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
            """
            return self._set("service_account_token_audiences", value)

    class BuilderContext(BuilderContextBase["KubernetesAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KubernetesAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KubernetesAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KubernetesAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KubernetesAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    auto_create_service_account_token: Annotated[
        Optional[bool], Field(alias="autoCreateServiceAccountToken")
    ] = None
    """
    Optionally automatically create a service account token for the configured service account. If this is set to `true`, the operator will automatically create a service account token for the configured service account.
    """
    identity_id: Annotated[str, Field(alias="identityId")]
    secrets_scope: Annotated[SecretsScope, Field(alias="secretsScope")]
    service_account_ref: Annotated[ServiceAccountRef, Field(alias="serviceAccountRef")]
    service_account_token_audiences: Annotated[
        Optional[List[str]], Field(alias="serviceAccountTokenAudiences")
    ] = None
    """
    The audiences to use for the service account token. This is only relevant if `autoCreateServiceAccountToken` is true.
    """


class ServiceAccountSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccountSecretReference"]:
            return ServiceAccountSecretReference

        def build(self) -> "ServiceAccountSecretReference":
            return ServiceAccountSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["ServiceAccountSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccountSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccountSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccountSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccountSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class ServiceAccount(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceAccount"]:
            return ServiceAccount

        def build(self) -> "ServiceAccount":
            return ServiceAccount(**self._attrs)

        def environment_name(self, value: str, /) -> Self:
            return self._set("environment_name", value)

        def project_id(self, value: str, /) -> Self:
            return self._set("project_id", value)

        @overload
        def service_account_secret_reference(
            self, value_or_callback: ServiceAccountSecretReference, /
        ) -> "ServiceAccount.Builder": ...

        @overload
        def service_account_secret_reference(
            self,
            value_or_callback: Callable[
                [ServiceAccountSecretReference.Builder],
                ServiceAccountSecretReference.Builder | ServiceAccountSecretReference,
            ],
            /,
        ) -> "ServiceAccount.Builder": ...

        @overload
        def service_account_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccountSecretReference.BuilderContext": ...

        def service_account_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccountSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccountSecretReference.builder())
                if isinstance(output, ServiceAccountSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account_secret_reference", value)

    class BuilderContext(BuilderContextBase["ServiceAccount.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceAccount.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceAccount."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceAccount", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceAccount.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    environment_name: Annotated[str, Field(alias="environmentName")]
    project_id: Annotated[str, Field(alias="projectId")]
    service_account_secret_reference: Annotated[
        ServiceAccountSecretReference, Field(alias="serviceAccountSecretReference")
    ]


class SecretsScopeModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScopeModel"]:
            return SecretsScopeModel

        def build(self) -> "SecretsScopeModel":
            return SecretsScopeModel(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScopeModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScopeModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScopeModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScopeModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScopeModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    recursive: Optional[bool] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class ServiceTokenSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceTokenSecretReference"]:
            return ServiceTokenSecretReference

        def build(self) -> "ServiceTokenSecretReference":
            return ServiceTokenSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["ServiceTokenSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceTokenSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceTokenSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceTokenSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceTokenSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class ServiceToken(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ServiceToken"]:
            return ServiceToken

        def build(self) -> "ServiceToken":
            return ServiceToken(**self._attrs)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScopeModel, /
        ) -> "ServiceToken.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScopeModel.Builder],
                SecretsScopeModel.Builder | SecretsScopeModel,
            ],
            /,
        ) -> "ServiceToken.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScopeModel.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScopeModel.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScopeModel.builder())
                if isinstance(output, SecretsScopeModel.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

        @overload
        def service_token_secret_reference(
            self, value_or_callback: ServiceTokenSecretReference, /
        ) -> "ServiceToken.Builder": ...

        @overload
        def service_token_secret_reference(
            self,
            value_or_callback: Callable[
                [ServiceTokenSecretReference.Builder],
                ServiceTokenSecretReference.Builder | ServiceTokenSecretReference,
            ],
            /,
        ) -> "ServiceToken.Builder": ...

        @overload
        def service_token_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ServiceTokenSecretReference.BuilderContext": ...

        def service_token_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceTokenSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_token_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceTokenSecretReference.builder())
                if isinstance(output, ServiceTokenSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_token_secret_reference", value)

    class BuilderContext(BuilderContextBase["ServiceToken.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ServiceToken.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ServiceToken."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ServiceToken", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ServiceToken.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secrets_scope: Annotated[SecretsScopeModel, Field(alias="secretsScope")]
    service_token_secret_reference: Annotated[
        ServiceTokenSecretReference, Field(alias="serviceTokenSecretReference")
    ]


class CredentialsRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CredentialsRef"]:
            return CredentialsRef

        def build(self) -> "CredentialsRef":
            return CredentialsRef(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["CredentialsRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CredentialsRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CredentialsRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CredentialsRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CredentialsRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class SecretsScopeModel1(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["SecretsScopeModel1"]:
            return SecretsScopeModel1

        def build(self) -> "SecretsScopeModel1":
            return SecretsScopeModel1(**self._attrs)

        def env_slug(self, value: str, /) -> Self:
            return self._set("env_slug", value)

        def project_slug(self, value: str, /) -> Self:
            return self._set("project_slug", value)

        def recursive(self, value: Optional[bool], /) -> Self:
            return self._set("recursive", value)

        def secrets_path(self, value: str, /) -> Self:
            return self._set("secrets_path", value)

    class BuilderContext(BuilderContextBase["SecretsScopeModel1.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = SecretsScopeModel1.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for SecretsScopeModel1."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["SecretsScopeModel1", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use SecretsScopeModel1.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    env_slug: Annotated[str, Field(alias="envSlug")]
    project_slug: Annotated[str, Field(alias="projectSlug")]
    recursive: Optional[bool] = None
    secrets_path: Annotated[str, Field(alias="secretsPath")]


class UniversalAuth(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["UniversalAuth"]:
            return UniversalAuth

        def build(self) -> "UniversalAuth":
            return UniversalAuth(**self._attrs)

        @overload
        def credentials_ref(
            self, value_or_callback: CredentialsRef, /
        ) -> "UniversalAuth.Builder": ...

        @overload
        def credentials_ref(
            self,
            value_or_callback: Callable[
                [CredentialsRef.Builder], CredentialsRef.Builder | CredentialsRef
            ],
            /,
        ) -> "UniversalAuth.Builder": ...

        @overload
        def credentials_ref(
            self, value_or_callback: Never = ...
        ) -> "CredentialsRef.BuilderContext": ...

        def credentials_ref(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = CredentialsRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CredentialsRef.builder())
                if isinstance(output, CredentialsRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials_ref", value)

        @overload
        def secrets_scope(
            self, value_or_callback: SecretsScopeModel1, /
        ) -> "UniversalAuth.Builder": ...

        @overload
        def secrets_scope(
            self,
            value_or_callback: Callable[
                [SecretsScopeModel1.Builder],
                SecretsScopeModel1.Builder | SecretsScopeModel1,
            ],
            /,
        ) -> "UniversalAuth.Builder": ...

        @overload
        def secrets_scope(
            self, value_or_callback: Never = ...
        ) -> "SecretsScopeModel1.BuilderContext": ...

        def secrets_scope(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = SecretsScopeModel1.BuilderContext()
                context._parent_builder = self
                context._field_name = "secrets_scope"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(SecretsScopeModel1.builder())
                if isinstance(output, SecretsScopeModel1.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("secrets_scope", value)

    class BuilderContext(BuilderContextBase["UniversalAuth.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = UniversalAuth.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for UniversalAuth."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["UniversalAuth", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use UniversalAuth.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    credentials_ref: Annotated[CredentialsRef, Field(alias="credentialsRef")]
    secrets_scope: Annotated[SecretsScopeModel1, Field(alias="secretsScope")]


class Authentication(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Authentication"]:
            return Authentication

        def build(self) -> "Authentication":
            return Authentication(**self._attrs)

        @overload
        def aws_iam_auth(
            self, value_or_callback: Optional[AwsIamAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def aws_iam_auth(
            self,
            value_or_callback: Callable[[AwsIamAuth.Builder], AwsIamAuth.Builder | AwsIamAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def aws_iam_auth(self, value_or_callback: Never = ...) -> "AwsIamAuth.BuilderContext": ...

        def aws_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AwsIamAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "aws_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AwsIamAuth.builder())
                if isinstance(output, AwsIamAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("aws_iam_auth", value)

        @overload
        def azure_auth(
            self, value_or_callback: Optional[AzureAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def azure_auth(
            self,
            value_or_callback: Callable[[AzureAuth.Builder], AzureAuth.Builder | AzureAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def azure_auth(self, value_or_callback: Never = ...) -> "AzureAuth.BuilderContext": ...

        def azure_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = AzureAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "azure_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AzureAuth.builder())
                if isinstance(output, AzureAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("azure_auth", value)

        @overload
        def gcp_iam_auth(
            self, value_or_callback: Optional[GcpIamAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_iam_auth(
            self,
            value_or_callback: Callable[[GcpIamAuth.Builder], GcpIamAuth.Builder | GcpIamAuth],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_iam_auth(self, value_or_callback: Never = ...) -> "GcpIamAuth.BuilderContext": ...

        def gcp_iam_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIamAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_iam_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIamAuth.builder())
                if isinstance(output, GcpIamAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_iam_auth", value)

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Optional[GcpIdTokenAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_id_token_auth(
            self,
            value_or_callback: Callable[
                [GcpIdTokenAuth.Builder], GcpIdTokenAuth.Builder | GcpIdTokenAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def gcp_id_token_auth(
            self, value_or_callback: Never = ...
        ) -> "GcpIdTokenAuth.BuilderContext": ...

        def gcp_id_token_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = GcpIdTokenAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "gcp_id_token_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(GcpIdTokenAuth.builder())
                if isinstance(output, GcpIdTokenAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("gcp_id_token_auth", value)

        @overload
        def kubernetes_auth(
            self, value_or_callback: Optional[KubernetesAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def kubernetes_auth(
            self,
            value_or_callback: Callable[
                [KubernetesAuth.Builder], KubernetesAuth.Builder | KubernetesAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def kubernetes_auth(
            self, value_or_callback: Never = ...
        ) -> "KubernetesAuth.BuilderContext": ...

        def kubernetes_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KubernetesAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "kubernetes_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KubernetesAuth.builder())
                if isinstance(output, KubernetesAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("kubernetes_auth", value)

        @overload
        def service_account(
            self, value_or_callback: Optional[ServiceAccount], /
        ) -> "Authentication.Builder": ...

        @overload
        def service_account(
            self,
            value_or_callback: Callable[
                [ServiceAccount.Builder], ServiceAccount.Builder | ServiceAccount
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def service_account(
            self, value_or_callback: Never = ...
        ) -> "ServiceAccount.BuilderContext": ...

        def service_account(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceAccount.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_account"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceAccount.builder())
                if isinstance(output, ServiceAccount.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_account", value)

        @overload
        def service_token(
            self, value_or_callback: Optional[ServiceToken], /
        ) -> "Authentication.Builder": ...

        @overload
        def service_token(
            self,
            value_or_callback: Callable[
                [ServiceToken.Builder], ServiceToken.Builder | ServiceToken
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def service_token(
            self, value_or_callback: Never = ...
        ) -> "ServiceToken.BuilderContext": ...

        def service_token(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ServiceToken.BuilderContext()
                context._parent_builder = self
                context._field_name = "service_token"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ServiceToken.builder())
                if isinstance(output, ServiceToken.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("service_token", value)

        @overload
        def universal_auth(
            self, value_or_callback: Optional[UniversalAuth], /
        ) -> "Authentication.Builder": ...

        @overload
        def universal_auth(
            self,
            value_or_callback: Callable[
                [UniversalAuth.Builder], UniversalAuth.Builder | UniversalAuth
            ],
            /,
        ) -> "Authentication.Builder": ...

        @overload
        def universal_auth(
            self, value_or_callback: Never = ...
        ) -> "UniversalAuth.BuilderContext": ...

        def universal_auth(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = UniversalAuth.BuilderContext()
                context._parent_builder = self
                context._field_name = "universal_auth"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(UniversalAuth.builder())
                if isinstance(output, UniversalAuth.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("universal_auth", value)

    class BuilderContext(BuilderContextBase["Authentication.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Authentication.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Authentication."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Authentication", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Authentication.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    aws_iam_auth: Annotated[Optional[AwsIamAuth], Field(alias="awsIamAuth")] = None
    azure_auth: Annotated[Optional[AzureAuth], Field(alias="azureAuth")] = None
    gcp_iam_auth: Annotated[Optional[GcpIamAuth], Field(alias="gcpIamAuth")] = None
    gcp_id_token_auth: Annotated[Optional[GcpIdTokenAuth], Field(alias="gcpIdTokenAuth")] = None
    kubernetes_auth: Annotated[Optional[KubernetesAuth], Field(alias="kubernetesAuth")] = None
    service_account: Annotated[Optional[ServiceAccount], Field(alias="serviceAccount")] = None
    service_token: Annotated[Optional[ServiceToken], Field(alias="serviceToken")] = None
    universal_auth: Annotated[Optional[UniversalAuth], Field(alias="universalAuth")] = None


class Template(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Template"]:
            return Template

        def build(self) -> "Template":
            return Template(**self._attrs)

        def data(self, value: Optional[Dict[str, str]], /) -> Self:
            """
            The template key values
            """
            return self._set("data", value)

        def include_all_secrets(self, value: Optional[bool], /) -> Self:
            """
            This injects all retrieved secrets into the top level of your template. Secrets defined in the template will take precedence over the injected ones.
            """
            return self._set("include_all_secrets", value)

    class BuilderContext(BuilderContextBase["Template.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Template.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Template."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Template", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Template.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[Dict[str, str]] = None
    """
    The template key values
    """
    include_all_secrets: Annotated[Optional[bool], Field(alias="includeAllSecrets")] = None
    """
    This injects all retrieved secrets into the top level of your template. Secrets defined in the template will take precedence over the injected ones.
    """


class ManagedKubeConfigMapReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedKubeConfigMapReference"]:
            return ManagedKubeConfigMapReference

        def build(self) -> "ManagedKubeConfigMapReference":
            return ManagedKubeConfigMapReference(**self._attrs)

        def config_map_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes ConfigMap
            """
            return self._set("config_map_name", value)

        def config_map_namespace(self, value: str, /) -> Self:
            """
            The namespace where the Kubernetes ConfigMap is located
            """
            return self._set("config_map_namespace", value)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes ConfigMap creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the config map and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the config map owner. This will result in the config map being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedKubeConfigMapReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedKubeConfigMapReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedKubeConfigMapReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedKubeConfigMapReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedKubeConfigMapReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedKubeConfigMapReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedKubeConfigMapReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config_map_name: Annotated[str, Field(alias="configMapName")]
    """
    The name of the Kubernetes ConfigMap
    """
    config_map_namespace: Annotated[str, Field(alias="configMapNamespace")]
    """
    The namespace where the Kubernetes ConfigMap is located
    """
    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes ConfigMap creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the config map and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the config map owner. This will result in the config map being orphaned and not deleted when the resource is deleted.
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class ManagedKubeSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedKubeSecretReference"]:
            return ManagedKubeSecretReference

        def build(self) -> "ManagedKubeSecretReference":
            return ManagedKubeSecretReference(**self._attrs)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

        def secret_type(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
            """
            return self._set("secret_type", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedKubeSecretReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedKubeSecretReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedKubeSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedKubeSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedKubeSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedKubeSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedKubeSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes Secret creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """
    secret_type: Annotated[Optional[str], Field(alias="secretType")] = "Opaque"
    """
    The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class ManagedSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ManagedSecretReference"]:
            return ManagedSecretReference

        def build(self) -> "ManagedSecretReference":
            return ManagedSecretReference(**self._attrs)

        def creation_policy(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
            """
            return self._set("creation_policy", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

        def secret_type(self, value: Optional[str], /) -> Self:
            """
            The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
            """
            return self._set("secret_type", value)

        @overload
        def template(
            self, value_or_callback: Optional[Template], /
        ) -> "ManagedSecretReference.Builder": ...

        @overload
        def template(
            self,
            value_or_callback: Callable[[Template.Builder], Template.Builder | Template],
            /,
        ) -> "ManagedSecretReference.Builder": ...

        @overload
        def template(self, value_or_callback: Never = ...) -> "Template.BuilderContext": ...

        def template(self, value_or_callback=None, /):
            """
            The template to transform the secret data
            """
            if self._in_context and value_or_callback is None:
                context = Template.BuilderContext()
                context._parent_builder = self
                context._field_name = "template"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Template.builder())
                if isinstance(output, Template.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("template", value)

    class BuilderContext(BuilderContextBase["ManagedSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ManagedSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ManagedSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ManagedSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ManagedSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    creation_policy: Annotated[Optional[str], Field(alias="creationPolicy")] = "Orphan"
    """
    The Kubernetes Secret creation policy. Enum with values: 'Owner', 'Orphan'. Owner creates the secret and sets .metadata.ownerReferences of the InfisicalSecret CRD that created it. Orphan will not set the secret owner. This will result in the secret being orphaned and not deleted when the resource is deleted.
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """
    secret_type: Annotated[Optional[str], Field(alias="secretType")] = "Opaque"
    """
    The Kubernetes Secret type (experimental feature). More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
    """
    template: Optional[Template] = None
    """
    The template to transform the secret data
    """


class CaRef(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["CaRef"]:
            return CaRef

        def build(self) -> "CaRef":
            return CaRef(**self._attrs)

        def key(self, value: str, /) -> Self:
            """
            The name of the secret property with the CA certificate value
            """
            return self._set("key", value)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The namespace where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["CaRef.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = CaRef.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for CaRef."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["CaRef", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use CaRef.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    key: str
    """
    The name of the secret property with the CA certificate value
    """
    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The namespace where the Kubernetes Secret is located
    """


class Tls(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Tls"]:
            return Tls

        def build(self) -> "Tls":
            return Tls(**self._attrs)

        @overload
        def ca_ref(self, value_or_callback: Optional[CaRef], /) -> "Tls.Builder": ...

        @overload
        def ca_ref(
            self, value_or_callback: Callable[[CaRef.Builder], CaRef.Builder | CaRef], /
        ) -> "Tls.Builder": ...

        @overload
        def ca_ref(self, value_or_callback: Never = ...) -> "CaRef.BuilderContext": ...

        def ca_ref(self, value_or_callback=None, /):
            """
            Reference to secret containing CA cert
            """
            if self._in_context and value_or_callback is None:
                context = CaRef.BuilderContext()
                context._parent_builder = self
                context._field_name = "ca_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(CaRef.builder())
                if isinstance(output, CaRef.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("ca_ref", value)

    class BuilderContext(BuilderContextBase["Tls.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Tls.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Tls."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Tls", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Tls.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ca_ref: Annotated[Optional[CaRef], Field(alias="caRef")] = None
    """
    Reference to secret containing CA cert
    """


class TokenSecretReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["TokenSecretReference"]:
            return TokenSecretReference

        def build(self) -> "TokenSecretReference":
            return TokenSecretReference(**self._attrs)

        def secret_name(self, value: str, /) -> Self:
            """
            The name of the Kubernetes Secret
            """
            return self._set("secret_name", value)

        def secret_namespace(self, value: str, /) -> Self:
            """
            The name space where the Kubernetes Secret is located
            """
            return self._set("secret_namespace", value)

    class BuilderContext(BuilderContextBase["TokenSecretReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = TokenSecretReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for TokenSecretReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["TokenSecretReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use TokenSecretReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    secret_name: Annotated[str, Field(alias="secretName")]
    """
    The name of the Kubernetes Secret
    """
    secret_namespace: Annotated[str, Field(alias="secretNamespace")]
    """
    The name space where the Kubernetes Secret is located
    """


class InfisicalSecretSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecretSpec"]:
            return InfisicalSecretSpec

        def build(self) -> "InfisicalSecretSpec":
            return InfisicalSecretSpec(**self._attrs)

        @overload
        def authentication(
            self, value_or_callback: Optional[Authentication], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def authentication(
            self,
            value_or_callback: Callable[
                [Authentication.Builder], Authentication.Builder | Authentication
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def authentication(
            self, value_or_callback: Never = ...
        ) -> "Authentication.BuilderContext": ...

        def authentication(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Authentication.BuilderContext()
                context._parent_builder = self
                context._field_name = "authentication"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Authentication.builder())
                if isinstance(output, Authentication.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("authentication", value)

        def host_api(self, value: Optional[str], /) -> Self:
            """
            Infisical host to pull secrets from
            """
            return self._set("host_api", value)

        @overload
        def managed_kube_config_map_references(
            self, value_or_callback: List[ManagedKubeConfigMapReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_config_map_references(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ManagedKubeConfigMapReference,
                        ManagedKubeConfigMapReference.Builder,
                    ]
                ],
                GenericListBuilder[
                    ManagedKubeConfigMapReference, ManagedKubeConfigMapReference.Builder
                ]
                | List[ManagedKubeConfigMapReference],
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_config_map_references(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ManagedKubeConfigMapReference.Builder]: ...

        def managed_kube_config_map_references(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ManagedKubeConfigMapReference.Builder]()
                context._parent_builder = self
                context._field_name = "managed_kube_config_map_references"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedKubeConfigMapReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_kube_config_map_references", value)

        @overload
        def managed_kube_secret_references(
            self, value_or_callback: List[ManagedKubeSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_secret_references(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ManagedKubeSecretReference, ManagedKubeSecretReference.Builder
                    ]
                ],
                GenericListBuilder[ManagedKubeSecretReference, ManagedKubeSecretReference.Builder]
                | List[ManagedKubeSecretReference],
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_kube_secret_references(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ManagedKubeSecretReference.Builder]: ...

        def managed_kube_secret_references(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ManagedKubeSecretReference.Builder]()
                context._parent_builder = self
                context._field_name = "managed_kube_secret_references"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedKubeSecretReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_kube_secret_references", value)

        @overload
        def managed_secret_reference(
            self, value_or_callback: Optional[ManagedSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self,
            value_or_callback: Callable[
                [ManagedSecretReference.Builder],
                ManagedSecretReference.Builder | ManagedSecretReference,
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def managed_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "ManagedSecretReference.BuilderContext": ...

        def managed_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ManagedSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "managed_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ManagedSecretReference.builder())
                if isinstance(output, ManagedSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("managed_secret_reference", value)

        def resync_interval(self, value: Optional[int], /) -> Self:
            return self._set("resync_interval", value)

        @overload
        def tls(self, value_or_callback: Optional[Tls], /) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def tls(
            self, value_or_callback: Callable[[Tls.Builder], Tls.Builder | Tls], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def tls(self, value_or_callback: Never = ...) -> "Tls.BuilderContext": ...

        def tls(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = Tls.BuilderContext()
                context._parent_builder = self
                context._field_name = "tls"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Tls.builder())
                if isinstance(output, Tls.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("tls", value)

        @overload
        def token_secret_reference(
            self, value_or_callback: Optional[TokenSecretReference], /
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def token_secret_reference(
            self,
            value_or_callback: Callable[
                [TokenSecretReference.Builder],
                TokenSecretReference.Builder | TokenSecretReference,
            ],
            /,
        ) -> "InfisicalSecretSpec.Builder": ...

        @overload
        def token_secret_reference(
            self, value_or_callback: Never = ...
        ) -> "TokenSecretReference.BuilderContext": ...

        def token_secret_reference(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = TokenSecretReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "token_secret_reference"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(TokenSecretReference.builder())
                if isinstance(output, TokenSecretReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("token_secret_reference", value)

    class BuilderContext(BuilderContextBase["InfisicalSecretSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecretSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecretSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecretSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecretSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    authentication: Optional[Authentication] = None
    host_api: Annotated[Optional[str], Field(alias="hostAPI")] = None
    """
    Infisical host to pull secrets from
    """
    managed_kube_config_map_references: Annotated[
        Optional[List[ManagedKubeConfigMapReference]],
        Field(alias="managedKubeConfigMapReferences"),
    ] = None
    managed_kube_secret_references: Annotated[
        Optional[List[ManagedKubeSecretReference]],
        Field(alias="managedKubeSecretReferences"),
    ] = None
    managed_secret_reference: Annotated[
        Optional[ManagedSecretReference], Field(alias="managedSecretReference")
    ] = None
    resync_interval: Annotated[Optional[int], Field(alias="resyncInterval")] = 60
    tls: Optional[Tls] = None
    token_secret_reference: Annotated[
        Optional[TokenSecretReference], Field(alias="tokenSecretReference")
    ] = None


class Condition(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Condition"]:
            return Condition

        def build(self) -> "Condition":
            return Condition(**self._attrs)

        def last_transition_time(self, value: datetime, /) -> Self:
            """
            lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
            """
            return self._set("last_transition_time", value)

        def message(self, value: str, /) -> Self:
            """
            message is a human readable message indicating details about the transition. This may be an empty string.
            """
            return self._set("message", value)

        def observed_generation(self, value: Optional[int], /) -> Self:
            """
            observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
            """
            return self._set("observed_generation", value)

        def reason(self, value: str, /) -> Self:
            """
            reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
            """
            return self._set("reason", value)

        def status(self, value: Literal["True", "False", "Unknown"], /) -> Self:
            """
            status of the condition, one of True, False, Unknown.
            """
            return self._set("status", value)

        def type(self, value: str, /) -> Self:
            """
            type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
            """
            return self._set("type", value)

    class BuilderContext(BuilderContextBase["Condition.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Condition.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Condition."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Condition", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Condition.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    last_transition_time: Annotated[datetime, Field(alias="lastTransitionTime")]
    """
    lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
    """
    message: Annotated[str, Field(max_length=32768)]
    """
    message is a human readable message indicating details about the transition. This may be an empty string.
    """
    observed_generation: Annotated[Optional[int], Field(alias="observedGeneration", ge=0)] = None
    """
    observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
    """
    reason: Annotated[
        str,
        Field(
            max_length=1024,
            min_length=1,
            pattern="^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$",
        ),
    ]
    """
    reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
    """
    status: Literal["True", "False", "Unknown"]
    """
    status of the condition, one of True, False, Unknown.
    """
    type: Annotated[
        str,
        Field(
            max_length=316,
            pattern="^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$",
        ),
    ]
    """
    type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are consistent across resources like Available, but because arbitrary conditions can be useful (see .node.status.conditions), the ability to deconflict is important. The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
    """


class InfisicalSecretStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecretStatus"]:
            return InfisicalSecretStatus

        def build(self) -> "InfisicalSecretStatus":
            return InfisicalSecretStatus(**self._attrs)

        @overload
        def conditions(
            self, value_or_callback: List[Condition], /
        ) -> "InfisicalSecretStatus.Builder": ...

        @overload
        def conditions(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[Condition, Condition.Builder]],
                GenericListBuilder[Condition, Condition.Builder] | List[Condition],
            ],
            /,
        ) -> "InfisicalSecretStatus.Builder": ...

        @overload
        def conditions(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[Condition.Builder]: ...

        def conditions(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[Condition.Builder]()
                context._parent_builder = self
                context._field_name = "conditions"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Condition.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("conditions", value)

    class BuilderContext(BuilderContextBase["InfisicalSecretStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecretStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecretStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecretStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecretStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    conditions: List[Condition]


class InfisicalSecret(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["InfisicalSecret"]:
            return InfisicalSecret

        def build(self) -> "InfisicalSecret":
            return InfisicalSecret(**self._attrs)

        def api_version(
            self, value: Optional[Literal["secrets.infisical.com/v1alpha1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["InfisicalSecret"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[v1.ObjectMeta], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: Optional[InfisicalSecretSpec], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [InfisicalSecretSpec.Builder],
                InfisicalSecretSpec.Builder | InfisicalSecretSpec,
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "InfisicalSecretSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalSecretSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalSecretSpec.builder())
                if isinstance(output, InfisicalSecretSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[InfisicalSecretStatus], /
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [InfisicalSecretStatus.Builder],
                InfisicalSecretStatus.Builder | InfisicalSecretStatus,
            ],
            /,
        ) -> "InfisicalSecret.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "InfisicalSecretStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = InfisicalSecretStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(InfisicalSecretStatus.builder())
                if isinstance(output, InfisicalSecretStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["InfisicalSecret.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = InfisicalSecret.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for InfisicalSecret."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["InfisicalSecret", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use InfisicalSecret.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["secrets.infisical.com/v1alpha1"]], Field(alias="apiVersion")
    ] = "secrets.infisical.com/v1alpha1"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["InfisicalSecret"]] = "InfisicalSecret"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[InfisicalSecretSpec] = None
    status: Optional[InfisicalSecretStatus] = None
