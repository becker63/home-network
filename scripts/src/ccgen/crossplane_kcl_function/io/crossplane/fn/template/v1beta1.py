# Generated by cloudcoil-model-codegen v0.5.8
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Any,
    Callable,
    Dict,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource
from pydantic import Field

from ....k8s.apimachinery.pkg.apis.meta import v1


class Config(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Config"]:
            return Config

        def build(self) -> "Config":
            return Config(**self._attrs)

        def arguments(self, value: Optional[List[str]], /) -> Self:
            """
            Arguments is the list of top level dynamic arguments for the kcl option function, e.g., env="prod"
            """
            return self._set("arguments", value)

        def debug(self, value: Optional[bool], /) -> Self:
            """
            Debug denotes running kcl in debug mode.
            """
            return self._set("debug", value)

        def disable_none(self, value: Optional[bool], /) -> Self:
            """
            DisableNone denotes running kcl and disable dumping None values.
            """
            return self._set("disable_none", value)

        def overrides(self, value: Optional[List[str]], /) -> Self:
            """
            Overrides is the list of override paths and values, e.g., app.image="v2"
            """
            return self._set("overrides", value)

        def path_selectors(self, value: Optional[List[str]], /) -> Self:
            """
            PathSelectors is the list of path selectors to select output result, e.g., a.b.c
            """
            return self._set("path_selectors", value)

        def settings(self, value: Optional[List[str]], /) -> Self:
            """
            Settings is the list of kcl setting files including all of the CLI config.
            """
            return self._set("settings", value)

        def show_hidden(self, value: Optional[bool], /) -> Self:
            """
            ShowHidden denotes output the hidden attribute in the result.
            """
            return self._set("show_hidden", value)

        def sort_keys(self, value: Optional[bool], /) -> Self:
            """
            SortKeys denotes sorting the output result keys, e.g., `{b = 1, a = 2} => {a = 2, b = 1}`.
            """
            return self._set("sort_keys", value)

        def strict_range_check(self, value: Optional[bool], /) -> Self:
            """
            StrictRangeCheck performs the 32-bit strict numeric range checks on numbers.
            """
            return self._set("strict_range_check", value)

        def vendor(self, value: Optional[bool], /) -> Self:
            """
            Vendor denotes running kcl in the vendor mode.
            """
            return self._set("vendor", value)

    class BuilderContext(BuilderContextBase["Config.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Config.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Config."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Config", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Config.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    arguments: Optional[List[str]] = None
    """
    Arguments is the list of top level dynamic arguments for the kcl option function, e.g., env="prod"
    """
    debug: Optional[bool] = None
    """
    Debug denotes running kcl in debug mode.
    """
    disable_none: Annotated[Optional[bool], Field(alias="disableNone")] = None
    """
    DisableNone denotes running kcl and disable dumping None values.
    """
    overrides: Optional[List[str]] = None
    """
    Overrides is the list of override paths and values, e.g., app.image="v2"
    """
    path_selectors: Annotated[Optional[List[str]], Field(alias="pathSelectors")] = None
    """
    PathSelectors is the list of path selectors to select output result, e.g., a.b.c
    """
    settings: Optional[List[str]] = None
    """
    Settings is the list of kcl setting files including all of the CLI config.
    """
    show_hidden: Annotated[Optional[bool], Field(alias="showHidden")] = None
    """
    ShowHidden denotes output the hidden attribute in the result.
    """
    sort_keys: Annotated[Optional[bool], Field(alias="sortKeys")] = None
    """
    SortKeys denotes sorting the output result keys, e.g., `{b = 1, a = 2} => {a = 2, b = 1}`.
    """
    strict_range_check: Annotated[Optional[bool], Field(alias="strictRangeCheck")] = None
    """
    StrictRangeCheck performs the 32-bit strict numeric range checks on numbers.
    """
    vendor: Optional[bool] = None
    """
    Vendor denotes running kcl in the vendor mode.
    """


class Credentials(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["Credentials"]:
            return Credentials

        def build(self) -> "Credentials":
            return Credentials(**self._attrs)

        def password(self, value: str, /) -> Self:
            return self._set("password", value)

        def url(self, value: Optional[str], /) -> Self:
            return self._set("url", value)

        def username(self, value: str, /) -> Self:
            return self._set("username", value)

    class BuilderContext(BuilderContextBase["Credentials.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = Credentials.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for Credentials."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["Credentials", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use Credentials.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    password: str
    url: Optional[str] = None
    username: str


class ResourceModel(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceModel"]:
            return ResourceModel

        def build(self) -> "ResourceModel":
            return ResourceModel(**self._attrs)

        def base(self, value: Optional[Dict[str, Any]], /) -> Self:
            """
            Base of the composed resource that patches will be applied to.
            According to the patches and transforms functions, this may be ommited on
            occassion by a previous pipeline
            """
            return self._set("base", value)

        def name(self, value: str, /) -> Self:
            """
            Name is a unique identifier for this entry in a ResourceList
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ResourceModel.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceModel.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceModel."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceModel", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceModel.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    base: Optional[Dict[str, Any]] = None
    """
    Base of the composed resource that patches will be applied to.
    According to the patches and transforms functions, this may be ommited on
    occassion by a previous pipeline
    """
    name: str
    """
    Name is a unique identifier for this entry in a ResourceList
    """


class KCLInputSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KCLInputSpec"]:
            return KCLInputSpec

        def build(self) -> "KCLInputSpec":
            return KCLInputSpec(**self._attrs)

        @overload
        def config(self, value_or_callback: Optional[Config], /) -> "KCLInputSpec.Builder": ...

        @overload
        def config(
            self,
            value_or_callback: Callable[[Config.Builder], Config.Builder | Config],
            /,
        ) -> "KCLInputSpec.Builder": ...

        @overload
        def config(self, value_or_callback: Never = ...) -> "Config.BuilderContext": ...

        def config(self, value_or_callback=None, /):
            """
            Config is the compile config.
            """
            if self._in_context and value_or_callback is None:
                context = Config.BuilderContext()
                context._parent_builder = self
                context._field_name = "config"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Config.builder())
                if isinstance(output, Config.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("config", value)

        @overload
        def credentials(
            self, value_or_callback: Optional[Credentials], /
        ) -> "KCLInputSpec.Builder": ...

        @overload
        def credentials(
            self,
            value_or_callback: Callable[[Credentials.Builder], Credentials.Builder | Credentials],
            /,
        ) -> "KCLInputSpec.Builder": ...

        @overload
        def credentials(self, value_or_callback: Never = ...) -> "Credentials.BuilderContext": ...

        def credentials(self, value_or_callback=None, /):
            """
            Credentials for remote locations
            """
            if self._in_context and value_or_callback is None:
                context = Credentials.BuilderContext()
                context._parent_builder = self
                context._field_name = "credentials"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(Credentials.builder())
                if isinstance(output, Credentials.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("credentials", value)

        def dependencies(self, value: Optional[str], /) -> Self:
            """
            Dependencies are the external dependencies for the KCL code.
            The format of the `dependencies` field is same as the `[dependencies]` in the `kcl.mod` file
            """
            return self._set("dependencies", value)

        def params(self, value: Optional[Dict[str, Dict[str, Any]]], /) -> Self:
            """
            Params are the parameters in key-value pairs format.
            """
            return self._set("params", value)

        @overload
        def resources(
            self, value_or_callback: List[ResourceModel], /
        ) -> "KCLInputSpec.Builder": ...

        @overload
        def resources(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceModel, ResourceModel.Builder]],
                GenericListBuilder[ResourceModel, ResourceModel.Builder] | List[ResourceModel],
            ],
            /,
        ) -> "KCLInputSpec.Builder": ...

        @overload
        def resources(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceModel.Builder]: ...

        def resources(self, value_or_callback=None, /):
            """
            Resources is a list of resources to patch and create
            This is utilized when a Target is set to PatchResources
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceModel.Builder]()
                context._parent_builder = self
                context._field_name = "resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceModel.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resources", value)

        def source(self, value: str, /) -> Self:
            """
            Source is a required field for providing a KCL script inline.
            """
            return self._set("source", value)

        def target(
            self,
            value: Optional[
                Literal["Default", "PatchDesired", "PatchResources", "Resources", "XR"]
            ],
            /,
        ) -> Self:
            """
            Target determines what object the export output should be applied to
            """
            return self._set("target", value)

    class BuilderContext(BuilderContextBase["KCLInputSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KCLInputSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KCLInputSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KCLInputSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KCLInputSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    config: Optional[Config] = None
    """
    Config is the compile config.
    """
    credentials: Optional[Credentials] = None
    """
    Credentials for remote locations
    """
    dependencies: Optional[str] = None
    """
    Dependencies are the external dependencies for the KCL code.
    The format of the `dependencies` field is same as the `[dependencies]` in the `kcl.mod` file
    """
    params: Optional[Dict[str, Dict[str, Any]]] = None
    """
    Params are the parameters in key-value pairs format.
    """
    resources: Optional[List[ResourceModel]] = None
    """
    Resources is a list of resources to patch and create
    This is utilized when a Target is set to PatchResources
    """
    source: str
    """
    Source is a required field for providing a KCL script inline.
    """
    target: Optional[Literal["Default", "PatchDesired", "PatchResources", "Resources", "XR"]] = (
        "Resources"
    )
    """
    Target determines what object the export output should be applied to
    """


class KCLInput(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["KCLInput"]:
            return KCLInput

        def build(self) -> "KCLInput":
            return KCLInput(**self._attrs)

        def api_version(
            self, value: Optional[Literal["template.fn.crossplane.io/v1beta1"]], /
        ) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object.
            Servers should convert recognized schemas to the latest internal value, and
            may reject unrecognized values.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["KCLInput"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents.
            Servers may infer this from the endpoint the client submits requests to.
            Cannot be updated.
            In CamelCase.
            More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(self, value_or_callback: Optional[v1.ObjectMeta], /) -> "KCLInput.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [v1.ObjectMeta.Builder], v1.ObjectMeta.Builder | v1.ObjectMeta
            ],
            /,
        ) -> "KCLInput.Builder": ...

        @overload
        def metadata(self, value_or_callback: Never = ...) -> "v1.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = v1.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.ObjectMeta.builder())
                if isinstance(output, v1.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: Optional[KCLInputSpec], /) -> "KCLInput.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [KCLInputSpec.Builder], KCLInputSpec.Builder | KCLInputSpec
            ],
            /,
        ) -> "KCLInput.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "KCLInputSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            if self._in_context and value_or_callback is None:
                context = KCLInputSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(KCLInputSpec.builder())
                if isinstance(output, KCLInputSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["KCLInput.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = KCLInput.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for KCLInput."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["KCLInput", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use KCLInput.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["template.fn.crossplane.io/v1beta1"]],
        Field(alias="apiVersion"),
    ] = "template.fn.crossplane.io/v1beta1"
    """
    APIVersion defines the versioned schema of this representation of an object.
    Servers should convert recognized schemas to the latest internal value, and
    may reject unrecognized values.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["KCLInput"]] = "KCLInput"
    """
    Kind is a string value representing the REST resource this object represents.
    Servers may infer this from the endpoint the client submits requests to.
    Cannot be updated.
    In CamelCase.
    More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[v1.ObjectMeta] = None
    spec: Optional[KCLInputSpec] = None
